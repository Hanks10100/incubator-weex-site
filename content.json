{"meta":{"title":"Weex","subtitle":null,"description":"A framework for building Mobile cross-platform UIs. Different from a \"web app\", \"HTML5 app\", or \"hybrid app\", you can use Weex to build a real mobile app. The code that you write is relatively simple, because you can build native applications just using HTML, CSS, Javascript. But underneath, the core of the application is Objective-C or Java. At the same time, Weex will provide a lot of native components or modules for developers to use.","author":"Jinjiang","url":"https://weex.apache.org"},"pages":[{"title":"How to Contribute","path":"contributing.html","permalink":"https://weex.apache.org/contributing.html","text":"How to Contribute#Welcome to create pull requests or join in our mailing list for bugfix, doc, example, suggestion and anything. Join in Weex Mailing List#In Weex community all discussion will happen on mailing list. Just send an email to dev-subscribe@weex.incubator.apache.org and follow the instructions to subscribe Weex dev mailing list. And then you will receive all discussions and community messages by your personal email. In the same time you can freely send your own emails to join in us. At the same time you can see the archives of all the mails through the web: http://mail-archives.apache.org/mod_mbox/incubator-weex-dev/ If you won’t follow the mailing list any more. There is another way to unsubscribe it: send an email to dev-unsubscribe@weex.incubator.apache.org and follow the instructions. Besides Weex dev mailing list, we also have some other mailing lists for you. You can check them out here: http://mail-archives.apache.org/mod_mbox/#weex.incubator Branch Management#release ↑release-&#123;version&#125; ↑master &lt;--- PR(feature/hotfix/typo) master branch master is the stable developing branch. It’s RECOMMENDED to commit hotfix (like typo) or feature PR to master. release-{version} branch release-{version} is used for every version which we consider for stable publish. e.g. release-0.16 release branch release is the latest release branch,we will make tag and publish version on this branch. Branch Name For PR#&#123;module&#125;-&#123;action&#125;-&#123;shortName&#125; {module}, see commit log module {action} feature: checkout from {module} and merge to {module} later. If {module} not exists, merge to dev bugfix: like feature, for bugfix only hotfix: checkout from master or release tag, merge to master and {module} later. If {module} not exists, merge to dev for example: android-bugfix-memory jsfm-feature-communication android-hotfix-compute-layout Commit Log#&#123;action&#125; [&#123;module&#125;] &#123;description&#125; {action} + add * update or bugfix - remove {module} Including: android, ios, jsfm, html5, component, doc, website, example, test, all {description} Just make it as clear and simple as possible. for example: + [android] close #123, add refreshing for WebView * [doc] fix #123, update video auto-play property - [example] remove abc Pull Request#You can create pull requests in GitHub. First we suggest you have some discussion with the community (commonly in our mailing list) before you code. Fork repo from https://github.com/apache/incubator-weex/ Finish the job you want to do. Create a pull request. Code Style Guide#Objective-C# Tabs for indentation(not spaces) * operator goes with the variable name (e.g. Type *variable;) Function definitions: place each brace on its own line. Other braces: place the open brace on the line preceding the code block; place the close brace on its own line. Use #pragma marks to categorize methods into functional groupings and protocol implementations Follow other guidelines on GitHub Objective-C Style Guide Java &amp; Android# Use Google Java Style as basic guidelines of java code. Follow AOSP Code Style for rest of android related code style.","type":"community"},{"title":"Development Process","path":"development-process.html","permalink":"https://weex.apache.org/development-process.html","text":"","type":"community"},{"title":"Resources","path":"resources.html","permalink":"https://weex.apache.org/resources.html","text":"","type":"community"},{"title":"Who is Using Weex?","path":"who-is-using-weex.html","permalink":"https://weex.apache.org/who-is-using-weex.html","text":"","type":"community"},{"title":"","path":"cn/blog.html","permalink":"https://weex.apache.org/cn/blog.html","text":"","type":"blog"},{"title":"如何参与 Weex 的开发","path":"cn/contributing.html","permalink":"https://weex.apache.org/cn/contributing.html","text":"如何参与社区#加入 Weex 邮件列表 (Mailing List)#在 Weex 官方社区所有的信息都会汇聚于邮件列表。订阅开发邮件列表的方式是发送邮件到 dev-subscribe@weex.incubator.apache.org 然后你的邮箱会收到一封来自 Apache 的回信 (英文)，把 Apache 的这封回信再次回复过去，即可完成订阅。 这里需要强调的是 Apache 是一个面向全球的全英文的社区，所以我们希望您能够用英文在邮件列表中跟大家交流。 如果您确实对使用英文存在很大的疑虑或困惑，我们也非常欢迎大家来中文问答平台 SegmentFault 提问，这里有非常多热心的开发者一起讨论和解答 Weex 相关的问题。 使用邮件列表的另外一个好处是它可以方便大家随时查阅之前的邮件记录: http://mail-archives.apache.org/mod_mbox/incubator-weex-dev/ 如果您对邮件列表中的内容已经不再感兴趣，这里也有退订邮件列表的方法: 发送邮件至 dev-unsubscribe@weex.incubator.apache.org 并根据回信的提示进行二次回复确认，完成退订。 除了开发 (dev) 邮件列表，我们还有另外几个的邮件列表供大家查阅：http://mail-archives.apache.org/mod_mbox/#weex.incubator 分支管理 (英)#release ↑release-&#123;version&#125; ↑master &lt;--- PR(feature/hotfix/typo) master branch master is the stable developing branch. It’s RECOMMENDED to commit hotfix (like typo) or feature PR to master. release-{version} branch release-{version} is used for every version which we consider for stable publish. e.g. release-0.16 release branch release is the latest release branch,we will make tag and publish version on this branch. 用于PR的分支命名#&#123;module&#125;-&#123;action&#125;-&#123;shortName&#125; {module}, see commit log module {action} feature: checkout from {module} and merge to {module} later. If {module} not exists, merge to dev bugfix: like feature, for bugfix only hotfix: checkout from master or release tag, merge to master and {module} later. If {module} not exists, merge to dev for example: android-bugfix-memory jsfm-feature-communication android-hotfix-compute-layout 提交日志格式 (英)#&#123;action&#125; [&#123;module&#125;] &#123;description&#125; {action} + add * update or bugfix - remove {module} Including: android, ios, jsfm, html5, component, doc, website, example, test, all {description} Just make it as clear and simple as possible. for example: + [android] close #123, add refreshing for WebView * [doc] fix #123, update video auto-play property - [example] remove abc 发送 Pull Request (英)#You can create pull requests in GitHub. First we suggest you have some discussion with the community (commonly in our mailing list) before you code. Fork repo from https://github.com/apache/incubator-weex/ Finish the job you want to do. Create a pull request. 编码规范 (英)#Objective-C# Tabs for indentation(not spaces) * operator goes with the variable name (e.g. Type *variable;) Function definitions: place each brace on its own line. Other braces: place the open brace on the line preceding the code block; place the close brace on its own line. Use #pragma marks to categorize methods into functional groupings and protocol implementations Follow other guidelines on GitHub Objective-C Style Guide Java &amp; Android# Use Google Java Style as basic guidelines of java code. Follow AOSP Code Style for rest of android related code style.","type":"community"},{"title":"开发流程","path":"cn/development-process.html","permalink":"https://weex.apache.org/cn/development-process.html","text":"","type":"community"},{"title":"资源","path":"cn/resources.html","permalink":"https://weex.apache.org/cn/resources.html","text":"","type":"community"},{"title":"谁在使用 Weex？","path":"cn/who-is-using-weex.html","permalink":"https://weex.apache.org/cn/who-is-using-weex.html","text":"","type":"community"},{"title":"Extend Android","path":"guide/extend-android.html","permalink":"https://weex.apache.org/guide/extend-android.html","text":"Module extend#weex sdk support Module extend, Weex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want the these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module Follow the steps below. Step to customize a module# Customize module must extend WXModule @WXModuleAnno annotation must be added, as it is the only the way to recognized by Weex The access levels of mehtod must be public The module class also can not be an inner class Customize can not be obfuscated by tools like ProGuard Module methods will be invoked in UI thread, do not put time consuming operation there Weex params can be int, double, float, String, Map, List Refer to the following example: public class WXEventModule extends WXModule&#123; private static final String WEEX_CATEGORY=\"com.taobao.android.intent.category.WEEX\"; @WXModuleAnno public void openURL(String url)&#123; //implement your module logic here &#125;&#125; Support synchronous/asynchronous callback#You can add @JSMethod (uiThread = false or true) annotation to choose the callback mode of moudle. See the follow example. // as sync-callback mode@JSMethod (uiThread = false)public void testSyncCall()&#123; WXLogUtils.d(\"WXComponentSyncTest : Thread.currentThread().getName());&#125;// as async-callback mode@JSMethod (uiThread = true)public void testAsyncCall()&#123; WXLogUtils.e(\"WXComponentASynTest : Thread.currentThread().getName() );&#125; Register the moulde#WXSDKEngine.registerModule(\"event\", WXEventModule.class); Use this module in weex DSL#Now event moudle is avaiable in weex, use the module like this: var event = weex.requireModule('event');event.openURL(\"http://www.github.com\"); Javascript callback#If the module need implement a callback to javascript, you just add JSCallback argument to the method you want expose to javascript: @WXModuleAnnopublic void openURL(String url,JSCallback callback)&#123; //implement your module logic here Map&lt;String,Object&gt; resp = new HashMap(); resp.put(\"result\",\"ok\"); callback.invoke(resp);&#125; At the javascript side, call the module with javascript function to receive callback data: event.openURL(\"http://www.github.com\",function(resp)&#123; console.log(resp.result); &#125;); Component extend#There are label, image, div, scroll, ect. components in weex, you can also customize your own components. Step to customize a component# Customize components must extend WXComponent or WXContainer @WXComponentProp(name=value(value is attr or style of dsl)) for it be recognized by weex SDK. The access levels of mehtod must be public The component class can not be an inner class Customize can not be obfuscated by tools like ProGuard Component methods will be invoked in UI thread, do not put time consuming operation there. Weex params can be int, double, float, String, Map, List, Array Refer to the following example public class MyViewComponent extends WXComponent&#123; public MyViewComponent(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, String instanceId, boolean isLazy) &#123; public MyViewComponent(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, String instanceId, boolean isLazy) &#123; super(instance, dom, parent, instanceId, isLazy); &#125; @Override protected void initView() &#123; mHost = new TextView(mContext); &#125; @WXComponentProp(name=WXDomPropConstant.WX_ATTR_VALUE) public void setMyViewValue(String value) &#123; ((TextView)mHost).setText(value); &#125;&#125; Register the Component#WXSDKEngine.registerComponent(\"MyView\", MyViewComponent.class); Adapter extend#ImagedownloadAdapter#Weex SDK has no image download capability, you need to implement IWXImgLoaderAdapter. Refer to the following examples. public class ImageAdapter implements IWXImgLoaderAdapter &#123; private Activity mContext; public ImageAdapter(Activity activity) &#123; mContext = activity; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; mContext.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\"))&#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width&lt;=0 || view.getLayoutParams().height&lt;=0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .resize(view.getLayoutParams().width, view.getLayoutParams().height).into(view); &#125; &#125;); &#125;&#125; Component Method# from WeexSDK 0.9.5, you can define your component method for example, define a method in component: @JSMethodpublic void focus()&#123; //method implementation&#125; after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt; Proguard Rules#If you want to using proguard to protect your source code, please add the following rules to your profile: -keep class com.taobao.weex.WXDebugTool&#123;*;&#125;-keep class com.taobao.weex.devtools.common.LogUtil&#123;*;&#125;-keep public class * extends com.taobao.weex.ui.component.WXComponent&#123;*;&#125;-keep public class * extends com.taobao.weex.common.WXModule&#123;*;&#125;-keepclassmembers class ** &#123; @com.taobao.weex.ui.component.WXComponentProp public *;&#125;","type":"guide"},{"title":"Extend iOS","path":"guide/extend-ios.html","permalink":"https://weex.apache.org/guide/extend-ios.html","text":"Notice#All of the exported APIs in Weex are controllable and safe, they can not access private APIs or do any system hacks at runtime, neither can they change the primary purpose of the Application. If you are extending your custom modules/components, be sure NOT to export the ability of Objective-C runtime, be sure NOT to export dynamic and uncontrolled methods such as dlopen(), dlsym(), respondsToSelector:, performSelector:, method_exchangeImplementations(), be sure NOT to export any private methods. Module extend#Weex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module following the steps below. Step to customize a module# Module customized must implement WXModuleProtocol A macro named WX_EXPORT_METHOD must be added, as it is the only way to export methods to JavaScript. The weexInstance should be synthesized. Each module object is bind to a specific instance. Module methods will be invoked in UI thread, so do not put time consuming operation there. If you want to execute the whole module methods in other thread, please implement the method - (NSThread *)targetExecuteThread in protocol. In the way, tasks distributed to this module will be executed in targetExecuteThread. Weex params can be String or Map. Module supports to return results to Javascript in callback. This callback is type of WXModuleCallback, the params of which can be String or Map. @implementation WXEventModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(openURL:callback:))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end export synchronous methods v0.10+#If you want to export synchronous methods which could make Javascript receive return values from natvie, you can use WX_EXPORT_METHOD_SYNC macro. native code: @implementation WXEventModuleWX_EXPORT_METHOD_SYNC(@selector(getString))- (NSString *)getString&#123; return @&quot;testString&quot;;&#125;@end js code: const eventModule = weex.requireModule('event')const returnString = syncTest.getString() // return \"testString\" You can alse return number/array/dictionary except string. notice: the exported synchronous native method can only be called on JS thread. Do not do heavy work which will block js execution. notice: Vue 2.0 has not supported this feature yet. It will be supported in version 0.12 at the soonest. Register the module#You can register the customized module by calling the method registerModule:withClass in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; Handler extend#Weex SDK doesn’t have capabilitis, such as image download 、navigator operation，please implement these protocols by yourself. WXImgLoaderProtocol#Weex SDK has no image download capability, you need to implement WXImgLoaderProtocol. Refer to the following examples. WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * @param imageUrl The URL of the image to download * @param imageFrame The frame of the image you want to set * @param options : The options to be used for this download * @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished. */ -(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock; @end Implement above protocol as follows. @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end Register the handler#You can register the handler which implements the protocol by calling registerHandler:withProtocol in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)]; Custom Native Components for iOS#Component extend#There are a lot of native components ready to be used in the Weex SDK, but users always have their own use cases. You might have written an awesome native UI widget in your previous work and just want to wrap up it and export to Weex. So we provide a way to enable developers to create their own custom fully-native components. This guide will use the implementation of existing component image to show you how to build a native component. It will also assume that you are familiar with iOS programming. Registration#Defining a custom native component is simple. Just call [WXSDKEngine registerComponent:withClass:] with the component’s tag name as first argument. [WXSDKEngine registerComponent:@&quot;image&quot; withClass:[WXImageComponent class]]; Then you can create a WXImageComponent class to represent the implementation of image component. Now you can use &lt;image&gt; wherever you want in the template. &lt;image&gt;&lt;/image&gt; Adding Properties#The next thing we can do is to extend some native properties to make the component more powerful. As an image, let’s say we should have a src attribute as image’s remote source and a resize attribute as image’s resize mode(contain/cover/stretch). @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end All of the styles, attributes and events will be passed to the component’s initialization method, so here you can store the properties which you are interested in. @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; &#125; return self;&#125;@end The properties getted in the attributes are of id type, so we have to convert them to the type we want using a conversion function. Basic conversion functions can be found in the WXConvert file, or you can just add your own conversion function. Hooking Render Life Cycle#A Native Component has a life cycle managed by Weex. Weex creates it, layout it, renders it and destroys it. Weex offers component life cycle hooks that give you visibility into these key moments and the ability to act when they occur. method description initWithRef:type:… Initializes a new component using the specified properties. layoutDidFinish Called when the component has just laid out. loadView Creates the view that the component manages. viewWillLoad Called before the load of component’s view . viewDidLoad Called after the component’s view is loaded and set. viewWillUnload Called just before releasing the component’s view. viewDidUnload Called when the component’s view is released. updateStyles: Called when component’s style are updated. updateAttributes: Called when component’s attributes are updated. addEvent: Called when adding an event to the component. removeEvent: Called when removing an event frome the component. As in the image component example, if we need to use our own image view, we can override the loadView method. - (UIView *)loadView&#123; return [[WXImageView alloc] init];&#125; Now Weex will use WXImageView to render the image component. As an image component, we will need to fetch the remote image and set it to the image view. This can be done in viewDidLoad method when the view is created and loaded. viewDidLoad is also the best time to perform additional initialization for your view， such as content mode changing. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; If image’s remote source can be changed, you can also hook the updateAttributes: method to perform your attributes changing logic. Component’s view always has been loaded while updateAttributes: or updateStyles: is called. - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; Maybe there is even more life cycle hooks you might need to consider, such as layoutDidFinish while layout computing is finished. If you want to go deeper, check out the WXComponent.h file in the source code. Now you can use &lt;image&gt; and its attributes wherever you want in the template. &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt; Component Method#from WeexSDK 0.9.5, you can define your component method by macro WX_EXPORT_METHODfor example: @implementation WXMyComponent +WX_EXPORT_METHOD(@selector(focus)) +- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance &#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self; &#125; - (void)focus &#123; NSLog(@&quot;you got it&quot;); &#125;@end after your registration for your own custom component, now you can call it in your js file. &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"Extend Web Render","path":"guide/extend-web-render.html","permalink":"https://weex.apache.org/guide/extend-web-render.html","text":"Extend to HTML5#Weex itself offers a lot of built-in components and modules, but also has the ability to expand horizontally. It allows developers to expand and customize themselves. But it is important to note that Weex is a cross-platform solution. When extending its built-in components or modules, you need to implement it on the three ends (Android, iOS, Web). After Weex switches the kernel to Vue 2.x, it will be easier to extend the Vue component on the Web side. Extend Web components#Vue.js is an independent front-end framework. In the browser, you can not use the Weex container for page rendering. So, the two things are the same: (1) for the Weex platform to expand Vue.js Web components. (2) directly using Vue.js to develop a Web component. The development of components can refer to its documentation: component. It is also recommended to use the file to write components. How to use it: [Single file component](https://vuejs.org/v2/guide/single-file-components.html).### Example of component extensionTo extend ```&lt;sidebar&gt;``` as an example, you should first write the logic of the component itself:```html&lt;!-- sidebar.vue --&gt;&lt;template&gt; &lt;div class=&quot;sidebar&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .sidebar &#123; /* ... */ &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: [], data () &#123; return &#123;&#125; &#125; &#125;&lt;/script&gt; And then register the component globally before using it:```javascriptimport Vue from &apos;vue&apos;import Sidebar from &apos;./path/to/sidebar.vue&apos;// register the ```&lt;sidebar&gt;``` component globallyVue.component(&apos;sidebar&apos;, Sidebar) When you extend the Weex component, if you only use the built-in components provided by Weex and use the styles that Weex supports, it is no different from the normal custom component and does not need to be implemented at the Native side. If you find a component that does not support labels and styles that are not supported by Weex, you will need to really extend the Weex component. At the same time, you also need to extend in the Android side and the iOS side, or will lead to rendering exception. Extend the Web module#In addition to the common components, Weex also provides a common module, you can easily call the native API. In general, the registered Weex module requires three ends to be implemented, otherwise it will affect its normal use. Register the module#If we import the library, we can get the weex variable globally. You can register the module using the ```registerModule```method.#### API format+ `registerModule` 1.```name```: &#123;String&#125; Required, module name. 2.```define```: &#123;Object&#125; Required, module definition.#### The example of register moduleThe following code registers a module called guide:```javascriptweex.registerModule(&apos;guide&apos;, &#123; greeting () &#123; console.log(&apos;Hello, nice to meet you. I am your guide.&apos;) &#125;, farewell () &#123; console.log(&apos;Goodbye, I am always at your service.&apos;) &#125;&#125;) Use the module#Weex provides the require method for getting registered modules. You only need to pass the module name directly: //import moduleconst guide = weex.requireModule('guide')// use the methods of moduleguide.greeting()guide.farewell() The above wording is as useful as the native end, except that the methods in the module are provided by Native.","type":"guide"},{"title":"Front-End Frameworks","path":"guide/front-end-frameworks.html","permalink":"https://weex.apache.org/guide/front-end-frameworks.html","text":"Front-end Frameworks in Weex Vue.js Runtime-only Build weex-vue-render Compile *.vue files Restrictions Rax Writing UIs in declarative way. Front-end Frameworks in Weex# The structure of Weex is decoupled, it isn’t relay on any specific front-end frameworks, the DOM operations will convert into render directives and send to native render engine. With the evolution of technology, even if Vue.js and React are not popular any more few years later, Weex can integrate the new widely-used front-end frameworks as well. Vue.js#Using v2.x.x version of Vue.js. If there is no special instructions, when I mentioned Vue.js, it actually refers Vue.js 2.x.x. Runtime-only Build#When using vue-loader or vueify, templates inside *.vue files are pre-compiled into JavaScript at build time. You don’t really need the compiler in the final bundle, and can therefore use the runtime-only build. Vue.js provides two available builds: the Runtime + Compiler build and the Runtime-only build. See its official document for more information. Weex only required the runtime-only build of Vue.js for better performance and less code size. The specific differences are: The template attribute is not supported when defining a component. Does not support using x-templates. Does not support using Vue.compile. weex-vue-render#Compile *.vue files#Because of the platform difference and 利用 web 本身特性的性能, you have to compile your source file in two different ways: For the web, you can compile source files in any official way, such as Webpack + vue-loader or Browserify + vueify. and require the weex-vue-render, which is a group of Weex build-in components. For Android and iOS, we’ve provided weex-loader to compile the *.vue files. That is, use Webpack + weex-loader to generate the js bundle that is available for the native. Using weex-loader#weex-loader is a loader for Webpack, see the official document to learn how to use it. One more thing should be reminded is that if the entry file of your webpack config is a .vue file, you also need to pass an additional entry parameter, usually set to true. module.exports = &#123; // Add the entry parameter for the .vue file entry: './path/to/App.vue?entry=true', // other configurations ... module: &#123; loaders: [&#123; // matches the .vue file path that contains the entry parameter test: /\\.vue(\\?^^]+)?$/, loaders: ['weex-loader'] &#125;] &#125;,&#125; You don’t need to write those additional parameters if you are using .js file as entry file. We recommend using javascript file as the entry file of webpack config. Restrictions# Scoped styles by default, by force. Vue.js was designed for the Web platform at the beginning. Although it can be based on Weex to develop native applications, there are still many differences between web and native. See Platform Differences Between Weex and Web for more details. Due to those differences, Weex doesn’t support those features in Vue.js (mostly are DOM-related): Event bubbling and capturing are not supported. Event modifiers, such as .prevent,.capture, .stop,.self are meaningless in the native environment. The keyboard event modifiers, like .{KeyCode | keyAlias} is also meaningless. (see docs in Vue.js) The v-html and v-text directives are not supported. Not support v-show, v-cloak and &lt;keep-alive&gt;, because Weex doesn’t support display:none; yet. vm.$el is Weex Virtual-DOM Element, not the HTMLElement. No need to call vm.$mount manually, the entry component will mount to the root view of the native container by default. No need Vue.mount(). Rax#Rax is a front-end framework with largely React-compatible APIs.","type":"guide"},{"title":"Integrate Devtool to iOS","path":"guide/integrate-devtool-to-ios.html","permalink":"https://weex.apache.org/guide/integrate-devtool-to-ios.html","text":"Integrate Devtool to iOS#Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page. To make it work, at first you must integrate devtool to your App. This page will help you integrate devtool to your iOS App. Integrate to iOS#Installing Dependencies#There are two choices to install dependencies: No.1 From cocoapods#source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;]， I strongly recommend you use the latest version since both Weex SDK and devtools are developed iteratively and rapidly. No.2 From source code# Get source code by GitHub. Copy source folder to your project. Choose options as the picture shows. Integrate#Step 1. Add header file in AppDelegate.m# From cocoapods: #import &lt;TBWXDevtool/WXDevtool.h&gt; ``- From source code #import “WXDevtool.h” #### Step 2. Initialize inspector when the APP launchedYou can see the WXDevtool header file as follows:```object-c#import &lt;Foundation/Foundation.h&gt;@interface WXDevTool : NSObject/*** set debug status* @param isDebug : YES:open debug model and inspect model;* default is NO,if isDebug is NO, open inspect only;* */+ (void)setDebug:(BOOL)isDebug;/*** get debug status* */+ (BOOL)isDebug;/*** launch weex debug* @param url : ws://ip:port/debugProxy/native, ip and port is your devtool server address* eg:@&quot;ws://30.30.29.242:8088/debugProxy/native&quot;* */+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end Note: The inspector API must be called before weex is initialized setDebug setDebug is used to control the state of debug mode, when its value is YES, open the debug mode, otherwise closed. (void)launchDevToolDebugWithUrl:(NSString *)url; wssip was the wss address showing in the chrome address bar. open debug model and inspector model eg： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; &#125; open inspect model, remove the @selector (setDebug:) or add [WXDevTool setDebug:NO] eg： - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; &#125; Step 3. Auto refresh#Q: Why do we need auto refresh feature? A: As shown in future, when you click the debugger button, Javascript runtime environment will change from the phone (JavaScriptCore) to PC (Chrome V8), then Weex need to re-initialize the Weex environment, re-render the page. Page rendering is required for the developer to add on its own page. Q: What kind of scene need to add refresh feature? Click debugger button Switch remoteDebug Refresh inspect page Q: How to add auto refresh feature? Register events when Weex initialization. [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; Notes: You must cancel this event in the dealloc method. For example: - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; For example, First you can destroy the current instance, and then re-create instance: - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; You can see the details in this case WXDemoViewController.m","type":"guide"},{"title":"Integrate Devtool to Android","path":"guide/integrate-devtool-to-android.html","permalink":"https://weex.apache.org/guide/integrate-devtool-to-android.html","text":"Integrate Devtool to Android#Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page. To make it work, at first you must integrate devtool to your App. This page will help you integrate devtool to your Android App. Integrate to Android#Installing Dependencies#Weex Devtools depend on weex_inspector. I strongly recommend you use the latest version since both Weex SDK and devtools are developed iteratively and rapidly. See the release version list here. All the release version will publish to the jcenter repo. There are two choices to install it: From Gradle dependencies &#123; compile 'com.taobao.android:weex_inspector:0.8.0.0'&#125; From source code you need to copy the dir of inspector to the same dir of your app and add include &quot;:inspector&quot;in your project’s settings.gradle file just like playground have done, then add dependency in your app’s build.gralde. dependencies &#123; compile project(':inspector')&#125; Version compatibility# weex sdk weex inspector Debugger Server 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - Adding Debug mode switch#The key to control the opening and closing of the debug mode can be summarized as three rules: No.1: Set the switch and Debugger Server addresses via sRemoteDebugMode and sRemoteDebugProxyUrl. WXEnvironment class has a pair of static variables mark Weex current debug mode: public static boolean sRemoteDebugMode; // default closepublic static String sRemoteDebugProxyUrl; // Debugger Server addresses You have to set WXEnvironment.sRemoteDebugMode and WXEnvironment.sRemoteDebugProxyUrl at the right time, for example: private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; No.2: You must call WXSDKEngine.reload() method when sRemoteDebugMode was changed. You can control a state of debug mode via the WXEnvironment.sRemoteDebugMode, but you need reset Weex runtime if you changed a state of debug mode. private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; In this way, You can control the debug mode flexibly. No.3: Auto refresh page via ACTION_DEBUG_INSTANCE_REFRESH broadcast ACTION_DEBUG_INSTANCE_REFRESH can be broadcast messages when the debug mode is switched or Chrome page refresh. You can use this mechanism to inform the current page to refresh in time. public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; Example#The easiest way is reuse the code of playground. On the other hand QR code is not necessary, if you review the source code you can draw a conclusion that QR CODE is just a way to set devtools server address. There are two examples of how to open debug modes in the Playground App: Set the debug mode via XXXApplication public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; Set the debug mode by scan QR code You review the source code of playground. Debug mode switch control: WXApplication.java Refresh control WXPageActivity.java Known Issues#You can report issues and bugs here. We will reply as soon as possible.","type":"guide"},{"title":"Integrate to Your App","path":"guide/integrate-to-your-app.html","permalink":"https://weex.apache.org/guide/integrate-to-your-app.html","text":"Integrate to Your App#Integrate to Android#Tip：The following documents assume that you already have a certain Android development experience. Android has two ways to integrate weex#1.using source code: Can quickly use the latest features of WEEX, according to your own characteristics of the project. So, you can do some related improvements. 2.using SDK: WEEX will regularly release a stable version at jcenter.jcenter Prerequisites#Make sure the following configuration is complete: JDK version &gt;= 1.7 , and configure the environment variable Android SDK installed and configure the environment variable Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) Quick to use#If you are the first time to try or have a higher demand for stability, you can use the way to dependence on the SDK.The steps are as follows: Create an Android project. There is nothing to be specified, according to your habits to. Update build.gradle by adding the following dependencies: compile 'com.android.support:recyclerview-v7:23.1.1'compile 'com.android.support:support-v4:23.1.1'compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.alibaba:fastjson:1.1.46.android'compile 'com.taobao.android:weex_sdk:0.5.1@aar' Note: the version can be high can not be low. Start writing code#Note: There is a complete code address in the appendix Implement the picture download interface, set the initialization. package com.weex.sample;import android.widget.ImageView;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/*** Created by lixinke on 16/6/1.*/public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //To implement picture download interface, otherwise the picture can not be displayed. &#125;&#125; initialization package com.weex.sample;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/*** Note: add android:name=\".WXApplication\" into Manifest file* To implement ImageAdapter, otherwise the picture can not be downloaded* Gradle must add some dependencies, otherwise the initialization will fail.* compile 'com.android.support:recyclerview-v7:23.1.1'* compile 'com.android.support:support-v4:23.1.1'* compile 'com.android.support:appcompat-v7:23.1.1'* compile 'com.alibaba:fastjson:1.1.45'*/public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; Start rendering package com.weex.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample can be replaced by any string * Template is js file that .we converted * Option can be empty, or through the option passed js required parameters. Such as the address of the bundle js. * JsonInitData can be empty. * width is -1 , default full screen, you can customize it. * height is -1 , default full screen, you can customize it. */ mWXSDKInstance.render(\"WXSample\", WXFileUtils.loadFileContent(\"hello.js\", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; Dependence on source code (IDE Android Studio)#1.Download source code. git clone https://github.com/alibaba/weex.2.Create an android project.3.Import the SDK Module through the following path:File-&gt;New-Import Module-&gt; chose WEEX SDK Module(weex/android/sdk) -&gt; Finish4.Add the following dependencies: compile project (‘: weex_sdk’) to build.gradle file.5.Other settings please refer to the above “Quick to use”. Appendix: WXSample address https://github.com/xkli/WXSample.git Integrated to iOS#Through the cocoaPods integrated Weex iOS SDK to the project.First assume that you have finished installing the iOS development environment and CocoaPods. Step 1: Add Dependencies#Import Weex iOS SDK to your existing project, if not, you can create a new project.Before proceeding, make sure that the Podfile file is under the project file. If not, create one and open with text editor. Integration framework WeexSDK The latest version on cocoaPods can be obtained here .Add the following to the Podfile file: source &apos;git@github.com:CocoaPods/Specs.git&apos;target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, &apos;0.9.5&apos; ## Suggest using latest Weex SDKend Integrate with source code First copy the ios / sdk directory to your existing project directory (here to copy the root directory of your existing project as an example), and then add the Podfile file. source &apos;git@github.com:CocoaPods/Specs.git&apos;target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos;end Step 2: Install Dependencies#Open the command line, switch to the directory of the Podfile file, and run the pod install command. If there are no errors, it means that the environment has been configured. Step 3: Initialize the Weex environment#In the AppDelegate.m file to do the initialization operation, usually in the didFinishLaunchingWithOptions method as follows to add. //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk environment[WXSDKEngine initSDKEnvironment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level[WXLog setLogLevel: WXLogLevelAll]; Step 4: Render weex Instance#Weex supports both full page rendering and partial rendering. What you need to do is render Weex’s view with the specified URL and add it to its parent container. The parent container is generally a viewController. #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad&#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;]; [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance is a very important class that provides a basic method and some callbacks, such as renderWithURL, onCreate, onFailed, etc., can be found in WXSDKInstance.h. Step 5: Destroy Weex Instance#In the dealloc phase of the viewController destroyed Weex instance, can play a role in avoiding memory leaks. - (void)dealloc&#123; [_instance destroyInstance];&#125; Import the Weex SDK framework to the project.#The Weex SDK can be compiled from the source code. You can try the latest feature in the new feature or bugfix branch.Refer to here for direct import of weexSDK.","type":"guide"},{"title":"Setup Develop Environment","path":"guide/set-up-env.html","permalink":"https://weex.apache.org/guide/set-up-env.html","text":"Setup Develop Environment#Using dotWe is a good choice, but if you want to develop locally on your own machine, you will need to set up your develop environment. You will need Node.js and the Weex CLI. Install Node.js using nvm (Simple bash script to manage multiple active Node.js versions). Run the following commands in a terminal after installing nvm: $ nvm install 6.10.0$ nvm use 6.10.0 And npm comes with Node.js, with witch you can install the Weex command line tools. NOTE: After upgrading the weex-toolkit to v1.0.8, the npm-shrinkwrap.json npm 5 specification has been added to lock the package dependencies, it is needed to upgrade your npm version to 5 above by command: npm install npm @latest -g if your version is lower than this, please check your npm version before using it. Run the following commands in a terminal: $ npm install -g weex-toolkit$ weex -v You can use ‘weex update @x.x.x’ to update weex-devtool, weex-previewer, weex-builder and weexpack to a specific version.weex update weex-devtool@latest // Here latest means to install the latest version NOTE: If you receive an error like “permission error”, try another time with sudo. Then you can use the Weex command to verify if the installation is successful: Generate a new Weex project#Use the command line tool to generate a Weex project called “awesome-project”. Run the following command in a terminal: $ weex create awesome-project Then enter the awesome-project folder, you will see a standard project skeleton has been generated. Usage#In the awesome-project folder, install dependencies with the following command: npm install Then run npm run serve in root directory to start watching mode and static server. Finally, you can access the Weex page in http://localhost:8080/index.html. This page can be modified in src/index.vue. The codes are shown below: &lt;template&gt; &lt;div class=\"wrapper\" @click=\"update\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;text class=\"desc\"&gt;Now, let's use vue to build your weex app.&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; padding-top:40px; padding-bottom: 40px; font-size: 48px; &#125; .logo &#123; width: 360px; height: 156px; &#125; .desc &#123; padding-top: 20px; color:#888; font-size: 24px;&#125;&lt;/style&gt;&lt;script&gt; export default &#123; data: &#123; logoUrl: 'http://img1.vued.vanthink.cn/vued08aa73a9ab65dcbd360ec54659ada97c.png', target: 'World' &#125;, methods: &#123; update: function (e) &#123; this.target = 'Weex' console.log('target:', this.target) &#125; &#125; &#125;&lt;/script&gt; For more technical details, please continue to read the next section. And don’t forget to write and preview your codes at dotWe.","type":"guide"},{"title":"Android APIs","path":"references/android-apis.html","permalink":"https://weex.apache.org/references/android-apis.html","text":"Android APIs#WXSDKEngine# Set up various adapters WXSDKEngine.initialize(this, new InitConfig.Builder().setImgAdapter(new ImageAdapter()).setDebugAdapter(new PlayDebugAdapter()).build()); Register the module and component WXSDKEngine.registerComponent(\"richtext\", RichText.class);WXSDKEngine.registerModule(\"event\", WXEventModule.class); Overloading framework WXSDKEngine.reload(this,framework,false); Adapter# IWXImgLoaderAdapter Weex need to implement this interface to download the pictureThe interface is defined as follows: public interface IWXImgLoaderAdapter &#123; void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy);&#125; WXImageQuality that the quality of the picture variables, take the following values LOW, NORMAL, HIGH, ORIGINAL picture quality in turn higher. The default is LOW. WXImageStrategy is an extension class that indicates whether the image can be cut (isClipping) sharpening (isSharpen) placeholder (placeHolder) and so on. IWXHttpAdapter Weex custom WXRequest and OnHttpListener, Native reload interface can be obtained from the Request URL, Header and other parameters, the network request can be completed through OnHttpListener callback notification. Weex provides the default network request: DefaultWXHttpAdapter, using HttpURLConnection for network requests. The interface is defined as follows: public interface IWXHttpAdapter &#123; void sendRequest(WXRequest request, OnHttpListener listener);&#125; WXRequest defines the parameters related to the network request, the request method, the request body, and the timeout time. Weex default timeout is 3000. OnHttpListener defines the corresponding method after the network request ends. Defined as follows: interface OnHttpListener &#123; /** * start request */ void onHttpStart(); /** * headers received */ void onHeadersReceived(int statusCode,Map&lt;String,List&lt;String&gt;&gt; headers); /** * post progress * @param uploadProgress */ void onHttpUploadProgress(int uploadProgress); /** * response loaded length (bytes), full length should read from headers (content-length) * @param loadedLength */ void onHttpResponseProgress(int loadedLength); /** * http response finish * @param response */ void onHttpFinish(WXResponse response); &#125; IWXUserTrackAdapter Weex related performance data (first screen loading time, JS-Native communication time, dom update time, etc.) and other general information (JSLib file size, Weex SDK version number, etc.).Interface definition: public interface IWXUserTrackAdapter &#123; void commit(Context context, String eventId, String type, WXPerformance perf, Map&lt;String, Serializable&gt; params);&#125; Native implementation interface can be obtained through WXPerformance and params corresponding information. Native interacts with JavaScript#Custom events#Used for a custom control for event notifications, such as custom click events, response drop events, and so on. WXSDKInstance.java public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data,final Map&lt;String, Object&gt; domChanges)&#123; &#125;public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data)&#123; fireEvent(elementRef,type,data,null);&#125;public void fireEvent(String elementRef, String type)&#123; fireEvent(ref,type,new HashMap&lt;String, Object&gt;());&#125; elementRef：The event occurred for the control ID。 type: Custom events, Weex defaults to a custom event starting with onXxxxx. OnPullDown (drop-down event) data: Need to reveal the parameters, such as the current control of the size, coordinates and other information。 domChanges：Update ref for the control’s Attribute and Style Event callback#Used for Module callback, for example, after the completion of positioning Module need to notify JS. Use as follows: public class WXLocation extends WXModule &#123; @JSMethod public void getLocation(JSCallback callback)&#123; //Get the code for the location information ..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put(\"x\",\"x\"); data.put(\"y\",\"y\"); //notify once callback.invoke(data); //Continuous connection callback.invokeAndKeepAlive(data); //Invoke method and invokeAndKeepAlive two methods of choice &#125;&#125; OnWXScrollListener#Weex gets the scroll event You can register registerOnWXScrollListener via WXSDKInstanceThe interface is defined as follows: public interface OnWXScrollListener &#123; /** * The view is not currently scrolling. */ int IDLE = RecyclerView.SCROLL_STATE_IDLE; /** * The view is currently being dragged by outside input such as user touch input. */ int DRAGGING = RecyclerView.SCROLL_STATE_DRAGGING; /** * The view is currently animating to a final position while not under * outside control. */ int SETTLING = RecyclerView.SCROLL_STATE_SETTLING; /** * Callback method to be invoked when the view has been scrolled. This will be * called after the scroll has completed. * &lt;p&gt; * This callback will also be called if visible item range changes after a layout * calculation. In that case, dx and dy will be 0. * */ void onScrolled(View view, int x, int y); /** * Callback method to be invoked when view's scroll state changes. * */ void onScrollStateChanged(View view, int x, int y, int newState);&#125; IActivityNavBarSetter#Weex provides WXNavigatorModule for navigation control, and the corresponding method can be customized by setting the IActivityNavBarSetter interface. Instructions: WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter()&#123;&#125;); Other Introduction#setSize#You can use the mWXSDKInstance.setSize() method to change the size of the Weex container. Downgrade#Weex in the development stage will add some new features and new methods, but these new features and functions must be upgraded to achieve the SDK, for the application should not be upgraded how to deal with it? You can use the downgrade feature. Native can be handled by the onException method in interface IWXRenderListener, and if it is an active demoulding errCode is a character that is divided by “|”. “|” The preceding character is 1 for active demotion, and the Native side can jump to the corresponding H5 page. Or otherwise prompted the user’s current environment does not support Weex.","type":"references"},{"title":"iOS APIs","path":"references/ios-apis.html","permalink":"https://weex.apache.org/references/ios-apis.html","text":"iOS APIs#Handler(like Android Adapter)# WXImgLoaderDefaultImpl Image load handler. Weex need to implement this interface to download the picture. The interface is defined as follows: @protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * * @param imageUrl The URL of the image to download * * @param imageFrame The frame of the image you want to set * * @param options : The options to be used for this download * * @param completedBlock : A block called once the download is completed. * image : the image which has been download to local. * error : the error which has happened in download. * finished : a Boolean value indicating whether download action has finished. */- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end Native interacts with JavaScript# Custom events Used for a custom control for event notifications, such as custom click events, response drop events, and so on. This is a method in the component base class that can be used directly. /** * @abstract Fire an event to the component and tell Javascript which value has been changed. * @param eventName * @param params * @param domChanges **/- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges Event callback Used for Module callback. There are two types of callback: WXModuleCallback: For performance reasons, the callback can only callback js once, and then will be released. WXModuleKeepAliveCallback: This callback can be set to multiple callbacks, multiple callbacks of the scene such as continually listen scrolls event and return to js. @implementation WXEchoModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);&#125; Set size of the Weex container#You can use the setFrame(CGRect) method to change the size of the Weex container. Downgrade#Weex in the development stage will add some new features and new methods, but these new features and functions must be upgraded to achieve the SDK, for the application should not be upgraded how to deal with it? You can use the downgrade feature. Native can be handled by the onFailed method in interface WXSDKInstance, and if it is an active demoulding error domain is TemplateErrorType, and the Native side can jump to the corresponding H5 page. Or otherwise prompted the user’s current environment does not support Weex.","type":"references"},{"title":"JS Service","path":"references/js-service.html","permalink":"https://weex.apache.org/references/js-service.html","text":"JS Service#v0.9.5+ JS service and Weex instance are parallel in js runtime. Weex instance lifecycle will invoke JS service lifecycle. Currently provide create, refresh, destroy of lifecycle. !!!Important: JS Service is very powerful. Please be careful to use. Register JS Service#iOS#[WeexSDKEngine registerService:@&quot;SERVICE_NAME&quot; withScript: @&quot;SERVICE_JS_CODE&quot; withOptions: @&#123;&#125;]; Android#HashMap&lt;String, String&gt; options = new HashMap&lt;&gt;()options.put(\"k1\", \"v1\")String SERVICE_NAME = \"SERVICE_NAME\"String SERVICE_JS_CODE = \"SERVICE_JS_CODE\"boolean result = WXSDKEngine.registerService(SERVICE_NAME, SERVICE_JS_CODE, options) Web#&lt;!-- Should be loaded after then jsfm --&gt;&lt;script src=\"SERVICE_JS_CODE_URL\"&gt;&lt;/script&gt; Write a JS Service#// options: native inject options// options.serviceName is native options nameservice.register(options.serviceName, &#123; /** * JS Service lifecycle. JS Service `create` will before then each instance lifecycle `create`. The return param `instance` is Weex protected param. This object will return to instance global. Other params will in the `services` at instance. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ create: function(id, env, config) &#123; return &#123; instance: &#123; InstanceService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125;, NormalService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125; &#125;, /** * JS Service lifecycle. JS Service `refresh` will before then each instance lifecycle `refresh`. If you want to reset variable or something on instance refresh. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment */ refresh: function(id, env, config)&#123; &#125;, /** * JS Service lifecycle. JS Service `destroy` will before then each instance lifecycle `destroy`. You can deleted variable here. If you doesn't detete variable define in JS Service. The variable will always in the js runtime. It's would be memory leak risk. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ destroy: function(id, env) &#123; &#125;&#125;) Using JS Service (vuejs)#&lt;script&gt;var _InstanceService = new InstanceService(weex)var _NormalService = new service.normalService(weex)module.exports = &#123; created: fucntion() &#123; // called modal module to toast something _InstanceService.toast('Instance JS Service') _NormalService.toast('Normal JS Service') &#125;&#125;&lt;/script&gt;","type":"references"},{"title":"JS Framework APIs","path":"references/js_framework-apis.html","permalink":"https://weex.apache.org/references/js_framework-apis.html","text":"JS Framework APIs#BroadcastChannel v0.9+#BroadcastChannel API is the solution for inter-instance communication. Reference# BroadcastChannel specification. MessageEvent specification API# postMessage(message): Sends the given message to other BroadcastChannel objects set up for this channel. close: Closes the BroadcastChannel object, opening it up to garbage collection. onmessage: Event handler, the event will be triggered when the instance receive a message. Usage#const Stack = new BroadcastChannel('Avengers')Stack.onmessage = function (event) &#123; console.log(event.data) // in this case, it's \"Hulk Smash !!!\"&#125;// in another instanceconst Hulk = new BroadcastChannel('Avengers')Hulk.postMessage(\"Hulk Smash !!!\") Run the code above, Stack can receive the message from Hulk. Notice#One thing should be noticed: The message object is not deep cloned. See the demo below: const a = new BroadcastChannel('app')const b = new BroadcastChannel('app')const message = &#123; lists: ['A', 'B']&#125;a.onmessage = function (event) &#123; // in this case, event.data is a reference of message console.assert(event.data === message)&#125;b.postMessage(message) In this case, event.data is strict equal to message. Compared to the deep clone, this behavior improves efficiency and reduces memory cost. However, developers are not recommended to cache or modify the event object when they are using it (All type of event handlers should have this restriction).","type":"references"},{"title":"Weex Variable","path":"references/weex-variable.html","permalink":"https://weex.apache.org/references/weex-variable.html","text":"Weex instance variable#Each Weex page has a separate weex variable, which exists in the JS context. They hold a single instance or method of the current Weex page. weex.config#This variable contains all the environment information for the current Weex page, including not only: BundleUrl: string: The URL of the JS bundle. Env: Object: environment object. WeexVersion: string: Weex sdk version. AppName: string: application name. AppVersion: string: app version. Platform: string: platform information, that is iOS, Android or Web. osName: string: OS name information, that is iOS, Android. OsVersion: string: system version. DeviceModel: string: device model (native application only). DeviceWidth: number: device width DeviceHeight: number: device height. In Weex, the default width of viewport is 750px, thus you can obtain the height of screen by height = 750/deviceWidth*deviceHeight if the width of viewport remains its default value. weex.requireModule(module: string): Object Get all the methods of a native module, such as: &lt;template&gt; &lt;div&gt;&lt;text&gt;Hello World&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; var modal = weex.requireModule('modal') modal.toast(&#123; message: 'I am a toast.', duration: 3 &#125;)&lt;/script&gt; weex.document: Document#Returns the document object of the current Weex page. weex.supports#v0.15+ weex.supports is a method used to detect whether a feature is supported in the current environment. Only supported in Weex DSL 2.0 (.vue). API#weex.supports(condition : String) : Boolean | Null Parameter# a formatted string: @{type}/{name}. The type must be “component” or “module”, the name can be tag name, module name or the method name in specific module. Return Value# if supported, returns true. if unsupported, returns false. if unclear, returns null. Example#// Detects whether the specific component is supportedweex.supports('@component/slider') // trueweex.supports('@component/my-tab') // false// Detects whether the specific module is supportedweex.supports('@module/stream') // trueweex.supports('@module/abcdef') // false// Detects whether the method in specific module is supportedweex.supports('@module/dom.getComponentRect') // trueweex.supports('@module/navigator.jumpToPage') // false// invalid inputweex.supports('div') // nullweex.supports('module/*') // nullweex.supports('@stream/fetch') // nullweex.supports('getComponentRect') // null","type":"references"},{"title":"Weex Language Support Plugin","path":"tools/helpers.html","permalink":"https://weex.apache.org/tools/helpers.html","text":"Weex Language Support Plugin#Weex Language Support is a official tools to code highlight, automatic completion，lint and other functions in IDEA, WebStorm or the others IDEs. Supported IDEs#You can install and use this plugin on the following IDEs on any operating system:IntelliJ IDEA Ultimate, PhpStorm, WebStorm, PyCharm, RubyMine, AppCode, CLion, Gogland, Rider Install#Just searching the Weex Language Support in plugin repo to install, next you need restart IDE to enable it. Configurations#Open Preferences -&gt; Other Settings -&gt; Weex language support to configuration plugin Target Weex Version: Config the version of Weex that your current project in use, default is LATEST, it means always using the latest version Vue Support: Config whether to support Vue, you need to restart IDE after turning on or off the set to take effect Custom Rules: Import the custom Weex DSL rules, The format of the custom rules will be listed later Global Weex Components: Sets the location of the module that is applied in the project, in particular, the node_modules directory in current project and npm root will be automatically included, you do not need to add them here Format of Custom DSL Rules#Custom rules are included in a json file, the root node of the json file is an array, each element in the array corresponds to a label in the DSL.Let’s take the example of the loading&gt; tag:&#123; \"tag\": \"loading\", //tag name, not null \"attrs\": [ //attributes of tag, can be null &#123; \"name\": \"display\", //attribute name, not null \"valuePattern\": null, //pattern expression to check the attribute value, can be null \"valueEnum\": [ //attribute value enumeration, can be null \"show\", \"hide\" ], \"valueType\": \"var\", //type of attribute value, must be var or function \"since\": 0, //which version the attribute is added to sdk, such as 0.11 \"weexOnly\": false //whether the attribute is available only in 1.0 syntax, default is false &#125; ], \"events\": [ //events list, can be null &#123; \"name\": \"loading\", //event name, not null \"since\": 0 //which version the event is added to sdk &#125; ], \"parents\": [ //The tag is allowed to be a child of which tags, null means no restrictions \"list\", \"scroller\" ], \"childes\": [ //which tags are allowed as their own child tags, null means no restrictions \"text\", \"image\", \"loading-indicator\" ], \"document\": \"/references/components/loading.html\" //document link &#125; Contribution#Please commiting Issues and Pull Requests into the weex-language-support project","type":"tools"},{"title":"Weex Market","path":"tools/market.html","permalink":"https://weex.apache.org/tools/market.html","text":"","type":"tools"},{"title":"Use weex-toolkit","path":"tools/toolkit.html","permalink":"https://weex.apache.org/tools/toolkit.html","text":"weex-toolkit#weex-toolkit is an official command line tool to help developers to create, debug and build their Weex project. Install#use npm to install weex-toolkit: $ npm install -g weex-toolkit if you make it, you can input “weex” in your command line terminal to test it. The right output: if you have never installed node.js, you should go node.js.org to download and install it. node engine version &gt;= 6. You can try n to manage your node versions*If you meet some errors when installing like permission error, please go weex-toolkit issues to find some solution or have a discuss with us. initialize Weex project#$ weex init awesome-project After command running, you can find awesome-project directory and there are some Weex templates in it.There are some useful npm scripts you will use in the future: build: build the source code and generate the JS bundle dev: run webpack watch configuration serve: start a web server debug: open the debug mode Then we run npm run dev &amp; npm run serve in root directory to start watch mode and static server. Finally, we can see the Weex page in http://localhost:8080/index.html. preview Weex page in time#weex-toolkit supports previewing your Weex file(.we or .vue) in a watch mode. You only need specify your file path. $ weex src/foo.vue The browser will auto open the location and you could see the layout and effects of your Weex page. If you have a Playground app in your mobile devices, you can scan the QR code at the opened page.Try the command below, you’ll preview the whole directory files. $ weex src --entry src/foo.vue You need to specify the directory path and the entry file(--entry). build Weex project#Use weex compile to build your single weex file or the whole project.weex compile src/foo.vue dist There are two arguments. One is your code source path (a single file or a directory) and another is your destination path you want to build debug#weex-toolkit has the ability to extend third party script. And Weex devtools is a custom devtools for Weex that implements Chrome Debugging Protocol, it is designed to help you quickly inspect your app and debug your JS bundle source in a Chrome web page, both android and iOS platform are supported. So you can use weex-devtools feature by weex-toolkit. usage#weex debug [options] [we_file|bundles_dir] Options: -h, --help output usage information -V, --verbose display logs of debugger server -v, --version display version -p, --port [port] set debugger server port -e, --entry [entry] set the entry bundlejs path when you specific the bundle server root path -m, --mode [mode] set build mode [transformer|loader] -w, --watch watch we file changes auto build them and refresh debugger page![default enabled] start debugger#$ weex debug this command will start debug server and launch a chrome opening DeviceList page.this page will display a qrcode ,you can use Playground App scan it for starting debug. debug .we | .vue file#$ weex debug your_weex.vue this command will compile your_weex.we to your_weex.js and start the debug server as upon command.your_weex.js will deploy on the server and displayed in DeviceList page as another qrcode contain the url of your_weex.js. . start debugger with a directory of we files#$weex debug your/we/path -e index.we this command will build every file in your/we/pathand deploy them on the bundle server. your directory will mapping to http://localhost:port/weex/use -e to set the entry of these bundles. and the url of index.we will display on device list page as another qrcode. Features#Connect devices# Inspector# Inspector can be used to show your Element \\ Network \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. Element# NetWork#show the total time and latency# show the header and response# Console# Resource# Debugger# Breakpoint and CallStack# Integrate devtools# Android See the doc Weex devtools (Android), it will lead you to config and use it step by step. IOS See the doc Weex devtools (IOS), it will lead you to config and use it step by step. weex-toolkit extends weexpack command#weexpack helps to setup Weex application from scratch quickly. With simple commands, developers could create a Weex project, add different platform template, could install plugins from local, GitHub or Weex market, could pack up his application project and run on mobile. For those who would like to share his own plugins, he could publish them to the Weex market. Now weex-toolkit can run the same commands of weexpack because of the new architecture. If your directory is generated by weexpack, you can build your iOS or android app. weex platform and run commands#Use platform add|remove to add or remove Weex app template and run it in your target devices. $ weex platform add ios If you use these commands firstly, you might see the prompt. Just enter Y. Then run platform, you will see an iPhone simulator. $ weex run ios weex plugin commands#If you want to use some plugins on the weex market, weex-toolkit is the right choice. $ weex plugin add plugin_name You need to specify the plugin name from market like “weex-chart”: $ weex plugin add weex-chart Remove some plugins(eg: weex-chart): $ weex plugin remove weex-chart Learn more about weexpack .","type":"tools"},{"title":"Common Events","path":"wiki/common-events.html","permalink":"https://weex.apache.org/wiki/common-events.html","text":"Common Events#Weex provide the ability to let events trigger action, like starting a JavaScript when a user click on a component. Bellow are the common event attributes that can be added to weex components to define event actions. Click event#The onclick attribute fires on a click gesture on the element.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object# type : click target : The target component where the event is triggered timestamp : Timestamp when event is triggered Longpress event#If a longpress event is bound to a component, the event will be triggered when user long press on it.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object# type : longpress target : The target component where the event is triggered timestamp : Timestamp when event is triggered Appear event#If a appear event is bound to a component inside a scrollable container, the event will be triggered when the component comes to be visible. event object# type : appear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. Disappear event#If a disappear event is bound to a component inside a scrollable container, the event will be triggered when the component scrolls out of viewport and disappears from your sight. event object# type : disappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. Page event#Weex provides you with simple management of page status, such as viewappear and viewdisappear.The viewappear event will be triggered when page is about to show or before any animations are configured for showing. For example, when calling push method in navigator module, this event will be trigged in new page.The viewdisappear event will be triggeded when page is about to dismiss.Different from appear and disappear of component, these two events focus on the status of whole page, so they must be bound to the root component.In addititon, these events also can be bound to body component which is not root actually such as wxc-navpage. event object# type : viewappear or viewdisappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\" @click=\"onclick\" @longpress=\"onlongpress\" @appear=\"onappear\" @disappear=\"ondisappear\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; onclick (event) &#123; console.log('onclick:', event) modal.toast(&#123; message: 'onclick', duration: 0.8 &#125;) &#125;, onlongpress (event) &#123; console.log('onlongpress:', event) modal.toast(&#123; message: 'onlongpress', duration: 0.8 &#125;) &#125;, onappear (event) &#123; console.log('onappear:', event) modal.toast(&#123; message: 'onappear', duration: 0.8 &#125;) &#125;, ondisappear (event) &#123; console.log('ondisappear:', event) modal.toast(&#123; message: 'ondisappear', duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt;","type":"wiki"},{"title":"Color name","path":"wiki/color-names.html","permalink":"https://weex.apache.org/wiki/color-names.html","text":"List of the names of colors#Basic color keywords:# Color Name Hex rgb black #000000 silver #C0C0C0 gray #808080 white #FFFFFF maroon #800000 red #FF0000 purple #800080 fuchsia #FF00FF green #008000 lime #00FF00 olive #808000 yellow #FFFF00 navy #000080 blue #0000FF teal #008080 aqua #00FFFF Extended color keywords:# Color Name Hex rgb aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"wiki"},{"title":"CSS Units","path":"wiki/css-units.html","permalink":"https://weex.apache.org/wiki/css-units.html","text":"CSS Units#Work in progresss.","type":"wiki"},{"title":"Common Style","path":"wiki/common-styles.html","permalink":"https://weex.apache.org/wiki/common-styles.html","text":"Common Style#All of weex tags share some common style rules Box Model# Weex box model based on the CSS box model, all of weex elements can be considered as boxes. The term “box model” is used when talking about design and layout. The box model is essentially a box that wraps around every HTML element. It consists of margins, borders, paddings, and the actual content. you can use the definition below in weex box model. width: length type, default value 0 height: length type, default value 0 padding: length type, default value 0, (space around content, between element content and the element border) padding-left: length type, default value 0 padding-right: length type, default value 0 padding-top: length type, default value 0 padding-bottom: length type, default value 0 margin: length type, default value 0, (space around elements, outside the border) margin-left: length type, default value 0 margin-right: length type, default value 0 margin-top: length type, default value 0 margin-bottom: length type, default value 0 border border-style: values solid | dashed | dotted, default value solid border-left-style: values solid | dashed | dotted, default value solid border-top-style: values solid | dashed | dotted, default value solid border-right-style: values solid | dashed | dotted, default value solid border-bottom-style: values solid | dashed | dotted, default value solid border-width: length type, non-negative, default value 0 border-left-width: length type, non-negative, default value 0 border-top-width: length type, non-negative, default value 0 border-right-width: length type, non-negative, default value 0 border-bottom-width: length type, non-negative, default value 0 border-color: color type, default value #000000 border-left-color: color type, default value #000000 border-top-color: color type, default value #000000 border-right-color: color type, default value #000000 border-bottom-color: color type, default value #000000 border-radius: length type, default value 0, (rounded borders to elements , default value is 0 meaning right angle ) border-bottom-left-radius: length type, non-negative, default value 0 border-bottom-right-radius: length type, non-negative, default value 0 border-top-left-radius: length type, non-negative, default value 0 border-top-right-radius: length type, non-negative, default value 0 Notes#Weex box model uses border-box as the default value of box-sizing, meaning the width and height properties includes content, padding and border, but not the margin. The rule of border-radius for a specific corner such as border-top-left-radius is not currently supported for component &lt;image&gt;in iOS. This only happens to iOS, it works fine on Android. Although overflow:hidden is default on android, a view will not clip its children according to border-radius unless all the following condtions met. This only happens on Android, it works fine on iOS. The view type is div, a, cell, refresh or loading. OS version is Android 4.3 or higher. OS version is not Andorid 7.0 A view does not have background-image property nor OS version is Android 5.0 or higher. Example#&lt;template&gt; &lt;div&gt; &lt;image src=\"...\" style=\"width: 400; height: 200; margin-left: 20;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; Flexbox#Weex box style model based on the CSS flexbox, ensures that elements behave predictably and the page layout can accommodates to different screen sizes and different display devices. Flexbox consists of flex containers and flex items. If a weex element can containing other elements, it is a flex container. Notice that the old version of flexbox specification has differences with the new ones, such as whether or not to support wrapping. This is described at w3c’s working drafts, and you should notice the differences among them. Also notice that the old version is only supported below the 4.4 version of android. Flex container#Flexbox is the default and only style model in Weex, so you don’t have to add display: flex; in a container. flex-direction: values row | column, default value column The flex-direction property specifies the direction of the flexible items inside the flex container. Default value is column (top-to-bottom). justify-content: values flex-start | flex-end | center | space-between, default value flex-start The justify-content property horizontally aligns the flexible container’s items when the items do not use all available space on the main-axis. Default value is flex-start meaning the flex items are positioned at the beginning of the container. flex-end means the items are positioned at the end of the container. center means the items are positioned at the center of the container. space-between means the items are positioned with space between the lines. align-items: values stretch | flex-start | center | flex-end, default value stretch The align-items property vertically aligns the flexible container’s items when the items do not use all available space on the cross-axis. Default value is stretch meaning the items are stretched to fit the container. flex-start means the items are positioned at the top of the container; flex-end means the items are positioned at the bottom of the container; center means items are positioned at the center of the container (vertically). Flex item# flex: number type, default value 0 the flex property specifies the length of the flex item, relative to the rest of the flex items inside the same container. If all of the flex items set flex: 1, they will have equal width or height on direction of flex container’s flex-direction. If there are two flex items, with one setting flex: 1, and the other setting flex: 2, the first one will take 1/3 container space, and the second one will take 2/3 container space. If all of flex items don’t set flex, they will be aligned depending on the container’s justify-content property. Examples#a list of images with equal scales align at the vertical axis: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; a image with fixed width aligns with a stretched text: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;text style=\"flex: 1;\"&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; mixed direction alignment: &lt;template&gt; &lt;div style=\"width: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text style=\"flex: 2; font-size: 32;\"&gt;title&lt;/text&gt; &lt;text style=\"flex: 1; font-size: 16;\"&gt;$100&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; one text align left , the other float right: &lt;template&gt;&lt;div style=\"flex-direction: row; justify-content: space-between;\"&gt; &lt;text&gt;WEEX&lt;/text&gt; &lt;text&gt;2016-05-08&lt;/text&gt;&lt;/div&gt;&lt;/template&gt; Position#we can use properties below to control placement of weex tag position: values relative | absolute | fixed | sticky, default value relative relative means the item is positioned relative to its normal position. absolute means the item is positioned relative to its container. fixed keeps the elements position fixed when the page is scrolling. sticky keeps elements positioned inside the viewport as “stuck” at the top or “relative” at its original place depending on whether does it about to scroll out of the view. top: number type, default value 0, upward offset value bottom: number type, default value 0, downward offset value left: number type, default value 0, leftward offset value right: number type, default value 0, rightward offset value Examples#&lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"top: 50px; left: 50px;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: sticky;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: absolute; top: 50px; left: 50px;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; transform#The CSS transform property lets you modify the coordinate space of the CSS visual formatting model. Using it, elements can be translated, rotated and scaled. Currently supported format: translate( [, ]?) translateX( ) translateY( ) scale( ) scaleX( ) scaleY( ) rotate( ) rotateX( ) v0.14+ rotateY( ) v0.14+ perspective( ), supported for Android 4.1 and above. v0.16+ transform-origin: number/percentage/keyword(top/left/right/bottom) Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"transform\"&gt; &lt;text class=\"title\"&gt;Transformed element&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .transform &#123; align-items: center; transform: translate(150px,200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px; &#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt; transition v0.16.0+#Now you can use the transition attribute in CSS to enhance the interactivity and visual experience of your application. The transition includes the layout animation, that is, LayoutAnimation, which now changes the layout and uses the fluent animation of the transition. Transition allows the CSS attribute values to transition smoothly over a certain time interval. Property# transition-property:Allows the name of the transitional animation to set the value of the different styles transition effect, the default value is empty, that does not perform any transition, the following table lists all the legitimate parameters of the property: Property Description width The transition is performed when the width of the component is involved in the animation height The transition is performed when the height of the component is involved in the animation top The transition is performed when the top of the component is involved in the animation bottom The transition is performed when the bottom of the component is involved in the animation left The transition is performed when the left of the component is involved in the animation right The transition is performed when the right of the component is involved in the animation backgroundColor The transition is performed when the backgroundColor of the component is involved in the animation opacity The transition is performed when the opacity of the component is involved in the animation transform The transition is performed when the transform of the component is involved in the animation transition-duration:Specifies the duration of the transition transition (in milliseconds). The default value is 0, indicating that there is no animation. transition-delay:Specifies the time interval (in milliseconds or seconds) between the request transition transition and the transition transition. The default value is 0, indicating that there is no delay, and the transition transition is performed immediately after the request. transition-timing-function:Describes the velocity curve of the transition transition, which is used to make the transition transition smoother. The default is ease. The following table lists all the valid attributes: Property Description ease The transition gradually slow down the transition effect ease-in The transition starts slowly and then becomes faster for the transition effect ease-out The transition starts quickly and then slows the transition effect ease-in-out The transition starts slowly, then goes fast and then slowly ends the transition effect linear The transition changes at constant speed cubic-bezier(x1, y1, x2, y2) Using the custom transition in the third-order Bessel function, the parameter values of the function must be between 0 and 1. For more information on three times Bessel, see cubic-bezier and Bézier curve. Example#&lt;style scoped&gt; .panel &#123; margin: 10px; top:10px; align-items: center; justify-content: center; border: solid; border-radius: 10px; transition-property: width,height,backgroundColor; transition-duration: 0.3s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); &#125;&lt;/style&gt; Pseudo class v0.9.5+#Weex support four pseudo-classes: active, focus, disabled, enabled All components support active, but only the input component and the textarea component support focus, enabled, diabled. Rule# the high priority override low priority when rules take effect at the same time such as: “input:active:enabled” will override “input:active” the interconnection rule as follow Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; font-size: 48px; &#125; .logo &#123; width: 360px; height: 82px; background-color: red; &#125; .logo:active &#123; width: 180px; height: 82px; background-color: green; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: &#123; logoUrl: &#123; default: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png' &#125;, target: &#123; default: 'World' &#125; &#125;, methods: &#123; update (e) &#123; this.target = 'Weex'; &#125; &#125; &#125;;&lt;/script&gt; Try it linear-gradient v0.10+#Weex support linear-gradient background, You can see W3C description of the gradient. Supported components#All components in Weex support gradients Usage#You can use linear gradient by background-image property. background-image: linear-gradient(to top,#a80077,#66ff00); radial-gradient is not currently supported, do not use it. Weex currently supports two color gradients. The direction of the gradient is as follows: to rightFrom left to right to leftFrom right to left to bottomFrom top to bottom to topFrom bottom to top to bottom rightFrom the upper left corner to the lower right corner to top leftFrom the lower right corner to the upper left corner Note# background-image and background-color are set at the same time, background-image precedes background-color. Do not use shorthand property such as background. Example#&lt;template&gt; &lt;scroller style=\"background-color: #3a3a3a\"&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to left&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to bottom,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to top,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;align-items: center;justify-content: center\"&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to bottom right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to top left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top left&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .container1 &#123; margin: 10px; width: 730px; height: 200px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .container2 &#123; margin: 10px; width: 300px; height: 300px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .direction &#123; font-size: 40px; color: white; &#125;&lt;/style&gt; box-shadow v0.11+#Weex supports box-shadow in iOS： inset,offset-x,offset-y, blur-radius,color Note# box-shadow takes effect in iOS Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div style=\"width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px black;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px #008B00;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123;align-items: center; margin-top: 120px;&#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; logoUrl: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png', target: 'World' &#125;; &#125; &#125;;&lt;/script&gt; Other Common Style# opacity background-color Type of Style Value# length type number type color type (The list of color keywords.) enumerated type Simple Step#These up-to-down steps may help you to plan the whole style of weex pages. overall style: divide the whole page to different parts flex alignment: align boxes in every part of page position box: place box, set offset element specific style: set styles for certain element if needed","type":"wiki"},{"title":"Design Principles","path":"wiki/design-principles.html","permalink":"https://weex.apache.org/wiki/design-principles.html","text":"","type":"wiki"},{"title":"Event Bubble","path":"wiki/event-bubble.html","permalink":"https://weex.apache.org/wiki/event-bubble.html","text":"Event Bubble v0.13+#Weex 2.0 implements the W3C standard event bubbling mechanism. Usage#&lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it Run the above code, open with the client, click on the middle of the elements, you can see the event spread up, followed by the trigger. Notice#One thing should be noticed: For compatibility with previous versions, Weex does not turn on event bubbling by default. You need to add bubble = &quot;true&quot; on the root element’s properties to turn on the bubbling mechanism. Otherwise, the event will not be propagated upwards, keeping the same effect as the previous version. stopPropagation#In the event handler function, you can use the e.stopPropagation() method to prevent the event from escalating. Note that e.stopPropagation() differs from bubble = &quot;true&quot;, which affects only the current elements and the propagation of parent elements, without affecting the propagation of child elements; the latter is a switching mechanism that is added for compatibility, Will be a global shutdown or open the bubble mechanism, the two can co-exist, as follows: &lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' e.stopPropagation() &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' // e.stopPropagation() &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it Run the above code, open with the client, click on the middle of the element, you can see the event up to the parent element is terminated, no longer continue to spread to the root element.","type":"wiki"},{"title":"Platform Differences with Web","path":"wiki/platform-difference.html","permalink":"https://weex.apache.org/wiki/platform-difference.html","text":"Platform Differences with Web#Work in progresss.","type":"wiki"},{"title":"Gesture","path":"wiki/gestures.html","permalink":"https://weex.apache.org/wiki/gestures.html","text":"Gesture# Experiment Feature Weex encapsulates native touch events to provide a gesture system. Using gesture is similar to use event in Weex. Just set on attributes on a node to listen to gesture. Type#For now, there are four types of gestures: Touch. Touch gesture is fired when a touch point is placed, moved or removed from the touch surface. Touch gesture is accuracy as it will report every trivial event. As a result, listening to touch gesture may be slow, a great deal of events needs to be processed even a small move happened. There are three types of Touch gesture: touchstart will be fired when a touch point is placed on the touch surface. touchmove will be fired when a touch point is moved along the touch surface. touchend will be fired when a touch point is removed from the touch surface. Pan. Pan gesture also report motion of touch point on the touch surface, which is similar to touch gesture. But Pan gesture is sampled and faster than the touch event. As consequence, it is less accuracy than touch gesture. There are also three types of Pan gesture, and the meaning of these types is very close to types of Touch. panstart panmove panend Horizontal/Vertical Pan v0.10+ . Mainly used for cell swipe gestures before conflict resolving system is completed. start/move/end state of the gesture will be passed by state property. Note: These gestures are in conflict with click event on Android currently. horizontalpan verticalpan Swipe. Swipe is fired when user swipe a touch point on the screen. A serial of motion will only trigger one Swipe gesture. LongPress. LongPress is fired when a touch point is held for 500 ms or more. The Touch gesture and Pan is very close to each other, with following features hold: Touch. Not sampled, accuracy, but slow. Pan. Sampled, fast, less accuracy. Users may choose their gesture according to their situation. Properties#The following properties can be used in gesture callback: direction. Only exists for Swipe gesture. Indicate the direcion of the swipe, choose from up, left, bottom, right. changedTouches. An array of motion for every touch pointer that has contribute to the current gesture. changedTouches#changedTouches is an array, with the following properties in its children: identifier. A unique identifier for a touch pointer. pageX. The X coordinate of the touch pointer relative to the left edge of the document. pageY. The Y coordinate of the touch pointer relative to the top of the document. screenX. The X coordinate of the touch point relative to the left edge of the screen. screenY. The Y coordinate of the touch point relative to the top edge of the screen. Constrain#Currently, Weex Android do not support listening to gesture on scroller, list and webview, as it would lead a large amount of event conflicting.","type":"wiki"},{"title":"Text Styles","path":"wiki/text-styles.html","permalink":"https://weex.apache.org/wiki/text-styles.html","text":"Text alike components share some common style rules. The text alike components currently includes text and input. Properties# color: &lt;colors&gt; this property set the foreground color of an component’s text content. font-size: &lt;length&gt; this property specifies the size of the font. font-style: &lt;enum&gt; normal | italic. This property lets you select italic or normal faces within a font-family. Default value is normal. font-weightv0.9+: values: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal is equal to 400, bold equel to 700 default value: normal apply to: &lt;text&gt;, &lt;input&gt; ios support showing 9 kind of font-weight. android support showing 2 kind of font-weight:400,700, other value will map to 400 or 700 Some standard values like lighter, bolder, number unit are not supported. The effect not apply to all elements, just &lt;text&gt; and &lt;input&gt;. In another way, it’s not inherited. text-decoration: &lt;enum&gt; none | underline | line-through. This property is used to set the text formatting to underline or line-through. The default value is none. text-align: &lt;enum&gt; left | center | right. This property describes how inline content like text is aligned in its parent component. The default value is left. font-family:&lt;string&gt; this property set the font-family of the text. This property doesn’t guarantee the given font will always be set to the text. If the specified font cannot be found at the device, a typeface fallback will occur and the default typeface will be load. The fallback mechanism may vary in different devices. text-overflow:&lt;string&gt; clip | ellipsis. This property determines how overflowed content that is not displayed is signaled to users. It can be clipped, display an ellipsis. The property color support multiple fomats of values, contains rgb, rgba, #fff, #ffffff, named-color. Example: .my-class &#123; color: red; &#125;.my-class &#123; color: #f00; &#125;.my-class &#123; color: #ff0000; &#125;.my-class &#123; color: rgb(255, 0, 0); &#125;.my-class &#123; color: rgba(255, 0, 0, 0.5); &#125; Type of Style Value# length: number followed by length unit px, px can be omitted. colors: support multiple formats of values, including rgb (rgb(255, 0, 0)), rgba (rgba(255, 0, 0, 0.5)), hexadecimal (#ff0000), short hexadecimal (#f00), named color (red). enumerated values: a limited number of string values. Note: The list of color keywords.","type":"wiki"},{"title":"Android 扩展","path":"cn/guide/extend-android.html","permalink":"https://weex.apache.org/cn/guide/extend-android.html","text":"Android 扩展#Weex 提供了扩展机制，可以根据自己的业务进行定制自己的功能。主要分为两类扩展： Module 扩展 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展 Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。 Module 扩展# Module 扩展必须继承 WXModule 类。 扩展方法必须加上 @WXModuleAnno 注解。Weex 会根据注解来判断当前方法是否要运行在 UI 线程，和当前方法是否是扩展方法。 Weex是根据反射来进行调用 Module 扩展方法，所以Module中的扩展方法必须是 public 类型。 同样因为是通过反射调用，Module 不能被混淆。请在混淆文件中添加代码：-keep public class * extends com.taobao.weex.common.WXModule{*;} Module 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Module 后一定要在初始化时注册 WXSDKEngine.registerModule(&quot;myModule&quot;, MyModule.class); 否则会报类似错误：ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;printLog&#39; 示例如下： public class MyModule extends WXModule &#123; @WXModuleAnno(runOnUIThread = true) public void printLog(String msg) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125;&#125; JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"click\"&gt;点击我测试&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; click: function() &#123; weex.requireModule('myModule').printLog(\"我是一个测试!\"); &#125; &#125; &#125;&lt;/script&gt; 支持 synchronous/asynchronous 回调#你可以添加 @JSMethod(uiThread = false或true) 注释来选择 moudle 的回调模式。请参见以下示例： // as sync-callback mode@JSMethod (uiThread = false)public void testSyncCall()&#123; WXLogUtils.d(\"WXComponentSyncTest : Thread.currentThread().getName());&#125;// as async-callback mode@JSMethod (uiThread = true)public void testAsyncCall()&#123; WXLogUtils.e(\"WXComponentASynTest : Thread.currentThread().getName() );&#125; Component 扩展# Component 扩展类必须集成 WXComponent. Component 对应的设置属性的方法必须添加注解 @WXComponentProp(name=value(value is attr or style of dsl)) Weex sdk 通过反射调用对应的方法，所以 Component 对应的属性方法必须是 public，并且不能被混淆。请在混淆文件中添加代码 -keep public class * extends com.taobao.weex.ui.component.WXComponent{*;} Component 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Component 后一定要在初始化时注册 WXSDKEngine.registerComponent(&quot;richtext&quot;,RichText.class); 示例如下: public class RichText extends WXComponent &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, boolean isLazy) &#123; super(instance, dom, parent, isLazy); &#125; @Override protected void initView() &#123; mHost=new TextView(mContext); ((TextView)mHost).setMovementMethod(LinkMovementMethod.getInstance()); &#125; @WXComponentProp(name = \"tel\") public void setTelLink(String tel)&#123; SpannableString spannable=new SpannableString(tel); spannable.setSpan(new URLSpan(\"tel:\"+tel),0,tel.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ((TextView)mHost).setText(spannable); &#125;&#125; JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; Adapter扩展#图片下载： 需要时集成接口 IWXImgLoaderAdapter，实现 setImage 方法。 示例如下： public class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; 组件方法支持#从WeexSDK 0.9.5开始，你可以定义组件方法 在组件中如下声明一个组件方法 @JSMethodpublic void focus()&#123; //method implementation&#125; 注册组之后，你可以在weex 文件中调用 &lt;template&gt; &lt;mycomponent id='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function() &#123; this.$el('mycomponent').focus(); &#125; &#125;&lt;/script&gt; 注:工程要添加依赖 compile &#39;com.squareup.picasso:picasso:2.5.2&#39; SDK混淆规则#若要在APP中使用混淆，请在相应的配置文件中添加如下规则： -keep class com.taobao.weex.WXDebugTool&#123;*;&#125;-keep class com.taobao.weex.devtools.common.LogUtil&#123;*;&#125;-keepclassmembers class ** &#123; @com.taobao.weex.ui.component.WXComponentProp public *;&#125;-keep class com.taobao.weex.bridge.**&#123;*;&#125;-keep class com.taobao.weex.dom.**&#123;*;&#125;-keep class com.taobao.weex.adapter.**&#123;*;&#125;-keep class com.taobao.weex.common.**&#123;*;&#125;-keep class * implements com.taobao.weex.IWXObject&#123;*;&#125;-keep class com.taobao.weex.ui.**&#123;*;&#125;-keep class com.taobao.weex.ui.component.**&#123;*;&#125;-keep class com.taobao.weex.utils.**&#123; public &lt;fields&gt;; public &lt;methods&gt;; &#125;-keep class com.taobao.weex.view.**&#123;*;&#125;-keep class com.taobao.weex.module.**&#123;*;&#125;-keep public class * extends com.taobao.weex.common.WXModule&#123;*;&#125;-keep public class * extends com.taobao.weex.ui.component.WXComponent&#123;*;&#125;-keep public class com.taobao.taolive.ui.weex.**&#123;*;&#125;-keep class * implements com.taobao.weex.ui.IExternalComponentGetter&#123;*;&#125;-keep class com.alibaba.aliweex.hc.HCConfig&#123;*;&#125;-keep class com.alibaba.dynamic.**&#123;*;&#125;","type":"guide"},{"title":"iOS 扩展","path":"cn/guide/extend-ios.html","permalink":"https://weex.apache.org/cn/guide/extend-ios.html","text":"注意#Weex 所有暴露给 JS 的内置 module 或 component API 都是安全和可控的， 它们不会去访问系统的私有 API ，也不会去做任何 runtime 上的 hack 更不会去改变应用原有的功能定位。 如果需要扩展自定义的 module 或者 component ，一定注意不要将 OC 的 runtime 暴露给 JS ， 不要将一些诸如 dlopen()， dlsym()， respondsToSelector:，performSelector:，method_exchangeImplementations() 的动态和不可控的方法暴露给JS， 也不要将系统的私有API暴露给JS Module 扩展#swift 扩展 module Weex SDK 只提供渲染，而不是其他的能力，如果你需要 像网络，图片，URL跳转这些特性，需要自己动手实现他们例如，如果你想实现一个url地址跳转函数，你可以按照如下步骤实现一个 Module 自定义module的步骤# 自定义的module类 必须实现 WXModuleProtocol 必须添加宏WX_EXPORT_METHOD, 它可以被weex识别，它的参数是 JavaScript调用 module指定方法的参数 添加@synthesized weexInstance，每个moudle对象被绑定到一个指定的实例上 Module 方法会在UI线程中被调用，所以不要做太多耗时的任务在这里，如果要在其他线程执行整个module 方法，需要实现WXModuleProtocol中- (NSThread *)targetExecuteThread的方法，这样，分发到这个module的任务会在指定的线程中运行 Weex 的参数可以是 String 或者Map Module 支持返回值给 JavaScript中的回调，回调的类型是WXModuleCallback,回调的参数可以是String或者Map @implementation WXEventModule@synthesize weexInstance;WX_EXPORT_METHOD(@selector(openURL:callback:))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end 暴露同步方法v0.10+#如果你想要暴露同步的native方法给JS， 即JS可以直接拿到Native的返回值。 你可以使用WX_EXPORT_METHOD_SYNC 宏。 native 代码: @implementation WXEventModuleWX_EXPORT_METHOD_SYNC(@selector(getString))- (NSString *)getString&#123; return @&quot;testString&quot;;&#125;@end js 代码: const eventModule = weex.requireModule('event')const returnString = syncTest.getString() // return \"testString\" 除了string, 你也可以返回 number/array/dictionary 类型. 注意: 暴露的同步方法只能在 JS 线程执行，请不要做太多同步的工作导致JS执行阻塞。 注意: Vue 2.0 还未支持这个特性，最早会在 0.12 版本支持 注册 module#通过调用 WXSDKEngine 中的 registerModule:withClass方法来注册自己的module WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; 使用自己的 module#这里的 require 里面的 event 就是在 上一步调用 registerModule: 注册 module 时候的 name var eventModule = weex.requireModule('event');eventModule.openURL('url',function(ret) &#123; nativeLog(ret);&#125;); Weex SDK 没有 图片下载，navigation 操作的能力，请大家自己实现这些 protocol WXImgLoaderProtocol#weexSDK 没有图片下载的能力，需要实现 WXImgLoaderProtocol, 参考下面的例子 WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/*** @abstract Creates a image download handler with a given URL* @param imageUrl The URL of the image to download* @param imageFrame The frame of the image you want to set* @param options : The options to be used for this download* @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished.*/-(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end 实现上述协议 @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end handler注册#你可以通过WXSDKEngine 中的 registerHandler:withProtocol注册handler WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)] Components 扩展#虽然 WeexSDK 中有很多的 native 的 Component，但这有可能并不能满足你的需求。在之前你可能已经写了一些很酷炫 native 的组件，想包装一下，导入到 Weex 中，因此我们提供了让开发者实现自己的 native Component。下面将以 WeexSDK 中已经存在的 Component：image 为例子，介绍一下如何构建一个 native Component。假设你已经了解 iOS 开发 注册 Component#注册一个 component 比较简单，调用 WXSDKEngine 中的 registerComponent:withClass: 方法，传入组件的标签名称，还有对应的 class 然后你可以创建一个 WXImageComponent 表示 image 组件的实现。在 .we 文件中，只需要写 &lt;image&gt;&lt;/image&gt; 添加属性#现在我们要做一些让 image component 更加强大的事情。既然作为一个图片的 component，那它应该要有源，给他加上一个 src 的属性，同时给它加上一个 resize 的属性（可以配置的有 contain/cover/stretch） @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end component 中所有的 style，attribute，events 都会被传递到 Component 的初始化方法中，所以，你可以在初始化方法中存储你感兴趣的一些属性值 @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]];&#125; return self;&#125;@end attribute 中拿到的值的类型都是 id，我们可以用转换方法把它转换到任何值。Weex SDK 提供了一些基础的转换方法，可以参考 WXConvert 类，或者你可以添加自己的转换函数。 Hooking 渲染生命周期#native 的 component 是由 Weex 管理的，Weex 创建，布局，渲染，销毁。Weex 的 component 生命周期都是可以 hook 的，你可以在这些生命周期中去做自己的事情。 方法 描述 initWithRef:type:… 用给定的属性初始化一个component. layoutDidFinish 在component完成布局时候会调用. loadView 创建component管理的view. viewWillLoad 在component的view加载之前会调用. viewDidLoad 在component的view加载完之后调用. viewWillUnload 在component的view被释放之前调用. viewDidUnload 在component的view被释放之后调用. updateStyles: 在component的style更新时候调用. updateAttributes: 在component的attribute更新时候调用. addEvent: 给component添加event的时候调用. removeEvent: 在event移除的时候调用. 在 image component 的例子里面，如果我们需要我们自己的 image view 的话，可以复写 loadView这个方法. - (UIView *)loadView&#123;return [[WXImageView alloc] init];&#125; 现在我们使用 WXImageView 渲染 image component。作为一个 image component，我们需要拿到服务器图片，而且把它设置进 image view 里. 这个操作可以在 viewDidLoad 方法中做，这个方法是在 view 已经被创建而且加载了时候 Weex SDK 会调用到，而且 viewDidLoad 这个方法是你做额外初始化工作比如改变 content mode(也就是设置resize) 的最好时间. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; 如果可以改变 image 的 src，也可以 hook updateAttributes: 方法来做属性更新操作，当 updateAttributes: 或者 updateStyles: 被调用的时候， component 的 view 已经加载完成 - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; 或许你需要考虑更多的生命周期方法去 Hook，当布局完成时候，像 layoutDidFinish，如果你想了解更多，可以参考一下WXComponent.h 声明的方法。 现在你可以用在任何 .we 文件里面使用 &lt;image&gt;，而且可以加上 image 的属性。 &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt; component 方法#WeexSDK 0.9.5 之后支持了在 js 中直接调用 component 的方法，这里提供一个例子 自定义一个 WXMyCompoenent 的组件 @implementation WXMyComponentWX_EXPORT_METHOD(@selector(focus)) // 暴露该方法给js- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; // handle your attributes // handle your styles &#125; return self;&#125;- (void)focus&#123; NSLog(@&quot;you got it&quot;);&#125;@end 注册组件 [WXSDKEngine registerComponent:@&quot;mycomponent&quot; withClass:[WXMyComponent class]] 在 weex 文件中调用 &lt;template&gt; &lt;mycomponent ref='mycomponent'&gt;&lt;/mycomponent&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created:function() &#123; this.$refs.mycomponent.focus(); &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"HTML5 扩展","path":"cn/guide/extend-web-render.html","permalink":"https://weex.apache.org/cn/guide/extend-web-render.html","text":"如何扩展 Weex Web 端的组件和模块#Weex 本身提供了很多内置组件和模块，也具备横向扩展的能力，允许开发者自行扩展和定制。需要注意的是，Weex 是一个跨平台的解决方案，扩展其内置组件或模块，需要在三端（Android、iOS、Web）中都有相应的实现。 Weex 将内核切换成 Vue 2.x 之后，在 Web 端扩展 Vue 组件将变得更加容易。 扩展 Web 组件#Vue.js 本身就是一个独立的前端框架，在浏览器中完全能够不基于 Weex 容器渲染。因此，针对 Weex 平台扩展 Vue.js 的 Web 端组件，和直接使用 Vue.js 开发一个 Web 组件是一样的。具体的组件编写方法可以参考其官方文档：组件 ，另外建议使用 .vue 格式的文件编写组件，使用方法参考：单文件组件。 扩展组件示例#以扩展 &lt;sidebar&gt; 为例，首先应该编写组件自身的逻辑： &lt;!-- sidebar.vue --&gt;&lt;template&gt; &lt;div class=\"sidebar\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .sidebar &#123; /* ... */ &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: [], data () &#123; return &#123;&#125; &#125; &#125;&lt;/script&gt; 然后在使用之前，全局注册 &lt;sidebar&gt; 组件： import Vue from 'vue'import Sidebar from './path/to/sidebar.vue'// 全局注册 sidebar 组件Vue.component('sidebar', Sidebar) 在扩展 Weex 组件时，如果只使用了 Weex 提供的内置组件，并且使用的都是 Weex 支持的样式，那么就和普通的自定义组件无异，不需要 Native 端再有相应的实现。 如果你定制组件时不得不用到目前 Weex 不支持的标签和样式，在这种情况下才是真正的“扩展”了 Weex 的组件，你还需要在 Android 和 iOS 中有相应的实现，不然会导致渲染异常。 扩展 Web 模块#除了通用组件以外，Weex 还有提供了通用的模块，可以方便的调用原生 API。通常来说，注册 Weex 模块要求三端都得有相应的实现，否则会影响其正常的使用。 注册模块#如果你引入了 weex-vue-render 这个库，那么在全局能获取到 weex 这个变量，其中提供了 registerModule 方法可以注册模块。 API 格式# registerModule name: {String} 必选，模块名称。 define: {Object} 必选，模块的定义。 注册模块示例#下边的代码注册了一个名为 guide 的模块： weex.registerModule('guide', &#123; greeting () &#123; console.log('Hello, nice to meet you. I am your guide.') &#125;, farewell () &#123; console.log('Goodbye, I am always at your service.') &#125;&#125;) 使用模块#在 weex 上提供了 require 方法用于获取已注册的模块，直接传递模块名即可： // 获取模块const guide = weex.requireModule('guide')// 可以直接调用模块中的方法guide.greeting()guide.farewell() 上述写法在 Native 环境中依然有效，只不过模块中的方法是由 Native 提供的。","type":"guide"},{"title":"拓展 JS framework","path":"cn/guide/extend-js-framework.html","permalink":"https://weex.apache.org/cn/guide/extend-js-framework.html","text":"定制自己的 JS Framework#这部分扩展能力还在讨论尝试中，可能随时会有调整，请留意。 Weex 希望能够尊重尽可能多的开发者的使用习惯，所以除了 Weex 官方支持的 Vue 2.0 之外，开发者还可以定制并横向扩展自己的或自己喜欢的 JS Framework。完整一套 JS Framework 的定制和扩展需要以下几个步骤： 首先你要有一套完整的 JS Framework。 了解 Weex 的 JS 引擎的特性支持情况。 适配 Weex 的 native DOM APIs。 适配 Weex 的初始化入口和多实例管理机制。 在 Weex JS runtime 的 framework 配置中加入自己的 JS Framework 然后打包。 基于该 JS Framework 撰写 JS bundle，并加入特定的前缀注释，以便 Weex JS runtime 能够正确识别。 Weex JS 引擎的特性支持情况# 在 iOS 下，Weex 使用的是系统自带的 JavaScriptCore，所以 ES 支持情况取决于操作系统的版本。目前保守判断，ES5 的特性市面上主流的 iOS 设备都是可以完美支持的，但是 ES6+ 的特性存在一定的碎片化。 在 Android 下，Weex 使用的是 UC 提供的 v8 内核，出于体积、性能和稳定性的考虑，我们使用的并不是最新版本的 v8 内核，同样的保守判断，ES5 特性能够全部支持，包括严格模式、Object.freeze 等。 Weex JS 引擎不支持 HTML DOM APIs 和 HTML5 JS APIs，这包括 document, setTimeout 等。 在此基础上，我们加入了 Promise 的 polyfill，以及 console 的 polyfill。 额外的，为了尽可能的确保 JS 引擎的长效内存管理，我们对一个通用的全局对象进行了 Object.freeze() 冻结操作，这包括： Object Object.prototype Array Array.prototype String.prototype Number.prototype Boolean.prototype Error.prototype Date.prototype RegExp.prototype 适配 Weex 的初始化入口和多实例管理机制#开发者提供的 JS Framework 最终需要包装成一个 CommonJS 包，并且这个包需要对外暴露以下方法： 框架初始化# init(config) config Document Element Comment TaskSender CallbackManager 该方法会把 Weex 提供的 Native DOM 类和两个辅助类放到 config 参数中，并允许框架本身完成初始化。 小提示：同时，框架作者也能够通过在框架初始化时传入不同的 config 来进行框架的测试或环境模拟。 参数格式介绍# TaskSender: wip… CallbackManager: wip… 注册可用的 native 组件和模块# registerComponents(components) registerModules(modules) 这两个方法会在框架初始化之后立刻调用，这样框架就能够知道当前的客户端支持哪些组件和模块，在一些特殊逻辑或必要的情况下，有机会为框架本身提供参考信息。 参数格式介绍# components: Array: 描述组件的数组，每一项包括： type: string: 组件名称，比如 div。 methods: string[]: 可选项，该组件支持的方法名称列表，这些方法可以遵循 Weex 的 native DOM APIs 的组件方法调用方式。 modules: Object: 描述一系列模块的散列表，每一项的 key 是模块名，每一项的值是一个数组，数组里的每一项描述了一个该模块中的一个方法，该方法的信息包括： name: string: 方法名 args: string[]: 参数个数和类型描述 例如： registerComponents([ &#123; type: 'web', methods: ['goBack', 'goForward', 'refresh']&#125;])registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ]&#125;) 多实例生命周期管理# createInstance(instanceId, code, config, data, env) refreshInstance(instanceId, data) destroyInstance(instanceId) 每个 Weex 页面都有被创建、被销毁两个必经阶段，同时在 Weex 页面运行过程中，native 有机会主动向 Weex 页面发送消息，不同的框架可以根据自己框架的设计对这样的消息有自己的理解和设计实现。 参数格式介绍# instanceId: string: 该 Weex 页面的唯一 id，由 native 产生。 code: string: 该 Weex 页面的 JS bundle 的代码，通过 native 传入。 config: Object?: 该 Weex 页面的配置信息，比如代表该 bundle 地址的 bundleUrl，由 native 配置产生，和 JS bundle 本身的内容无关。 data: Object?: Native 有机会在创建一个 Weex 页面的时候，传入一份外部数据，JS 框架也有机会接此机会为相同的 JS bundle 配合不同的 data 生成不同的页面内容。 env: Object?: 当前 Weex 页面的相关环境信息，各字段的含义： info: Object: 框架 info 信息，详见之后的 “JS Bundle 格式要求”。 config: Object: 等同该方法的第三个参数 config。 callbacks: CallbackManager: 该 Weex 页面唯一的 CallbackManager 实例。 created: number: 该 Weex 页面的创建时间毫秒数。 framework: string: 该 Weex 页面基于的框架名，等同于 info.framework。 Native 通信# receiveTasks(instanceId, tasks) Native 除了通过 refreshInstance 方法向 JS 框架层发送消息之外，更多的会通过 receiveTasks 发送用户事件或方法回调给 JS 框架。 比如用户点击了一个按钮，native 就会发送一个 fireEvent 类型的任务给 JS 框架，然后 JS 框架再处理相应的事件逻辑。这部分工作机制和 native DOM 接口中的 addEvent 的设计有关。 再比如用户发起了一个 fetch 网络请求，当请求在 native 端完成时，会以一个 callback 类型的任务发给 JS 框架。由于 native 无法传递 JavaScript 中的 function，所以实际上知会发送一个 callbackId 给 JS 框架。这部分工作机制和之前出现过的 CallbackManager 的设计有关。 辅助方法# getRoot(instanceId): JSON 该方法可以返回文档主体结点的完整 JSON 描述，开发者可以以此查看到完整的 native DOM 树，具体返回值的格式和 native DOM 接口中的 toJSON() 方法返回值格式一致。此功能多用作开发者工具扩展。 在 WeexSDK 中配置 JS Framework#准备好你的 JS Framework 代码#// your-own-js-framework.jsexport function init (config) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function createInstance (id, code, config, data, env) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; 注册一个 JS Framework#import * as Vue from '...'import * as React from '...'import * as Angular from '...'export default &#123; Vue, React, Angular &#125;; 然后打包 JS runtime，集成到 WeexSDK 中。 JS Bundle 格式要求#框架 info 你需要保障基于该 JS Framework 的 JS Bundle 在文件开头带有如下格式的注释，我们称其为框架 info： // &#123; \"framework\": \"Vue\" &#125;... 这样 Weex JS 引擎就会识别出这个 JS bundle 需要用 Vue 框架来解析。并分发给 Vue 框架处理。同理，Weex 支持同时多种框架在一个移动应用中共存并各自解析基于不同框架的 JS bundle。","type":"guide"},{"title":"支持的前端框架","path":"cn/guide/front-end-frameworks.html","permalink":"https://weex.apache.org/cn/guide/front-end-frameworks.html","text":"Vue.js#Rax#","type":"guide"},{"title":"集成 Devtools 到 iOS","path":"cn/guide/integrate-devtool-to-ios.html","permalink":"https://weex.apache.org/cn/guide/integrate-devtool-to-ios.html","text":"集成 Devtools 到 iOS#Weex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 iOS 端如何接入 Weex Devtools。 iOS 应用接入#添加依赖#方法一：cocoapods 依赖#在工程目录的 podfile 添加如下代码 source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;]， 目前有如下几个版本： 0.7.0, 0.6.1, 0.1.1, 0.1.0 [master repo] 可以通过更新本地 podspec repo，pod search 来查询最新版本，在 podfile 文件添加依赖。 推荐在DEBUG模式下依赖。 方法二：github 源码依赖# 拉取最新的WXDevtool代码。 按照如下图示：直接拖动source目录源文件到目标工程中 按照红框中配置勾选 在相对较大的互联网 App 研发中, framework 静态库被广泛应用，所以推荐使用方法一接入。 集成功能#如果按照方法一接入：podfile 的方式，添加头文件包含： #import &lt;TBWXDevtool/WXDevtool.h&gt; 如果按照方法二接入：源码依赖的方式，添加头文件包含： #import &quot;WXDevtool.h&quot; 查看 WXDevtool 头文件如下： #import &lt;Foundation/Foundation.h&gt;@interface WXDevTool : NSObject/*** set debug status* @param isDebug : YES:open debug model and inspect model;* default is NO,if isDebug is NO, open inspect only;* */+ (void)setDebug:(BOOL)isDebug;/*** get debug status* */+ (BOOL)isDebug;/*** launch weex debug* @param url : ws://ip:port/debugProxy/native, ip and port is your devtool server address* eg:@&quot;ws://30.30.29.242:8088/debugProxy/native&quot;* */+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end setDebug：参数为 YES 时，直接开启 debug 模式，反之关闭，使用场景如下所述 在你自己的程序中添加如下代码： [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 其中的 ws 地址正是 Weex debug 控制台中出现的地址，直接 copy 到 launchDevToolDebugWithUrl 接口中。 如果程序一启动就开启 Weex 调试，需要在 WeexSDK 引擎初始化之前添加代码： [WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 附加页面刷新功能# 为什么需要页面刷新功能？ 如下图所示，当点击 debugger 按钮时，js 的运行环境会从手机端（JavaScriptCore）切换到 Chrome（V8），这时需要重新初始化 Weex 环境，重新渲染页面。页面渲染是需要接入方在自己的页面添加。 什么场景下需要添加页面刷新功能? 点击 debugger 按钮调试 切换 RemoteDebug 开关 刷新 Chrome 页面（command+R） 如何添加刷新 在 Weex 页面初始化或 viewDidLoad 方法时添加注册通知，举例如下： [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; 最后千万记得在 dealloc 方法中取消通知，如下所示 - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; 具体实现可参考 playground WXDemoViewController.m 文件 说明：目前版本需要注册的通知名称为固定的 “RefreshInstance”，下个版本会添加用户自定义 name 。 使用#如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 《Get started》）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 日志级别控制 日志级别可以控制native端关于weex的日志。 日记级别描述如下： Off = 0,Error = ErrorWarning = Error | Warning,Info = Warning | Info,Log = Log | Info,Debug = Log | Debug,All = NSUIntegerMax 解释：off 关闭日志，Warning 包含 Error、Warning，Info 包含 Warning、Info，Log 包含 Info、Log，Debug 包含 Log、Debug，All 包含所有。 Vdom/Native tree选择 图一 图二 点击图一所示native选项会打开图二，方便查看native tree以及view property 图三 图四 点击图三所示 vdom 选项会打开图四，方便查看 vdom tree 以及 component property。","type":"guide"},{"title":"集成 Devtools 到 Android","path":"cn/guide/integrate-devtool-to-android.html","permalink":"https://weex.apache.org/cn/guide/integrate-devtool-to-android.html","text":"集成 Devtools 到 Android#Weex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 Android 端如何接入 Weex Devtools。 Android 应用接入#添加依赖#可以通过 Gradle 或者 Maven 添加对 devtools aar 的依赖，也可以直接对源码依赖。强烈建议使用最新版本，因为 Weex SDK 和 devtools 都在快速的迭代开发中，新版本会有更多惊喜，同时也修复老版本中一些问题。最新的 release 版本可在这里查看。所有的 release 版本都会发布到 jcenter repo。 Gradle 依赖 dependencies &#123; compile 'com.taobao.android:weex_inspector:$&#123;version&#125;'&#125; Maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.taobao.android&lt;/groupId&gt; &lt;artifactId&gt;weex_inspector&lt;/artifactId&gt; &lt;version&gt;$&#123;version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 源码依赖 需要复制 inspector 目录到你的 App 的同级目录，然后在工程的 settings.gradle 文件下添加 include &quot;:inspector&quot;，此过程可以参考 playground 源码的工程配置及其配置，然后在 App 的 build.gralde 中添加依赖。 dependencies &#123; compile project(':inspector')&#125; 另外 weex_inspector 中有一部分包是以 provided 的方式引入，接入方需要自行解决依赖和版本冲突。 provided方式引用的包 dependencies &#123; provided 'com.google.code.findbugs:jsr305:2.0.1' provided 'com.android.support:appcompat-v7:23.1.1' provided 'com.taobao.android:weex_sdk:0.8.0' provided 'com.alibaba:fastjson:1.1.45+' ...&#125; 反射引用的包(0.8.0.0以上版本) dependencies &#123; compile 'com.squareup.okhttp:okhttp:2.3.0' compile 'com.squareup.okhttp:okhttp-ws:2.3.0' ...&#125; 或者 dependencies &#123; compile 'com.squareup.okhttp:okhttp:3.4.1' compile 'com.squareup.okhttp:okhttp-ws:3.4.1' ...&#125; 版本兼容# weex sdk weex inspector Debugger Server 0.13+ 0.12+ 0.2.39+ 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - 添加 Debug 模式开关#控制调试模式的打开和关闭的关键点可以概括为三条规则。 规则一：通过 sRemoteDebugMode 和 sRemoteDebugProxyUrl 来设置开关和 Debugger Server 地址。 Weex SDK 的 WXEnvironment 类里有一对静态变量标记了 Weex 当前的调试模式是否开启分别是： public static boolean sRemoteDebugMode; // 是否开启 debug 模式，默认关闭public static String sRemoteDebugProxyUrl; // DebugServer的websocket地址 无论在 App 中无论以何种方式设置 Debug 模式，都必须在恰当的时机调用类似如下的方法来设置 WXEnvironment.sRemoteDebugMode 和 WXEnvironment.sRemoteDebugProxyUrl。 private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; 规则二：修改 sRemoteDebugMode 后一定要调用`WXSDKEngine.reload()。 一般來說，在修改了 WXEnvironment.sRemoteDebugMode 以后调用了 WXSDKEngine.reload() 方法才能够使 Debug模式生效。WXSDKEngine.reload() 用来重置 Weex 的运行环境上下文，在切换调试模式时需要调用此方法来创建新的 Weex 运行时和 DebugBridge 并将所有的 JS 调用桥接到调试服务器执行。在 reload 过程中会调用 launchInspector，这就是 SDK 控制 Debug 模式最核心一个方法，其传入参数即为 sRemoteDebugMode，若为 true 则该方法中尝试以反射的方式获取 DebugBridge 用来在远端执行 JS，否则在本地运行。 private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; 只要遵循上面的原理，开启 Debug 模式的方式和时机可由接入方灵活实现。从 launchInspector 可以看到，SDK 对 devtools 的 aar 包并无强依赖,我们的 App 只需要在 Debug 包中打包该 aar 即可，这样多少可以缓解包大小问题和安全问题。 例外： 若修改 WXEnvironment.sRemoteDebugMode 的时机在 WXBridgeManager 初始化和 restart 和之前则 WXSDKEngine.reload() 可忽略. 规则三：通过响应 ACTION_DEBUG_INSTANCE_REFRESH 广播及时刷新。 广播 ACTION_DEBUG_INSTANCE_REFRESH 在调试模式切换和 Chrome 调试页面刷新时发出，主要用来通知当前的 Weex容器以 Debug 模式重新加载当前页。在 playground 中的处理过程如下： public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; 如果接入方的容器未对该广播做处理，那么将不支持刷新和调试过程中编辑代码时的 watch 功能。 接入示例#最简单方式就是复用 Playground 的相关代码，比如扫码和刷新等模块，但是扫码不是必须的，它只是与 App 通信的一种形式，二维码里的包含 DebugServer IP 及 bundle 地址等信息，用于建立 App 和 Debugger Server 之间的连接及动态加载 bundle。在 Playground 中给出了两种开启 debug 模式的范例。 范例1：通过在 XXXApplication 中设置开关打开调试模式 public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; 这种方式最直接，在代码中直接 hardcode 了开启调试模式，如果在 SDK 初始化之前调用甚至连 WXSDKEngine.reload() 都不需要调用，接入方如果需要更灵活的策略可以将 initDebugEnvironment(boolean enable, String host) 和 WXSDKEngine.reload() 组合在一起在合适的位置和时机调用即可。 范例2：通过扫码打开调试模式 Playground 中较多的使用扫码的方式传递信息，不仅用这种方式控制 Debug 模式的开关,而且还通过它来传入 bundle 的 url 直接调试。应当说在开发中这种方式是比较高效的，省去了修改 SDK 代码重复编译和安装 App 的麻烦，缺点就是调试工具这种方式接入需要 App 具有扫码和处理特定规则二维码的能力。除了 Playground 中的方式，接入方亦可根据业务场景对 Debugger 和接入方式进行二次开发。 Playground 集成的具体代码可参考如下两个文件： 开关控制，主要参考对二维码的处理部分，详见 WXApplication.java 刷新控制 ，主要参考是对容器 ACTION_DEBUG_INSTANCE_REFRESH的处理，详见 WXPageActivity.java 牛刀小试#前置工作#如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 《Get Started》）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 开始调试#如果你的 App 客户端完成了以上步骤那么恭喜你已经接入完毕，可以愉快的调试 Weex bundle 了，调试体验和网页调试一致！建议新手首先用官方的 Playground 体验一下调试流程。只需要启动 App 扫描 Chrome 调试页面下方的第一个二维码即可建立与 Debugger Server 的通信，Chorome 的调试页面将会列出连接成功的设备信息。 主要步骤如下# 如果你要加载服务器上 bundle，第一步就是要让你的 bundle sever 跑起来. 在 Playground 中特别简单，只需要你到 Weex 源码目录下，运行 ./start 即可。 命令行运行 weex debug 启动 Debugger Server，Chrome 将会打开一个网页，在网页下方有一个二维码和简单的介绍。 启动 App 并确认打开调试模式。你将在上一步中打开的网页中看到一个设备列表，每个设备项都有两个按钮，分别是 Debugger 和 Inspector。 点击 Inspector Chrome 将创建 Inspector 网页；点击 Debugger Chrome 将创建 Debugger 网页；二者是相互独立的功能，不相互依赖。 背景知识#Devtools 组件介绍#Devtools 扩展了 Chrome Debugging Protocol，在客户端和调试服务器之间的采用 JSON-RPC 作为通信机制，本质上调试过程是两个进程间协同，相互交换控制权及运行结果的过程。更多细节还请阅读 Weex Devtools Debugger 的技术选型实录这篇文章。 客户端 Devtools 客户端作为 aar 被集成 App 中，它通过 webscoket 连接到调试服务器，此处并未做安全检查。出于安全机制及包大小考虑，强烈建议接入方只在 debug 版本中打包此 aar。 服务器 Devtools 服务器端是信息交换的中枢，既连接客户端，又连接 Chrome，大多数情况下扮演一个消息转发服务器和 Runtime Manager 的角色。 Web端 Chrome 的 V8 引擎扮演着 Bundle javascript runtime 的角色。开启 debug 模式后，所有的 bundle js 代码都在该引擎上运行。另一方面我们也复用了 Chrome 前端的调试界面，例如设置断点，查看调用栈等，调试页关闭则 runtime 将会被清理。 调试的大致过程请参考如下时序图。 FAQ#在各业务接入过程中，陆续发现一些问题，对高频次的问题解答如下，开发中以 weex debug -V 的方式启动 Debugger Server 可以看到 server 端的 log 信息，对照上文中的时序图对于定位问题还是非常有帮助，建议调试中默认开启 server 端 log。 扫码 App 在 DebugServerProxy 中抛出 class not found 已知的原因如下： weex_inspector 以 provided 方式引用的包是否引入成功，如 fastjson 等。 weex_inspector 以 compile 方式引用的包是否引入成功，某些 app 重新引入 com.squareup.okhttp:okhttp:2.3.0 和 com.squareup.okhttp:okhttp-ws:2.3.0 则不再报错。 混淆规则影响反射。 playground 扫码调试 crash 已知的原因如下： 系统为 android 6+，崩溃信息提示进程需要 android.permission.READ_PHONE_STATE 权限，代码中未做权限检查，在 0.0.2.7 版本以后已修复，不再需要此权限。 扫码后设备列表页并没有出现我的设备信息 已知的原因如下： Debugger Server 和手机在不同网段，被防火墙隔离。 手机连接了 PC 端的代理，当前尚不支持。 多进程连接服务器端的同一端口，比如在 Application 的 onCreate 中初始化 sdk，若多个进程连接服务器端的同一端口则报错，在 0.0.2.3 版本以后已支持多进程无此问题。 调试过程中频繁刷新连接失败，Server 端提示重新启动 App，非必现 已知的原因如下： 多线程操作网络连接引起，在频繁的即断即连时容易触发。在 0.0.7.1 版本已修复。 注入自定义WebSocket Client#目前Inspector以反射的方式动态调用了okhttp-ws库中的相关代码，可以兼容的okhttp与okhttp-ws版本为： okhttp, okhttp-ws 2.7.5版本以下 okhttp3, okhttp3-ws 3.5版本以下 如果客户端中集成的版本与上述版本不匹配，则可以使用WeexInspector.overrideWebSocketClient方法来注入自定义的WebSocket实现，示例：public class CustomWebSocketClient implements IWebSocketClient &#123; private WebSocket ws; @Override public boolean isOpen() &#123; return ws != null; &#125; @Override public void connect(String wsAddress, final WSListener listener) &#123; OkHttpClient okHttpClient = new OkHttpClient(); okHttpClient.setConnectTimeout(5, TimeUnit.SECONDS); okHttpClient.setReadTimeout(5, TimeUnit.SECONDS); okHttpClient.setWriteTimeout(5, TimeUnit.SECONDS); Request request = new Request.Builder().url(wsAddress).build(); WebSocketCall webSocketCall = WebSocketCall.create(okHttpClient, request); webSocketCall.enqueue(new WebSocketListener() &#123; @Override public void onOpen(WebSocket webSocket, Request request, Response response) throws IOException &#123; ws = webSocket; listener.onOpen(); &#125; @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException &#123; if (WebSocket.PayloadType.TEXT == type) &#123; listener.onMessage(payload.readUtf8()); &#125; &#125; @Override public void onPong(Buffer payload) &#123; //ignore &#125; @Override public void onClose(int code, String reason) &#123; listener.onClose(); &#125; @Override public void onFailure(IOException e) &#123; listener.onFailure(e); &#125; &#125;); &#125; @Override public void close() &#123; if (ws != null) &#123; try &#123; ws.close(CloseCodes.NORMAL_CLOSURE, \"Normal closure\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void sendMessage(int requestId, String message) &#123; if (ws != null) &#123; try &#123; ws.sendMessage(WebSocket.PayloadType.TEXT, new Buffer().writeString(message, Charset.defaultCharset())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","type":"guide"},{"title":"集成 Weex 到已有应用","path":"cn/guide/integrate-to-your-app.html","permalink":"https://weex.apache.org/cn/guide/integrate-to-your-app.html","text":"集成 Weex 到已有应用#集成到 Android#注：以下文档都是假设您已经具备一定的Android开发经验。 Android 集成有两种方式# 源码依赖：能够快速使用WEEX最新功能，可以根据自己项目的特性进行相关改进。 SDK依赖：WEEX 会在jcenter 定期发布稳定版本。jcenter注:国内可能需要翻墙 前期准备# 已经安装了JDK version&gt;=1.7 并配置了环境变量 已经安装Android SDK 并配置环境变量。 Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) 快速接入#如果你是尝鲜或者对稳定性要求比较高可以使用依赖SDK的方式。步骤如下： 创建Android工程，没有什么要特别说明的，按照你的习惯来。 修改build.gradle 加入如下基础依赖 compile 'com.android.support:recyclerview-v7:23.1.1'compile 'com.android.support:support-v4:23.1.1'compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.alibaba:fastjson:1.1.46.android'compile 'com.taobao.android:weex_sdk:0.5.1@aar' 注:版本可以高不可以低。 代码实现#注:附录中有完整代码地址 实现图片下载接口，初始化时设置。 package com.weex.sample;import android.widget.ImageView;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/** * Created by lixinke on 16/6/1. */public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现你自己的图片下载，否则图片无法显示。 &#125;&#125; 初始化 package com.weex.sample;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/** * 注意要在Manifest中设置android:name=\".WXApplication\" * 要实现ImageAdapter 否则图片不能下载 * gradle 中一定要添加一些依赖，否则初始化会失败。 * compile 'com.android.support:recyclerview-v7:23.1.1' * compile 'com.android.support:support-v4:23.1.1' * compile 'com.android.support:appcompat-v7:23.1.1' * compile 'com.alibaba:fastjson:1.1.45' */public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; 开始渲染 package com.weex.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * width 为-1 默认全屏，可以自己定制。 * height =-1 默认全屏，可以自己定制。 */ mWXSDKInstance.render(\"WXSample\", WXFileUtils.loadFileContent(\"hello.js\", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 源码依赖(IDE Android Studio)# 下载源码 git clone https://github.com/alibaba/weex 创建 Android 工程。 通过以下路径引入 SDK ModuleFile-&gt;New-Import Module-&gt; 选择 WEEX SDK Module(weex/android/sdk) -&gt; Finish app 的 build.gradle 中添加如下依赖:compile project(&#39;:weex_sdk&#39;) 其他设置请参考上面快速接入 附录#WXSample地址 https://github.com/xkli/WXSample.git 集成到 iOS#通过cocoaPods 集成 Weex iOS SDK到你的项目#首先假设你已经完成了安装 iOS 开发环境 和 CocoaPods 第一步：添加依赖#导入 Weex iOS SDK 到你已有的项目, 如果没有，可以参考新建项目在继续下面内容之前，确保你已有的项目目录有名称为 Podfile 文件，如果没有，创建一个，用文本编辑器打开 集成 framework WeexSDK 在 cocoaPods 上最新版本 可以在这获取 在 Podfile 文件中添加如下内容 source &apos;git@github.com:CocoaPods/Specs.git&apos;target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, &apos;0.9.5&apos; ## 建议使用WeexSDK新版本end 源码集成 首先 拷贝 ios/sdk 目录到你已有项目目录 (此处以拷贝到你已有项目的根目录为例子)，然后在 Podfile 文件中添加 source &apos;git@github.com:CocoaPods/Specs.git&apos;target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos;end 第二步：安装依赖#打开命令行，切换到你已有项目 Podfile 这个文件存在的目录，执行 pod install，没有出现任何错误表示已经完成环境配置。 第三步：初始化 Weex 环境#在 AppDelegate.m 文件中做初始化操作，一般会在 didFinishLaunchingWithOptions 方法中如下添加。 //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk environment[WXSDKEngine initSDKEnvironment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level[WXLog setLogLevel: WXLogLevelAll]; 第四步：渲染 weex Instance#Weex 支持整体页面渲染和部分渲染两种模式，你需要做的事情是用指定的 URL 渲染 Weex 的 view，然后添加到它的父容器上，父容器一般都是 viewController。 #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad&#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;js&quot;]; [_instance renderWithURL:url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance 是很重要的一个类，提供了基础的方法和一些回调，如 renderWithURL, onCreate, onFailed 等，可以参见 WXSDKInstance.h 的声明。 第五步：销毁 Weex Instance# 在 viewController 的 dealloc 阶段 销毁掉 Weex instance，释放内存，避免造成内存泄露。 - (void)dealloc&#123; [_instance destroyInstance];&#125; 导入 Weex SDK framework 到工程# 可以通过源码编译出 Weex SDK，可以在新的 feature 或者 bugfix 分支，尝试最新的 feature。 参考此处直接导入 weexSDK。","type":"guide"},{"title":"搭建开发环境","path":"cn/guide/set-up-env.html","permalink":"https://weex.apache.org/cn/guide/set-up-env.html","text":"搭建开发环境#使用 dotWe 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex， dotWe 就不怎么够用了。本节会教你如何搭建本地开发环境进行 Weex 开发。 第一步：安装依赖#Weex 官方提供了 weex-toolkit 的脚手架工具来辅助开发和调试。首先，你需要 Node.js 和 Weex CLi。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 对于 Mac，可以使用 Homebrew 进行安装： brew install node 更多安装方式可参考 Node.js 官方信息 安装完成后，可以使用以下命令检测是否安装成功： $ node -vv6.11.3$ npm -v3.10.10 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit。 npm 是一个 JavaScript 包管理工具，它可以让开发者轻松共享和重用代码。Weex 很多依赖来自社区，同样，Weex 也将很多工具发布到社区方便开发者使用。 注意: 在weex-toolkit1.0.8\b版本后添加了npm5规范的npm-shrinkwrap.json用于锁定包依赖，故npm版本&lt;5的用户需要通过npm i npm@latest -g更新一下npm的版本，使用前请确认版本是否正确。 $ npm install -g weex-toolkit$ weex -v //查看当前weex版本 weex-toolkit也支持直接升级子依赖，如：weex update weex-devtool@latest //@后标注版本后，latest表示最新 国内开发者可以考虑使用淘宝的 npm 镜像 —— cnpm 安装 weex-toolkit $ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm install -g weex-toolkit 提示： 如果提示权限错误（permission error），使用 sudo 关键字进行安装 $ sudo cnpm install -g weex-toolkit 安装结束后你可以直接使用 weex 命令验证是否安装成功，它会显示 weex 命令行工具各参数： 第二步：初始化#然后初始化 Weex 项目： $ weex create awesome-project 执行完命令后，在 awesome-project 目录中就创建了一个使用 Weex 和 Vue 的模板项目。 第三步：开发#之后我们进入项目所在路径，weex-toolkit 已经为我们生成了标准项目结构。 在 package.json 中，已经配置好了几个常用的 npm script，分别是： build: 源码打包，生成 JS Bundle dev: webpack watch 模式，方便开发 serve: 开启HotReload服务器，代码改动的将会实时同步到网页中 我们先通过 npm install 安装项目依赖。之后运行根目录下的 npm run dev &amp; npm run serve 开启 watch 模式和静态服务器。 然后我们打开浏览器，进入 http://localhost:8080/index.html 即可看到 weex h5 页面。 初始化时已经为我们创建了基本的示例，我们可以在 src/index.vue 中查看。 代码如下所示： &lt;template&gt; &lt;div class=\"wrapper\" @click=\"update\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;text class=\"desc\"&gt;Now, let's use vue to build your weex app.&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; padding-top:40px; padding-bottom: 40px; font-size: 48px; &#125; .logo &#123; width: 360px; height: 156px; &#125; .desc &#123; padding-top: 20px; color:#888; font-size: 24px;&#125;&lt;/style&gt;&lt;script&gt; export default &#123; data: &#123; logoUrl: 'http://img1.vued.vanthink.cn/vued08aa73a9ab65dcbd360ec54659ada97c.png', target: 'World' &#125;, methods: &#123; update: function (e) &#123; this.target = 'Weex' console.log('target:', this.target) &#125; &#125; &#125;&lt;/script&gt; 关于 Weex 语法部分，你可以直接参考 Vue Guide，这里不再重复介绍。如果您想了解有关技术详情的更多信息，请继续阅读下一节。并且不要忘记在 dotWe 写代码并随时预览。","type":"guide"},{"title":"使用 Rax","path":"cn/guide/using-rax.html","permalink":"https://weex.apache.org/cn/guide/using-rax.html","text":"","type":"guide"},{"title":"使用 Vue.js","path":"cn/guide/using-vue.html","permalink":"https://weex.apache.org/cn/guide/using-vue.html","text":"使用 Vue 开发 Weex 页面#Vue in Weex#Vue.js 是 Evan You 开发的渐进式 JavaScript 框架，在易用性、灵活性和性能等方面都非常优秀。开发者能够通过撰写 *.vue 文件，基于 &lt;template&gt;, &lt;style&gt;, &lt;script&gt; 快速构建组件化的 web 应用。 Vue.js 在 2016 年 10 月正式发布了 2.0 版本，该版本加入了 Virtual-DOM 和预编译器的设计，使得该框架在运行时能够脱离 HTML 和 CSS 解析，只依赖 JavaScript；同时 Virtual-DOM 也使得 Vue 2.x 渲染成原生 UI 成为了可能。 目前 Weex 与 Vue 正在展开官方合作，并将 Vue 2.x 作为内置的前端框架，Vue 也因此具备了开发原生应用的能力。 相关链接 Weex 快速上手 Vue 介绍 Weex 工作原理 Vue 2.x 在 Weex 中的特色功能#流式渲染#在 Weex 中，我们可以通过 &lt;foo append=&quot;tree|node&quot;&gt; 的方式定义页面首次渲染时的渲染颗粒度，这让开发者有机会根据界面的复杂度和业务需求对首次渲染过程进行定制。append=&quot;tree&quot; 表示整个结点包括其所有子结点全部生成完毕之后，才会一次性渲染到界面上；而 append=&quot;node&quot; 则表示该结点会先渲染在界面上作为一个容器，其子结点会稍后做进一步渲染。 表单控件绑定#在 Weex 中，我们针对 &lt;input&gt; 和 &lt;textarea&gt; 这两个表单控件提供了和 web 体验相同的 v-model 指令。通过 &lt;input v-model=&quot;message&quot;&gt; 或 &lt;textarea v-model=&quot;message&quot;&gt;，开发者可以把数据 message 的值自动展示在文本框上，同时用户修改了文本框的值的时候，数据 message 会自动被更新。 多页面上下文隔离#如 Weex 工作原理文中所述，所有 Weex 的 JS bundle 公用一个 JavaScript 内核实例。所以如何能够让多个 JS bundle 中使用的 Vue 是完全隔离的，并且其中一个页面对 Vue 进行扩展或改写不会影响到其它页面就变成了一个问题，通过 Weex 和 Vue 双方的协作，这一问题已经得以解决。大家可以放心使用。 &lt;transition&gt; 过渡状态#Weex 支持了 Vue 2.x 中经典的 &lt;transition&gt; 写法，开发者可以通过 &lt;transition&gt; 轻松定义一个界面在两种状态中的过渡方式。 注意事项#Vue.js 最初是为 Web 设计的，虽然可以基于 Weex 开发移动应用，但是 Web 开发和原生开发毕竟不同，在功能和开发体验上都有一些差异，这些差异从本质上讲是原生开发平台和 Web 平台之间的差异，Weex 正在努力缩小这个差异的范围。 参考文章《Vue 2.x 在 Weex 和 Web 中的差异》了解存在差异的原因和细节。 使用其他 Vue 的工具库#Vue.js 也有较多周边技术产品，如 Vuex 和 vue-router 等，这些库也可以在 Weex 中很好的工作。 关于 Vuex 和 vue-router 的使用方法，可以参考《在 Weex 项目中使用 Vuex 和 vue-router》。 我们基于 Weex 和 Vue 开发了一个的完整项目 weex-hackernews ，引入了包含 Vue 2.x 的 WeexSDK，创建了三端的项目和基本的编译配置。在项目中使用了 Vuex 和 vue-router ，能够实现同一份代码，在 iOS、Android、Web 下都能完整地工作。","type":"guide"},{"title":"Android APIs","path":"cn/references/android-apis.html","permalink":"https://weex.apache.org/cn/references/android-apis.html","text":"Android APIs#Weex 初步接入请参考：https://github.com/weexteam/article/issues/25 WXSDKEngine 是 Weex 对外的总入口。#主要提供了一下功能： 设置相关 Adapter 和获取 adapter。 注册自定义 module 和 component 重置 JSFramework Adapter 介绍#Weex 为了重用 Native 通用库提供了对应的接口进行设置。 IWXImgLoaderAdapter 图片适配器。 Weex 会把需要设置图片的 View 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。 Weex 没有提供图片默认实现。 接口定义如下： public interface IWXImgLoaderAdapter &#123; void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy);&#125; WXImageQuality 表示图片的质量，WXImageQuality 取如下值 LOW, NORMAL, HIGH, ORIGINAL 图片质量依次变高。默认为 LOW。WXImageStrategy 为扩展类，表示了图片是否可以裁剪 (isClipping) 锐化 (isSharpen) 占位符 (placeHolder) 等。 IWXHttpAdapter 网络下载适配器。 Weex 自定义了 WXRequest 和 OnHttpListener，Native 重载接口后可以从 Request 中获取URL，Header 等参数，网络请求完成后可以通过 OnHttpListener 进行回调通知。Weex 提供了默认网络请求：DefaultWXHttpAdapter， 使用的是 HttpURLConnection 进行网络请求。 接口定义如下： public interface IWXHttpAdapter &#123; void sendRequest(WXRequest request, OnHttpListener listener);&#125; WXRequest 定义了网络请求相关的参数，请求方法，请求主体，超时时间。Weex默认超时时间是3000. OnHttpListener 定义了网络请求结束后对应方法。定义如下： interface OnHttpListener &#123; /** * start request */ void onHttpStart(); /** * headers received */ void onHeadersReceived(int statusCode,Map&lt;String,List&lt;String&gt;&gt; headers); /** * post progress * @param uploadProgress */ void onHttpUploadProgress(int uploadProgress); /** * response loaded length (bytes), full length should read from headers (content-length) * @param loadedLength */ void onHttpResponseProgress(int loadedLength); /** * http response finish * @param response */ void onHttpFinish(WXResponse response);&#125; IWXUserTrackAdapter Weex 相关性能数据 (首屏加载时间、JS-Native 通信时间、dom 更新时间等) 和其他通用信息 (JSLib 文件大小, Weex SDK 版本号等)。 接口定义： public interface IWXUserTrackAdapter &#123; void commit(Context context, String eventId, String type, WXPerformance perf, Map&lt;String, Serializable&gt; params);&#125; Native 实现接口后可以通过 WXPerformance 和 params 获取对应的信息。WXPerformane 对应字段表示含义请参考文档：https://github.com/weexteam/article/issues/124 后续随着开发 Weex 还会定义更多的 Adapter，此文档也会定时更新。 Native 和 JS 通信# 自定义事件通知 多用于某个自定义控件进行事件通知，例如自定义点击事件，响应下拉事件等。 WXSDKInstance.java public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data,final Map&lt;String, Object&gt; domChanges)&#123; &#125;public void fireEvent(String elementRef,final String type, final Map&lt;String, Object&gt; data)&#123; fireEvent(elementRef,type,data,null);&#125;public void fireEvent(String elementRef, String type)&#123; fireEvent(ref,type,new HashMap&lt;String, Object&gt;());&#125; elementRef：事件发生的控件 ID。 type: 自定义事件，Weex 默认以 onXxxxx 开头为自定义事件。onPullDown (下拉事件)。 data: 需要透出的参数，例如当前控件的大小，坐标等其他信息。 domChanges：更新 ref 对应控件的 Attribute 和 Style。 事件回调 多用于 Module 回调，例如定位 Module 完成后需要通知 JS。使用方法如下： public class WXLocation extends WXModule &#123; @JSMethod public void getLocation(JSCallback callback)&#123; //获取定位代码..... Map&lt;String,String&gt; data=new HashMap&lt;&gt;(); data.put(\"x\",\"x\"); data.put(\"y\",\"y\"); //通知一次 callback.invoke(data); //持续通知 callback.invokeAndKeepAlive(data); //invoke方法和invokeAndKeepAlive两个方法二选一 &#125;&#125; 注册滑动事件#Weex 获取滑动事件可以通过 WXSDKInstance 注册 registerOnWXScrollListener 监听 接口定义如下： public interface OnWXScrollListener &#123; /** * The view is not currently scrolling. */ int IDLE = RecyclerView.SCROLL_STATE_IDLE; /** * The view is currently being dragged by outside input such as user touch input. */ int DRAGGING = RecyclerView.SCROLL_STATE_DRAGGING; /** * The view is currently animating to a final position while not under * outside control. */ int SETTLING = RecyclerView.SCROLL_STATE_SETTLING; /** * Callback method to be invoked when the view has been scrolled. This will be * called after the scroll has completed. * &lt;p&gt; * This callback will also be called if visible item range changes after a layout * calculation. In that case, dx and dy will be 0. * */ void onScrolled(View view, int x, int y); /** * Callback method to be invoked when view's scroll state changes. * */ void onScrollStateChanged(View view, int x, int y, int newState);&#125; 自定义NavBar#Weex 提供了 WXNavigatorModule 进行导航控制，对应的方法可以通过设置 IActivityNavBarSetter 接口进行定制。 使用方法: WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter()&#123;&#125;); 其他介绍#动态适配容器#因为 Android 手机的碎片化导致屏幕适配很困难。Weex 对外提供的接口 render 需要动态传入容器的宽高，但是传入的宽高有时会发生变化，例如 ActionBar 隐藏等，这是传入的 Weex 容器也要进行对应的变化。为了适应这种变化，Weex 提供了接口 WXSDKInstance.setSize(int width, int height) 来改变容器的大小。 /** * * @param width 容器宽度 * @param height 容器高度 */ public void setSize(int width, int height)&#123;&#125;; 降级使用#Weex 处于发展阶段会增加一些新的特性和功能，但是这些新的特性和功能都必须升级 SDK 才能实现，对于没有升级的应用应该怎么处理呢？可以使用降级功能。 所谓降级功能就是 Weex 无法运行的版本或者手机，可以用 Weex h5 来代替。 Native 端可以通过接口 IWXRenderListener 中的 onException 方法进行处理，如果是主动降级 errCode 是以“|”分割的字符。“|”前面的字符为1表示主动降级，Native 端可以跳转到对应的 H5 页面。或者用其他的方式提示用户当前环境不支持 Weex。","type":"references"},{"title":"iOS APIs","path":"cn/references/ios-apis.html","permalink":"https://weex.apache.org/cn/references/ios-apis.html","text":"iOS APIs#Native 对外接口# 注册 SDK 默认的 Module、Handler 和 Component 注册自定义 module、Handler 和 Component 重置 JSFramework Handler (对应于 Android 的 Adapter) 介绍# WXImgLoaderDefaultImpl 图片下载 handler。Weex 会把需要设置图片的 View 和 URL 透露出来，Native 端需要实现这个接口进行图片下载。WeexSDK kernel 本身没有提供图片下载的默认实现。 接口定义如下： @protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * * @param imageUrl The URL of the image to download * * @param imageFrame The frame of the image you want to set * * @param options : The options to be used for this download * * @param completedBlock : A block called once the download is completed. * image : the image which has been download to local. * error : the error which has happened in download. * finished : a Boolean value indicating whether download action has finished. */- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end Native 和 JS 通信# 自定义通知事件 用于 native 自定义部分和 js 进行实践通知，比如传递下拉事件到 js，这个是在 component 基类的方法，可以直接使用 /** * @abstract Fire an event to the component and tell Javascript which value has been changed. * @param eventName 事件名称，可以在weex文件某个标签组件监听，命名规范为 onXXX * @param params 数据 * @param domChanges 发生改变的数据 **/- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges 事件回调 多用于 Module 回调结果给 js，回调类型分为下面两种： WXModuleCallback 为了性能考虑，该回调只能回调通知js一次，之后会被释放，多用于一次结果 WXModuleKeepAliveCallback 该回调可以设置是否为多次回调类型，多次回调的场景如持续监听位置的变化，并返回给 js。 @implementation WXEchoModule@synthesize weexInstance; // 让该module 获得当前instanceWX_EXPORT_METHOD(@selector(echo:))- (void)echo:(NSString *)param callback:(WXModuleKeepAliveCallback)callback&#123; callback(param,ture);// 此处设置true，该回调function 可以多次回调执行，可以写循环测试.&#125; 动态适配容器#WeexSDK 在 WXSDKInstance 类中提供了方法 setFrame(CGRect) 来改变容器的大小。 如：在导航栏从有到无过程，需要 weexView 的变化， 可以在此时 native 调用该方法设置 降级使用#Weex 处于发展阶段会增加一些新的特性和功能，但是这些新的特性和功能都必须升级 SDK 才能实现，对于没有升级的应用应该怎么处理呢？可以使用降级功能。 所谓降级功能就是 Weex 无法运行的版本或者手机，可以用 Weex h5 来代替。 Native 端可以通过接口 WXSDKInstance 中的 onFailed 回调进行处理，如果是主动降级则返回的错误 domain 为 TemplateErrorType，Native 端可以跳转到对应的 H5 页面，或者用其他的方式提示用户当前环境不支持 Weex。","type":"references"},{"title":"JS Service","path":"cn/references/js-service.html","permalink":"https://weex.apache.org/cn/references/js-service.html","text":"JS Service#v0.9.5+ JS service 和 Weex 实例在 JS runtime 中并行运行。Weex 实例的生命周期可调用 JS service 生命周期。目前提供创建、刷新、销毁生命周期。 重要提醒: JS Service 非常强大但也很危险，请小心使用！ 注册 JS Service#iOS#[WeexSDKEngine registerService:@&quot;SERVICE_NAME&quot; withScript: @&quot;SERVICE_JS_CODE&quot; withOptions: @&#123;&#125;]; Android#HashMap&lt;String, String&gt; options = new HashMap&lt;&gt;()options.put(\"k1\", \"v1\")String SERVICE_NAME = \"SERVICE_NAME\"String SERVICE_JS_CODE = \"SERVICE_JS_CODE\"boolean result = WXSDKEngine.registerService(SERVICE_NAME, SERVICE_JS_CODE, options) Web#&lt;!-- 必须在 JSFM 之后加载 --&gt;&lt;script src=\"SERVICE_JS_CODE_URL\"&gt;&lt;/script&gt; 编写一个 JS service#// options: native inject options// options.serviceName is native options nameservice.register(options.serviceName, &#123; /** * JS Service lifecycle. JS Service `create` will before then each instance lifecycle `create`. The return param `instance` is Weex protected param. This object will return to instance global. Other params will in the `services` at instance. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ create: function(id, env, config) &#123; return &#123; instance: &#123; InstanceService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125;, NormalService: function(weex) &#123; var modal = weex.requireModule('modal') return &#123; toast: function(title) &#123; modal.toast(&#123; message: title &#125;) &#125; &#125; &#125; &#125; &#125;, /** * JS Service lifecycle. JS Service `refresh` will before then each instance lifecycle `refresh`. If you want to reset variable or something on instance refresh. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment */ refresh: function(id, env, config)&#123; &#125;, /** * JS Service lifecycle. JS Service `destroy` will before then each instance lifecycle `destroy`. You can deleted variable here. If you doesn't detete variable define in JS Service. The variable will always in the js runtime. It's would be memory leak risk. * * @param &#123;String&#125; id instance id * @param &#123;Object&#125; env device environment * @return &#123;Object&#125; */ destroy: function(id, env) &#123; &#125;&#125;) Using JS Service (vuejs)#&lt;script&gt;var _InstanceService = new InstanceService(weex)var _NormalService = new service.normalService(weex)module.exports = &#123; created: fucntion() &#123; // called modal module to toast something _InstanceService.toast('Instance JS Service') _NormalService.toast('Normal JS Service') &#125;&#125;&lt;/script&gt;","type":"references"},{"title":"JS Framework APIs","path":"cn/references/js-framework-apis.html","permalink":"https://weex.apache.org/cn/references/js-framework-apis.html","text":"JS Framework APIs#BroadcastChannel v0.9+#BroadcastChannel API 是 Weex 实例间通信的解决方案。 参考# BroadcastChannel specification. MessageEvent specification API# postMessage(message): 通过消息通道发送特定消息给其他 BroadcastChannel 对象。 close: 关闭 BroadcastChannel 对象，以便垃圾回收。 onmessage: Event 处理函数, 当 BroadcastChannel 对象接收到消息时触发。 使用#const Stack = new BroadcastChannel('Avengers')Stack.onmessage = function (event) &#123; console.log(event.data) // in this case, it's \"Hulk Smash !!!\"&#125;// in another instanceconst Hulk = new BroadcastChannel('Avengers')Hulk.postMessage(\"Hulk Smash !!!\") 运行以上代码，Stack 可以从 Hulk 接收消息。 注意#需要注意的是: message 如果是一个对象，该对象不会深拷贝。 参考以下例子 const a = new BroadcastChannel('app')const b = new BroadcastChannel('app')const message = &#123; lists: ['A', 'B']&#125;a.onmessage = function (event) &#123; // in this case, event.data is a reference of message console.assert(event.data === message)&#125;b.postMessage(message) 在这个例子中，event.data 全等于 message。 与深拷贝相比，这种方式能够提高效率并减少内存消耗。但是，不建议开发者在使用时缓存或修改事件对象 (所有类型的事件处理程序都应该有此限制)。","type":"references"},{"title":"Weex 实例变量","path":"cn/references/weex-variable.html","permalink":"https://weex.apache.org/cn/references/weex-variable.html","text":"Weex 实例变量#每个 Weex 页面的 JS 上下文中都有一个相互独立的 weex 变量，用来持有当前 Weex 页面相关的单例内容或方法。 weex.config#该变量包含了当前 Weex 页面的所有环境信息，包括不仅限于： bundleUrl: string: JS bundle 的 URL。 env: Object: 环境对象。 weexVersion: string: Weex sdk 版本。 appName: string: 应用名字。 appVersion: string: 应用版本。 platform: string: 平台信息，是 iOS、Android 还是 Web。 osName: string: iOS或者android，表示操作系统的名称. osVersion: string: 系统版本。 deviceModel: string: 设备型号 (仅原生应用)。 deviceWidth: number: 设备宽度。Weex 默认以宽度为 750px 做适配渲染，要获得750px下的屏幕高度，可以通过 height = 750/deviceWidth*deviceHeight 公式获得，可以使用到 CSS 中，用来设置全屏尺寸 deviceHeight: number: 设备高度。 weex.requireModule(module: string): Object#获取某个 native module 的所有方法，比如： &lt;template&gt; &lt;div&gt;&lt;text&gt;Hello World&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; var modal = weex.requireModule('modal') modal.toast(&#123; message: 'I am a toast.', duration: 3 &#125;)&lt;/script&gt; weex.document: Document#返回当前 Weex 页面的文档对象。 weex.supports#v0.15+ weex.supports 可以用来检测当前环境中是否支持某个特性。 目前仅在 Weex DSL 2.0 (.vue) 中支持。 API#weex.supports(condition : String) : Boolean | Null 参数# 特定格式的字符串：@{type}/{name}。 type 必须是 “component” 或者 “module”。name 可以是标签名、模块名，也可以指定模块中的某个方法名（和模块名用 . 隔开）。 返回值# 支持，则返回 true。 不支持，则返回 false。 参数格式错误或无法确定是否支持，则返回 null。 例子#// 检测是否支持某个组件weex.supports('@component/slider') // trueweex.supports('@component/my-tab') // false// 检测是否支持某个模块weex.supports('@module/stream') // trueweex.supports('@module/abcdef') // false// 检测是否支持模块中的某个方法weex.supports('@module/dom.getComponentRect') // trueweex.supports('@module/navigator.jumpToPage') // false// 无效的输入weex.supports('div') // nullweex.supports('module/*') // nullweex.supports('@stream/fetch') // nullweex.supports('getComponentRect') // null","type":"references"},{"title":"Weex语法支持插件","path":"cn/tools/helpers.html","permalink":"https://weex.apache.org/cn/tools/helpers.html","text":"Weex语法支持插件#Weex Language Support 插件是官方提供的一个工具，你可以使用它在IntelliJ IDEA，WebStorm等一系列IDE上对Weex DSL进行语法高亮，自动补全和错误检查等操作。 支持的IDE#你可以在任何操作系统上的下列IDE上安装和使用Weex Language Support插件：IntelliJ IDEA Ultimate, PhpStorm, WebStorm, PyCharm, RubyMine, AppCode, CLion, Gogland, Rider 安装#在IDE的插件仓库中搜索Weex Language Support来安装该插件，安装完毕后重启IDE即可激活插件相关功能 配置#打开Preferences -&gt; Other Settings -&gt; Weex language support可配置插件的相关功能 Target Weex Version: 配置插件以哪一个版本的语法规则来对DSL进行提示及检查，默认值LATEST表示总是应用最行\b\b新版本weex的语法规则 Vue Support: 配置插件是否支持Weex 2.0版本的DSL(.vue文件)，开启后重启生效（注意：如果IDE内有其他支持Vue语法的插件，则需要关闭相应的插件后Weex插件才能生效） Custom Rules: 引入自定义的Weex DSL规则，如果你在native中定义了自己的Module或Component，可通过自定义规则引入插件中来提供相应的提示和补全支持，自定义规则的\b格式将在后文列出 Global Weex Components: 默认地，插件会解析当前工程及npm root路径下的node_modules\b目录，解析其中包含的Weex Components并对其提供补全支持。如果你的项目中引用了这两个路径以外的Components，可以在此处将其添加到搜索路径中，\b插件将会将其中的Components载入，并在编写DSL时为相应的标签提供补全支持 自定义规则格式#自定义规则包含在一个json文件中，json文件的根节点为数组类型，数组中的每一个元素对应DSL中的一个标签。我们以&lt;loading&gt;标签的规则来举例：&#123; \"tag\": \"loading\", //标签名，不可为空 \"attrs\": [ //标签属性列表，可为空 &#123; \"name\": \"display\", //属性名，不可为空 \"valuePattern\": null, //属性值的正则表达式，用于检测\b值是否合法，可为空 \"valueEnum\": [ //属性值枚举，可为空 \"show\", \"hide\" ], \"valueType\": \"var\", //属性值类型，必须是var或function，决定该从数据列表还是函数列表中查找属性值补全的候选值，不可为空 \"since\": 0, //该属性何时被添加到sdk中，例如0.11，\b默认为0 \"weexOnly\": false //该属性是否仅在1.0语法中可用，默认为false &#125; ], \"events\": [ //事件列表。可为空 &#123; \"name\": \"loading\", //事件名称，不可为空 \"since\": 0 //该事件何时被添加到sdk中 &#125; ], \"parents\": [ //该标签允许被作为哪些标签的子元素，空表示可以作为任意元素的子元素 \"list\", \"scroller\" ], \"childes\": [ //该标签允许哪些元素作为自己的子元素，空表示任意元素都可作为子元素 \"text\", \"image\", \"loading-indicator\" ], \"document\": \"/references/components/loading.html\" //文档地址，配置该属性之后可在编辑界面中对应的标签上直接打开文档 &#125; 使用#插件的绝大部分功能\b被集成到编辑器上下文中，会随用户输入在需要补全，提示或Lint时被触发，无需特殊干预。下列功能需要用户手动触发： 文档搜索#打开IDE右侧工具栏的Weex Documents即可对文档进行搜索，搜索结果与官网保持同步，勾选 EN 可切换搜索结果为英文内容 打开标签对应的文档#\b将光标定位到标签上，并通过Show Intention Actions操作（OSX上默认键为 option + enter，可通过Keymap查看）打开Intenion菜单，\b选择Open Document可打开标签对应的文档 参与插件建设#请将Issues及Pull Requests提交到weex-language-support项目中","type":"tools"},{"title":"Weex Market","path":"cn/tools/market.html","permalink":"https://weex.apache.org/cn/tools/market.html","text":"","type":"tools"},{"title":"使用 weex-toolkit","path":"cn/tools/toolkit.html","permalink":"https://weex.apache.org/cn/tools/toolkit.html","text":"weex-toolkit#weex-toolkit 是官方提供的一个脚手架命令行工具，你可以使用它进行 Weex 项目的创建，调试以及打包等功能。 安装#使用 npm 安装: $ npm install -g weex-toolkit 安装成功后，你输入 weex 应该可以看到下面的提示效果； 如果你本地没有安装 node.js 你可以前往官网下载安装。 *请确保你的 node 版本是&gt;=6，你可以使用 n 来进行 node 的版本管理。 中国用户如果npm遭遇网络问题，可以使用淘宝的 cnpm 镜像： $ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm install -g weex-toolkit 如果你安装的过程中遇到了问题，比如 permission error 你可以去 weex-toolkit issues 找到解决方法。 初始化 weex 项目#$ weex init awesome-project 执行完命令后，在 awesome-project 目录中就创建了一个使用 Weex 和 Vue 的模板项目。 然后我们进入项目所在路径，weex-toolkit 已经为我们生成了标准项目结构。 在 package.json 中，已经配置好了几个常用的 npm script，分别是： build: 源码打包，生成 JS Bundle dev: webpack watch 模式，方便开发 serve: 开启静态服务器 debug: 调试模式 我们先通过 npm install 安装项目依赖。之后运行根目录下的 npm run dev &amp; npm run serve 开启 watch 模式和静态服务器。 然后我们打开浏览器，进入 http://localhost:8080/index.html 即可看到 Weex h5 页面。 实时预览#weex-toolkit 支持预览你当前开发的weex页面(.we或者.vue)，你只需要指定预览的文件路径即可： $ weex src/foo.vue 浏览器会自动弹出页面，这个时候你可以看到你所编辑的 Weex页面的具体效果和页面布局。如果你使用 Playground 扫描右边的二维码，就能够看到 Weex 在 Android/IOS 设备上的效果了。 如果你需要预览整个项目目录，你可以输入这样的命令: $ weex src --entry src/foo.vue 你需要在传入的参数指定预览的目录和入口文件。 打包weex项目#如果开发完成后，你可以使用 weex compile 通过命令行工具进行单个文件或者整个项目的打包。 weex compile src/foo.vue dist 命令行需要两个参数，你的源码文件或者目录， 以及你生成打包后的目录地址。 调试 Weex 页面#weex-toolkit支持调试工具。weex devtools ，它是专门为Weex定制的一款实现了 Chrome Debugging Protocol 的 inspect/debug 工具，能够帮助你快速查看 app 运行状态和调试 Weex 中的 JS 代码，当前支持 IOS 和 Android 两个平台。 用法#weex debug [options] [we_file|bundles_dir] 选项: -h, --help 显示帮助-V, --verbose 显示 debug 服务器运行时的各种 log-v, --version 显示版本-p, --port [port] 设置 debug 服务器端口号 默认为8088-e, --entry [entry] debug 一个目录时,这个参数指定整个目录的入口 bundle 文件,这个 bundle 文件的地址会显示在 debug 主页上(作为二维码)-m, --mode [mode] 设置构建 we 文件的方式，transformer 最基础的风格适合单文件， loader:webpack 风格 适合模块化的多文件 . 默认为 transformer 开启调试#$ weex debug 单纯启动一个调试服务器，并同时唤起Chrome浏览器打开调试主页。这个调试主页上会有一个二维码，使用 Playground App 扫这个二维码可以开启 Playground 调试。开启调试后,设备列表中会出现您的设备，根据提示进行后续的调试操作。 调试 .we | .vue 文件#$ weex debug your_weex.vue 这个命令会将 your_weex.vue 编译成 JS Bundle 文件 部署到 debug 服务器；并启动debug服务器如上述命令那样打开的调试vue主页会多显示一个二维码，使用 Playground App扫这个二维码码可以加载 your_weex.we (注意要先扫描开启调试的那个二维码码)。这个命令会自动检测 your_weex.we 文件变动，如果发现内容被修改则立即重新编译部署，并刷新 debugger 页面。. 调试整个bundle/we文件夹#同样你也可以调试整个目录的文件，你只需要传入目录的路径和入口文件即可； $weex debug your/we/path -e index.we 这个命令会编译你指定目录下的所有的 .we 文件,并把编译好的 JS Bundle 部署到 debug 服务器,他们的地址会映射到 http://lcoalhost:8088/weex/ 下比如 your/we/path/index.we 可以通过 http://lcoalhost:8088/weex/index.js 访问。your/we/path/demo/test.we 可以通过 http://lcoalhost:8088/weex/demo/index.js 。 -e 参数可以指定一个入口的 .we 文件，这个文件的地址会显示在调试主页上(作为二维码)。 特性#连接设备# Inspector# Inspector 能够用来查看 Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View 等。 Element# NetWork#查看网络请求的总耗时和延时# 查看网络请求的header和response# 控制台# 资源# Debugger# 调试器用来调试 Weex 中的 JS 代码，能够设置断点、查看调用栈。 Breakpoint and CallStack# 集成devtools# Android 请参考文档 Weex devtools (Android)，其中有详细说明。 IOS 请参考文档 Weex devtools (iOS)， 其中有详细说明。 weex-toolkit 对 weexpack 的水平扩展#weexpack 是基于 Weex 快速搭建应用原型的利器。它能够帮助开发者通过命令行创建 Weex 工程，添加相应平台的 Weex app 模版，并基于模版从本地，GitHub 或者 Weex 应用市场安装插件，快速打包 Weex 应用并安装到手机运行，对于具有分享精神的开发者而言还能够创建 Weex 插件模版并发布插件到 Weex 应用市场。 现在使用 weex-toolkit 同样支持对 weexpack 的命令调用,如果你当前的项目与 weexpack 生成的项目目录一致，那么你可以直接实现对于 platform 的操作，从而构建具体的 Android/IOS app 。 weex platform 以及 run 命令#如果我们希望在模拟器或者真机上查看 Weex 运行的效果，我们可以使用 platform 添加或者删除 Weex 应用模板。 $ weex platform add ios 在第一次使用 platform/plugin 命令的时候，可能会遇到下面的界面，你只需要输入 Y 或者直接 enter 键即可。 添加ios平台，然后这个时候只要输入: $ weex run ios 就能看到启动的模拟器运行的效果了。 weex plugin 命令#如果你想使用插件市场的插件，你可以使用： $ weex plugin add plugin_name 你只需要输入插件的名称就可以从远程添加插件到你本地的项目，比如添加 weex-chart，我们可以输入命令： $ weex plugin add weex-chart 我们可以使用plugin remove移除插件，比如移除安装好的 weex-cahrt： $ weex plugin remove weex-chart 关于 weexpack 更加详细的介绍，你可以阅读 官方文档。","type":"tools"},{"title":"通用事件","path":"cn/wiki/common-events.html","permalink":"https://weex.apache.org/cn/wiki/common-events.html","text":"通用事件#Weex 提供了通过事件触发动作的能力，例如在用户点击组件时执行 JavaScript。下面列出了可被添加到 Weex 组件上以定义事件动作的属性： click#当组件上发生点击手势时被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象# type: click target: 触发点击事件的目标组件 timestamp: 触发点击事件时的时间戳 longpress#如果一个组件被绑定了 longpress 事件，那么当用户长按这个组件时，该事件将会被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象# type : longpress target : 触发长按事件的目标组件 timestamp : 长按事件触发时的时间戳 Appear 事件#如果一个位于某个可滚动区域内的组件被绑定了 appear 事件，那么当这个组件的状态变为在屏幕上可见时，该事件将被触发。 事件对象# type : appear target : 触发 Appear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down Disappear 事件#如果一个位于某个可滚动区域内的组件被绑定了 disappear 事件，那么当这个组件被滑出屏幕变为不可见状态时，该事件将被触发。 事件对象# type : disappear target : 触发 Disappear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down Page 事件#注意：仅支持 iOS 和 Android，H5 暂不支持。 Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力。 viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。 与组件的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。 特殊情况下，这两个事件也能被绑定到非根元素的body组件上，例如wxc-navpage组件。 事件对象# type : viewappear 或 viewdisappear target : 触发事件的组件对象 timestamp : 事件被触发时的时间戳 示例#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\" @click=\"onclick\" @longpress=\"onlongpress\" @appear=\"onappear\" @disappear=\"ondisappear\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; onclick (event) &#123; console.log('onclick:', event) modal.toast(&#123; message: 'onclick', duration: 0.8 &#125;) &#125;, onlongpress (event) &#123; console.log('onlongpress:', event) modal.toast(&#123; message: 'onlongpress', duration: 0.8 &#125;) &#125;, onappear (event) &#123; console.log('onappear:', event) modal.toast(&#123; message: 'onappear', duration: 0.8 &#125;) &#125;, ondisappear (event) &#123; console.log('ondisappear:', event) modal.toast(&#123; message: 'ondisappear', duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt;","type":"wiki"},{"title":"颜色名称列表","path":"cn/wiki/color-names.html","permalink":"https://weex.apache.org/cn/wiki/color-names.html","text":"Weex 支持的所有颜色名称#基础颜色关键词:# 颜色名 十六进制RGB值 black(黑) #000000 silver(银) #C0C0C0 gray(灰) #808080 white(白) #FFFFFF maroon(褐紫红) #800000 red(红) #FF0000 purple(紫) #800080 fuchsia(晚樱) #FF00FF green(绿) #008000 lime(石灰) #00FF00 olive(橄榄) #808000 yellow(黄) #FFFF00 navy(海军蓝) #000080 blue(蓝) #0000FF teal(水鸭) #008080 aqua(水蓝) #00FFFF 扩展颜色关键词:# 颜色名 十六进制RGB值 aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"wiki"},{"title":"CSS 单位","path":"cn/wiki/css-units.html","permalink":"https://weex.apache.org/cn/wiki/css-units.html","text":"CSS 单位#CSS color 单位#支持以下写法： .classA &#123; /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray;&#125; 注意# 不支持 hsl(), hsla(), currentColor, 8个字符的十六进制颜色。 rgb(a,b,c) 或 rgba(a,b,c,d) 的性能比其他颜色格式差很多，请选择合适的颜色格式。 颜色名称可查看 颜色名称列表. CSS length 单位#在 Weex 中，我们只支持 px 长度单位。并且它将在 JavaScript 运行时和本机渲染器中解析为数字类型。 下面这些不同的写法，解析的结果完全相同。 .classA &#123; font-size: 48px; line-height: 64px; &#125; 不支持类似 em，rem，pt 这样的 CSS 标准中的其他长度单位。 CSS number 单位#仅仅一个数字。用于 opacity，lines等。 有时值必须是整数，例如：lines。 CSS percentage 单位 (暂不支持)#表示百分比值，如“50％”，“66.7％”等。 它是 CSS 标准的一部分，但 Weex 暂不支持。","type":"wiki"},{"title":"通用样式","path":"cn/wiki/common-styles.html","permalink":"https://weex.apache.org/cn/wiki/common-styles.html","text":"通用样式#所有 Weex 组件都支持以下通用样式规则。 盒模型# Weex 盒模型基于 CSS 盒模型，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 注意：Weex 对于长度值目前只支持像素值，不支持相对单位（em、rem）。 width {length}：，默认值 0 height {length}：，默认值 0 padding {length}：内边距，内容和边框之间的距离。默认值 0 可有如下写法： padding-left {length}：，默认值 0 padding-right {length}：，默认值 0 padding-top {length}：，默认值 0 padding-bottom {length}：，默认值 0 margin： 外边距，元素和元素之间的空白距离。值类型为 length，默认值 0 可有如下写法： margin-left {length}：，默认值 0 margin-right {length}：，默认值 0 margin-top {length}：，默认值 0 margin-bottom {length}：，默认值 0 border： 设定边框，border 目前不支持类似这样 border: 1 solid #ff0000; 的组合写法。 可有如下写法： border-style： 设定边框样式，值类型为 string，可选值为 solid | dashed | dotted，默认值 solid 可有如下写法： border-left-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-top-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-right-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-bottom-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-width {length}： 设定边框宽度，非负值, 默认值 0 可有如下写法： border-left-width {length}：，非负值, 默认值 0 border-top-width {length}：，非负值, 默认值 0 border-right-width {length}：，非负值, 默认值 0 border-bottom-width {length}：，非负值, 默认值 0 border-color {color}： 设定边框颜色，默认值 #000000 可有如下写法： border-left-color {color}：，默认值 #000000 border-top-color {color}：，默认值 #000000 border-right-color {color}：，默认值 #000000 border-bottom-color {color}：，默认值 #000000 border-radius {length}： 设定圆角，默认值 0 可有如下写法： border-bottom-left-radius {length}：，非负值, 默认值 0 border-bottom-right-radius {length}：，非负值, 默认值 0 border-top-left-radius {length}：，非负值, 默认值 0 border-top-right-radius {length}：，非负值, 默认值 0 注意：#Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 目前在 &lt;image&gt; 组件上尚无法只定义一个或几个角的 border-radius。比如你无法在这两个组件上使用 border-top-left-radius。该约束只对 iOS 生效，Android 并不受此限制。 尽管 overflow:hidden 在 Android 上是默认行为，但只有下列条件都满足时，一个父 view 才会去 clip 它的子 view。这个限制只对 Android 生效，iOS 不受影响。 父view是div, a, cell, refresh 或 loading。 系统版本是 Android 4.3 或更高。 系统版本不是 Andorid 7.0。 父 view 没有 background-image 属性或系统版本是 Android 5.0 或更高。 示例：#&lt;template&gt; &lt;div&gt; &lt;image style=\"width: 400px; height: 200px; margin-left: 20px;\" src=\"https://g.alicdn.com/mtb/lab-zikuan/0.0.18/weex/weex_logo_blue@3x.png\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; Flexbox#Weex 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 Flexbox 包含 flex 容器和 flex 成员项。如果一个 Weex 元素可以容纳其他元素，那么它就成为 flex 容器。需要注意的是，flexbox 的老版规范相较新版有些出入，比如是否能支持 wrapping。这些都描述在 W3C 的工作草案中了，你需要注意下新老版本之间的不同。另外，老版本只在安卓 4.4 版以下得到支持。 Flex 容器#在 Weex 中，Flexbox 是默认且唯一的布局模型，所以你不需要手动为元素添加 display: flex; 属性。 flex-direction： 定义了 flex 容器中 flex 成员项的排列方向。可选值为 row | column，默认值为 column column：从上到下排列。 row：从左到右排列。 justify-content： 定义了 flex 容器中 flex 成员项在主轴方向上如何排列以处理空白部分。可选值为 flex-start | flex-end | center | space-between，默认值为 flex-start。 flex-start：是默认值，所有的 flex 成员项都排列在容器的前部； flex-end：则意味着成员项排列在容器的后部； center：即中间对齐，成员项排列在容器中间、两边留白； space-between：表示两端对齐，空白均匀地填充到 flex 成员项之间。 align-items： 定义了 flex 容器中 flex 成员项在纵轴方向上如何排列以处理空白部分。可选值为 stretch | flex-start | center | flex-end，默认值为 stretch。 stretch 是默认值，即拉伸高度至 flex 容器的大小； flex-start 则是上对齐，所有的成员项排列在容器顶部； flex-end 是下对齐，所有的成员项排列在容器底部； center 是中间对齐，所有成员项都垂直地居中显示。 Flex 成员项#flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的2倍。 flex {number}：值为 number 类型。 示例#一个简单的网格布局。 &lt;template&gt; &lt;div&gt; &lt;div v-for=\"(v, i) in list\" class=\"row\"&gt; &lt;div v-for=\"(text, k) in v\" class=\"item\"&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .item&#123; flex:1; justify-content: center; align-items:center; border-width:1; &#125; .row&#123; flex-direction: row; height:80px; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; list:[ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ] &#125; &#125; &#125;&lt;/script&gt; 一个在相对于屏幕水平居中，全屏居中的 &lt;div&gt;。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; justify-content: center; align-items: center; &#125; .box &#123; width: 200px; height: 200px; background-color: #fc0000; &#125;&lt;/style&gt; 定位#Weex 支持 position 定位，用法与 CSS position 类似。为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标。 position {string}： 设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。 relative 是默认值，指的是相对定位； absolute 是绝对定位，以元素的容器作为参考系； fixed 保证元素在页面窗口中的对应位置显示； sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。 top {number}：距离上方的偏移量，默认为 0。 bottom {number}：距离下方的偏移量，默认为 0。 left {number}：距离左方的偏移量，默认为 0。 right {number}：距离右方的偏移量，默认为 0。 注意： Weex 目前不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。 如果定位元素超过容器边界，在 Android 下，超出部分将不可见，原因在于 Android 端元素 overflow 默认值为 hidden，但目前 Android 暂不支持设置 overflow: visible。 示例# &lt;template scoped&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box box1\"&gt; &lt;/div&gt; &lt;div class=\"box box2\"&gt; &lt;/div&gt; &lt;div class=\"box box3\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; &#125; .box &#123; width: 400px; height: 400px; position: absolute; &#125; .box1 &#123; top: 0; left: 0; background-color: #ff0000; &#125; .box2 &#123; top: 150px; left: 150px; background-color: #0055dd; &#125; .box3 &#123; top: 300px; left: 300px; background-color: #00ff49; &#125;&lt;/style&gt; transform#transform 属性向元素应用 2D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 目前支持的 transform 声明格式: translate( [, ]?) translateX( ) translateY( ) scale( ) scaleX( ) scaleY( ) rotate( ) rotateX( ) v0.14+ rotateY( ) v0.14+ perspective( ) Android 4.1及以上版本支持 v0.16+ transform-origin: number/percentage/keyword(top/left/right/bottom) 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"transform\"&gt; &lt;text class=\"title\"&gt;Transformed element&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .transform &#123; align-items: center; transform: translate(150px,200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px; &#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt; transition v0.16.0+#现在您可以在CSS中使用transition属性来提升您应用的交互性与视觉感受，transition中包括布局动画，即LayoutAnimation，现在布局产生变化的同时也能使用transition带来的流畅动画。transition允许CSS的属性值在一定的时间区间内平滑地过渡。 参数# transition-property:允许过渡动画的属性名，设置不同样式transition效果的键值对，默认值为空，表示不执行任何transition，下表列出了所有合法的参数属性： 参数名 描述 width transition过渡执行的时候是否组件的宽度参与动画 height transition过渡执行的时候是否组件的高度参与动画 top transition过渡执行的时候是否组件的顶部距离参与动画 bottom transition过渡执行的时候是否组件的底部距离参与动画 left transition过渡执行的时候是否组件的左侧距离参与动画 right transition过渡执行的时候是否组件的右侧距离参与动画 backgroundColor transition过渡执行的时候是否组件的背景颜色参与动画 opacity transition过渡执行的时候是否组件的不透明度参与动画 transform transition过渡执行的时候是否组件的变换类型参与动画 transition-duration:指定transition过渡的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 transition-delay:指定请求transition过渡操作到执行transition过渡之间的时间间隔 (单位是毫秒或者秒)，默认值是 0，表示没有延迟，在请求后立即执行transition过渡。 transition-timing-function:描述transition过渡执行的速度曲线，用于使transition过渡更为平滑。默认值是 ease。下表列出了所有合法的属性： 属性名 描述 ease transition过渡逐渐变慢的过渡效果 ease-in transition过渡慢速开始，然后变快的过渡效果 ease-out transition过渡快速开始，然后变慢的过渡效果 ease-in-out transition过渡慢速开始，然后变快，然后慢速结束的过渡效果 linear transition过渡以匀速变化 cubic-bezier(x1, y1, x2, y2) 使用三阶贝塞尔函数中自定义transition变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. 示例#&lt;style scoped&gt; .panel &#123; margin: 10px; top:10px; align-items: center; justify-content: center; border: solid; border-radius: 10px; transition-property: width,height,backgroundColor; transition-duration: 0.3s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); &#125;&lt;/style&gt; 伪类 v0.9.5+#Weex 支持四种伪类：active, focus, disabled, enabled 所有组件都支持 active, 但只有 input 组件和 textarea 组件支持 focus, enabled, disabled。 规则# 同时生效的时候，优先级高覆盖优先级低 例如：input:active:enabled 和 input:active 同时生效，前者覆盖后者 互联规则如下所示 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;image :src=\"logoUrl\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; align-items: center; margin-top: 120px; &#125; .title &#123; font-size: 48px; &#125; .logo &#123; width: 360px; height: 82px; background-color: red; &#125; .logo:active &#123; width: 180px; height: 82px; background-color: green; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; props: &#123; logoUrl: &#123; default: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png' &#125;, target: &#123; default: 'World' &#125; &#125;, methods: &#123; update (e) &#123; this.target = 'Weex'; &#125; &#125; &#125;;&lt;/script&gt; 试一下 线性渐变 v0.10+#Weex 支持线性渐变背景，具体介绍可参考 W3C description of the gradient。 所有组件均支持线性渐变。 使用# 你可以通过 background-image 属性创建线性渐变。 background-image: linear-gradient(to top,#a80077,#66ff00); 目前暂不支持 radial-gradient（径向渐变）。 Weex 目前只支持两种颜色的渐变，渐变方向如下： to right从左向右渐变 to left从右向左渐变 to bottom从上到下渐变 to top从下到上渐变 to bottom right从左上角到右下角 to top left从右下角到左上角 Note# background-image 优先级高于 background-color，这意味着同时设置 background-image 和 background-color，background-color 被覆盖。 不要使用 background 简写. 示例#&lt;template&gt; &lt;scroller style=\"background-color: #3a3a3a\"&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to left&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to bottom,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container1\" style=\"background-image:linear-gradient(to top,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;align-items: center;justify-content: center\"&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to bottom right,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to bottom right&lt;/text&gt; &lt;/div&gt; &lt;div class=\"container2\" style=\"background-image:linear-gradient(to top left,#a80077,#66ff00);\"&gt; &lt;text class=\"direction\"&gt;to top left&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .container1 &#123; margin: 10px; width: 730px; height: 200px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .container2 &#123; margin: 10px; width: 300px; height: 300px; align-items: center; justify-content: center; border: solid; border-radius: 10px; &#125; .direction &#123; font-size: 40px; color: white; &#125;&lt;/style&gt; 阴影(box-shadow) v0.11+#Weex 支持阴影属性：active, focus, disabled, enabled inset(可选),offset-x,offset-y, blur-radius,color 注意# box-shadow仅仅支持iOS 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div style=\"width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgba(255, 69, 0, 0.8);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:inset 20px 10px 5px rgb(255, 69, 0);\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px black;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div style=\"margin-top: 80px;width:400px; height:60px;background-color: #FFE4C4; box-shadow:20px 10px 5px #008B00;\"&gt; &lt;text class=\"title\" style=\"text-align: center\"&gt;Hello &#123;&#123;target&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123;align-items: center; margin-top: 120px;&#125; .title &#123;font-size: 48px;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; logoUrl: 'https://alibaba.github.io/weex/img/weex_logo_blue@3x.png', target: 'World' &#125;; &#125; &#125;;&lt;/script&gt; 其他基本样式# opacity {number}：取值范围为 [0, 1] 区间。默认值是 1，即完全不透明；0 是完全透明；0.5 是 50% 的透明度。 background-color {color}：设定元素的背景色，可选值为色值，支持RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red），默认值是 transparent 。 注意： 色值的关键字列表。 上手样式#如果对于样式写法需要更多上手参考，可参考每个组件的文档中，都有常见的例子可供参考。 你可以按照以下步骤来规划 Weex 页面的样式。 全局样式规划：将整个页面分割成合适的模块。 flex 布局：排列和对齐页面模块。 定位盒子：定位并设置偏移量。 细节样式处理：增加特定的具体样式。","type":"wiki"},{"title":"设计理念","path":"cn/wiki/design-principles.html","permalink":"https://weex.apache.org/cn/wiki/design-principles.html","text":"","type":"wiki"},{"title":"事件冒泡","path":"cn/wiki/event-bubble.html","permalink":"https://weex.apache.org/cn/wiki/event-bubble.html","text":"事件冒泡 v0.13+#Weex 2.0 实现了 W3C 标准的事件冒泡机制。 使用#&lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it 运行以上代码，用客户端打开，点击中间的元素，可以看到事件向上传播，依次触发。 注意#需要注意的是: 为了兼容之前的版本，Weex 默认不会开启事件冒泡机制。需要在根元素的属性上，添加 bubble=&quot;true&quot; 来开启冒泡机制。否则，将不会向上传播事件，保持与之前版本的效果相同。 stopPropagation#在事件处理函数中，可以使用 e.stopPropagation() 方法，来阻止本次事件向上的传递过程。注意，e.stopPropagation() 与 bubble=&quot;true&quot; 不同，前者只会影响当前元素以及父元素的传播，不会影响子元素的传播；后者是为了版本兼容而增加的开关机制，会全局关闭或者开启冒泡机制，两者可以共同存在使用，如下： &lt;template&gt; &lt;div class=\"root\" @click=\"rootClick\" bubble=\"true\"&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;rootText&#125;&#125;&lt;/text&gt; &lt;div class=\"outer\" @click=\"parentClick\"&gt; &lt;div&gt; &lt;text style=\"font-size: 40px;\"&gt;&#123;&#123;parentText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"inner\" @click=\"click\"&gt;&#123;&#123;innerText&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; innerText: 'click me', parentText: '', rootText: '' &#125;, methods: &#123; click: function(e) &#123; this.innerText = 'inner bubble' &#125;, parentClick: function(e) &#123; this.parentText = 'parent bubble' e.stopPropagation() &#125;, rootClick: function(e) &#123; this.rootText = 'root bubble' // e.stopPropagation() &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .inner &#123; font-size: 40px; text-align: center; background-color: #7a9b1b; padding: 40px; &#125; .outer &#123; font-size: 40px; text-align: center; background-color: #9b7a1b; padding: 120px; &#125; .root &#123; font-size: 40px; text-align: center; background-color: #7a1b9b; padding: 80px; &#125;&lt;/style&gt; try it 运行以上代码，用客户端打开，点击中间的元素，可以看到事件向上传播到父元素被终止，不再继续往根元素传播。","type":"wiki"},{"title":"手势","path":"cn/wiki/gestures.html","permalink":"https://weex.apache.org/cn/wiki/gestures.html","text":"手势#注：该功能属于实验性功能 Weex 封装了原生的触摸事件以提供手势系统。使用手势类似于在 Weex 中使用事件，只需在节点上设置 on 特性来监听手势即可。 手势类型#目前，仅支持以下四种手势类型： Touch：当触摸到一个点，移动或从触摸面移开时触发 touch 手势。触摸手势很精准，它会返回所有详细的事件信息。所以，监听 touch 手势可能很慢，即使只移动一丁点也需要处理大量事件。有三种类型的 touch 手势： touchstart 将在触摸到触摸面上时触发。 touchmove 将在触摸点在触摸面移动时被触发。 touchend 将在从触摸面离开时被触发。 Pan：pan 手势也会返回触摸点在触摸面的移动信息，有点类似于 touch 手势。但是 pan 手势只会采样收集部分事件信息因此比 touch 事件要快得多，当然精准性差于 touch。pan 也有三中类型的手势，这些手势的意义与 touch 完全一样： panstart panmove panend horizontalpan v0.10+：手势的 start/move/end 状态保存在 state 特性中。目前该手势在 Android 下会与 click 事件冲突。 verticalpan v0.10+：势的 start/move/end 状态保存在 state 特性中。目前该手势在 Android 下会与 click 事件冲突。 Swipe：swipe 将会在用户在屏幕上滑动时触发，一次连续的滑动只会触发一次 swiper 手势。 LongPress：LongPress 将会在触摸点连续保持 500 ms以上时触发。 touch 和 pan 非常接近，它们的特点可以总结成这样： Touch：完整信息，精准、很慢 Pan：抽样信息，很快，不够精准 开发者可以根据自己的情况选择合适的手势。 属性#以下属性可以在手势的回调中使用： direction：仅在 swipe 手势中存在，返回滑动方向，返回值可能为 up, left, bottom, right。 changedTouches：一个数组，包含了当前手势的触摸点的运动轨迹 changedTouches#changedTouches 是一个数组，其子元素中包含以下属性： identifier：触摸点的唯一标识符。 pageX：触摸点相对于文档左侧边缘的 X 轴坐标。 pageY：触摸点相对于文档顶部边缘的 Y 轴坐标。 screenX：触摸点相对于屏幕左侧边缘的 X 轴坐标。 screenY：触摸点相对于屏幕顶部边缘的 Y 轴坐标。 约束#目前，由于会触发大量事件冲突，Weex Android 还不支持在滚动类型的元素上监听手势，例如 scroller, list 和 webview 这三个组件。","type":"wiki"},{"title":"与 Web 平台的差异","path":"cn/wiki/platform-difference.html","permalink":"https://weex.apache.org/cn/wiki/platform-difference.html","text":"Weex 和 Web 平台的差异#Weex 是一个跨平台解决方案，Web 平台只是其一种运行环境，除此之外还可以在 Android 和 iOS 客户端中运行。原生开发平台和 Web 平台之间的差异，在功能和开发体验上都有一些差异。 Weex 环境中没有 DOM#DOM（Document Object Model），即文档对象模型，是 HTML 和 XML 文档的编程接口，是 Web 中的概念。Weex 的运行环境以原生应用为主，在 Android 和 iOS 环境中渲染出来的是原生的组件，不是 DOM Element。 不支持 DOM 操作#既然原生环境中不支持 Web API，没有 Element 、Event 、File 等对象，详细列表可以参考 Web APIs on MDN。不支持选中元素，如 document.getElementById 、 document.querySelector 等；当然也不支持基于 DOM API 的程序库（如 jQuery）。 有限的事件类型#Weex 支持在标签上绑定事件，和在浏览器中的写法一样，但是 Weex 中的事件是由原生组件捕获并触发的，行为和浏览器中有所不同，事件中的属性也和 Web 中有差异。 并不支持 Web 中所有的事件类型，详情请参考《通用事件》。 不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。 Weex 环境中没有 BOM#BOM（Browser Object Model），即浏览器对象模型，是浏览器环境为 javascript 提供的接口。Weex 在原生端没有并不基于浏览器运行，不支持浏览器提供的 BOM 接口。 没有 window 、screen 对象#Weex 中并未提供浏览器中的 window 和 screen 对象，不支持使用全局变量。如果是想要获取设备的屏幕或环境信息，可以使用 WXEnvironment 变量。 WXEnvironment weexVersion: WeexSDK 的版本。 appName: 应用的名称。 appVersion: 应用的版本。 platform: 运行平台，可能的值是 Web 、Android 、iOS 之一。 osName: 系统的名称。 osVersion: 系统版本。 deviceWidth: 设备宽度。 deviceHeight: 设备高度。 没有 document 对象#在浏览器中 document 表示了当前活动的文档模型，在 Android 和 iOS 环境中并没有这个对象，也不支持与其相关的 DOM 操作。 没有 history 、location 、navigator 对象# history 保存了当前页面的历史记录，并且提供了前进后退操作。 location 记录了当前页面 URL 相关的信息。 navigator 记录了当前浏览器中的信息。 这些接口与浏览器自身的实现有关，可以控制页面的前进后退并且获取状态信息。虽然在 Android 和 iOS 中也有“历史”和“导航”的概念，但是它是用于多个管理视图之间的跳转的。换句话说，在浏览器中执行“前进”、“后退”仍然会处于同一个页签中，在原生应用中“前进”、“后退”则会真实的跳转到其他页面。 此外 Weex 也提供了 navigator 模块来操作页面的跳转，使用方法参考《navigator 导航控制》。 能够调用移动设备原生 API#在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。 《clipboard 剪切板》 《navigator 导航控制》 《storage 本地存储 》 为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考《iOS 扩展》 和《Android 扩展》。 有些接口在浏览器环境中也存在，不过在使用时应该注意浏览器的兼容性；如剪贴板功能，出于安全性考虑，绝大多数浏览器都限制其使用。","type":"wiki"},{"title":"文本样式","path":"cn/wiki/text-styles.html","permalink":"https://weex.apache.org/cn/wiki/text-styles.html","text":"文本样式#v0.5+ 文本类组件共享一些通用样式, 这类组件目前包括 &lt;text&gt; 和 &lt;input&gt;。 属性# color {color}：文字颜色。 可选值为色值，支持 RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red）。 lines {number}: 指定文本行数。仅在 &lt;text&gt; 组件中支持。默认值是 0 代表不限制行数。 font-size {number}：文字大小。 font-style {string}：字体类别。可选值 normal | italic，默认为 normal。 font-weight {string}v0.9+：字体粗细程度 可选值: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal 等同于 400, bold 等同于 700； 默认值: normal； iOS 支持 9 种 font-weight值；Android 仅支持 400 和 700, 其他值会设为 400 或 700 类似 lighter, bolder 这样的值暂时不支持 text-decoration {string}：字体装饰，可选值 none | underline | line-through，默认值为 none。 text-align {string}：对齐方式。可选值 left | center | right，默认值为 left。目前暂不支持 justify, justify-all。 font-family {string}：设置字体。 这个设置 不保证 在不同平台，设备间的一致性。如所选设置在平台上不可用，将会降级到平台默认字体。 text-overflow {string}：设置内容超长时的省略样式。可选值 clip | ellipsis 其它参考# 颜色关键字列表。","type":"wiki"},{"title":"Mobile App Architecture","path":"guide/advanced/app-architecture.html","permalink":"https://weex.apache.org/guide/advanced/app-architecture.html","text":"Mobile App Architecture#Today’s Mobile App#Let’s talk about what we think a mobile app should be. Mobile App Needs Parallel Development#Nowadays, all mobile app teams requires the ability to develop in parallel. When a mobile app keeps growing, supporting large-scale parallel development must become a very important key thing. Otherwise it’s really easy to become a bottleneck. Mobile App Needs to be Dynamic#Today the development of mobile apps is very heavy. And it’s really slow in iteration, release, distribution and online bugfix. The size of the package of an app is growing fast too. All of this is not suitable for this mobile internet age. Mobile app needs to be dynaimic which is out of the cumbersome process of version deployment and distribution. Mobile App Needs Open Interconnection#Today in your phone, things are hard to connect and share between different apps. They needs some container with common standard and specs to be shared with each other. Our Thinking of Mobile App#We think a dynamic, parallel development supported, standardized mobile app should be like this: |------|------|------|------| |-----|| page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||---------------------------| | api || router | | api ||---------------------------| |-----| Pages: A whole mobile app should be divided into several mobile pages. Each mobile page has its own “URL”. Router: All the mobile pages above will be connected with router. And navigators or tab bars are just doing this job. Features: All kinds of APIs or services provided from the device. Every mobile page could use these features as they like. So before you build your mobile app, make sure how many mobile pages your mobile app has and what are they. How do they connect each other. Give each mobile page a URL. And sort out all the APIs and services your mobile app needs. Then create the pages and develop, debug and deploy them using Weex. Links Mobile page architecture If you have built a complete mobile app already and just want to using Weex to rebuild part of these pages, that’s absolutely no problem. Because Weex is just a SDK to build mobile pages which can coexist very well with other native views or hybrid pages. If the feature of WeexSDK is limited to your mobile app. You can extend your own components and modules. It requires some native development knowledge. But with our efforts on delivering more and more features, we believe this part of job will be getting smaller and smaller. Links Extend to iOS Extend to Android","type":"guide"},{"title":"Downgrade","path":"guide/advanced/downgrade.html","permalink":"https://weex.apache.org/guide/advanced/downgrade.html","text":"downgrade#Weex 2.0 downgrade change to module，please refer to downgrade","type":"guide"},{"title":"Weex Page Architecture","path":"guide/advanced/page-architecture.html","permalink":"https://weex.apache.org/guide/advanced/page-architecture.html","text":"Weex Page Architecture#A Weex page is a independent mobile page which includes UI, interaction logic, device power, lifecycle management etc. UI#Native DOM Model#Weex page has its HTML-like DOM model to manage UI. It will be decomposed into a DOM tree which consists of some DOM nodes. Links Weex Native DOM APIs Components#Weex supports many kinds of components. Some of them are content components such as text, image and videos. Some of them are container components such as div, list, scroller. Also there are some special components like slider, input, textarea, and switch. Links All components Weex supports Layout System#Weex use some CSS properties to layout every nodes in the DOM tree together. It includes: Box model: Describe the width, height, padding, margin and border of a component node. Flexbox: Describe the relations between different nodes with CSS Flexbox Spec. Supportting absolute, relative, fixed and sticky value of CSS position property. Features#Weex supports lots of device features through modules such as storage, navigation, modals etc. Each of them exposes some JS APIs. Links All modules Weex supports Lifecycle#Every Weex page has its lifecycle which is defined and implemented in WeexSDK. All Weex pages will go through the whole process, from being created and last to being destroyed.","type":"guide"},{"title":"Asset Path","path":"guide/advanced/path.html","permalink":"https://weex.apache.org/guide/advanced/path.html","text":"Path#0.9 This article will cover uri (url) usage in Weex. Including using image/typeface resources, deal with relative uri and how to access local and packaged asset files. Schemes# LocalWeex SDK provide local scheme to access resources packaged with application, and of cource, it’s not working in the HTML5 runtime.Currently, developers can use this scheme with image and text’s font file location. In iOS, it’s always locate file in ‘bundle resources’. For example, a image component with local:///app_icon will load image file named ‘app_icon’ in bundle resouce, and font file work in the same way. In Android, image component will load from ‘drawable’ resource folder like ‘res/drawable-xxx’. But load font file is different, android framework can not load font file from ‘res’, so SDK will load it from asserts folder. HTTP/HTTPSIt’s working in the same way as in web, Weex support these at very beginning. FileUse file scheme to access local disk file. This scheme has its limitations: You would not hard coded a file url in source page. Because not matter it’s running in different platform(iOS, Android) or not, the content will be totally different in another device, which is depend to the specific device.So one possible case is getting the file url in runtime dynamically, which you can use it to diaplay a local disk image, or maybe upload it later. Relative URI#Like we do in HTML, weex process ‘relative URI’ in the same way. The relative URI, which start with /,.,..,//, will resolve by the bunle url.Means URL start with / will resolve to the root folder as bundle js file, . and .. will resolve to current and parent folder, and // will resolve to same scheme bundle js have. URI Adapter#All the above is the default implementation, developers can extend or override these their own by providing a ‘URI Adapter’. Same as the other adapters, Custom adapter should be set before Weex SDK is initializing.","type":"guide"},{"title":"Use Vuex and vue-router","path":"guide/advanced/use-vuex-and-vue-router.html","permalink":"https://weex.apache.org/guide/advanced/use-vuex-and-vue-router.html","text":"Using Vuex and vue-router#Vue.js also has many peripheral technology products such as Vuex and vue-router, etc. Those libraries can also works well in Weex. We developed a complete project based on Weex and Vue.js which named weex-hackernews. We used Vuex and vue-loader in it, and it works well on both iOS, Android and web. Using Vuex# Official Vuex documents Vuex is a state management pattern + library for Vue.js applications. it’s also a library implementation tailored specifically for Vue.js to take advantage of its granular reactivity system for efficient updates. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. As a kind of state management library, Vuex is platform-independent, It also can be used in Weex. Read its official documents for more details. It also integrates with Vue’s official devtools extension to provide advanced features on web platform, such as zero-config time-travel debugging and state snapshot export / import. (web platform only) Using vue-router# Official vue-router documents Creating a Single-page Application with Vue.js + vue-router is dead simple. With Vue.js, you are already composing our application with components. When adding vue-router to the mix, all you need to do is map your components to the routes and let vue-router know where to render them. However, there are many difference between web and Android or iOS, some features of vue-router are limited in Weex. Router mode#vue-router provides three routing modes: hash: uses the URL hash for routing. Works in all Vue-supported browsers, including those that do not support HTML5 History API. (default) history: requires HTML5 History API and server config. See HTML5 History Mode. abstract: works in all JavaScript environments, e.g. server-side with Node.js. You can pass the mode parameter when creating a router: new Router(&#123; mode: 'abstract', // ...&#125;) Obviously “hash” mode and “history” mode are only available on the web, and have no effect in Weex. That is, you have to use “abstract” mode in Android and iOS. However, vue-router will automatically be forced into “abstract” mode if no browser API is present. so, just don’t set the mode option, or set it to “abstract”. Programmatic navigation#vue-router use &lt;router-link&gt; to create a navigation link, but in which some of the features based on the DOM events, it doesn’t work well in the native environment. In Weex, you must use the Programmatic Navigation to manage the router. Here is an basic example using &lt;router-link&gt;: &lt;!-- Can only be used on the web, it takes no effects on Android or iOS! --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link to=\"profile\"&gt; &lt;text&gt;Profile&lt;/text&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; For native platforms, you have to use the router.push: &lt;template&gt; &lt;div&gt; &lt;text @click=\"jump\"&gt;Profile&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import router from './path/to/router' export default &#123; methods: &#123; jump () &#123; router.push('profile') &#125; &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"<a>","path":"references/components/a.html","permalink":"https://weex.apache.org/references/components/a.html","text":"&lt;a&gt;#a defines a hyperlink to a page in the web. Its purpose and syntax is very similar to in HTML5. Child Components#This type of component supports all kinds of weex component as it’s child components except for its own kind. Attributes# href: href attributes defines the URL of the hyperlink. Styles:#common styles#Check out the common styles Events#common events#Check out the common events Notes#We can’t guarantee the order of execution between onclick function and href. we recommend that do not use the click event in a. Examples#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;a class=\"button\" href=\"http://dotwe.org/raw/dist/3e0e40f9ddad79f98cd236753965ffd8.js\"&gt; &lt;text class=\"text\"&gt;Jump&lt;/text&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; width: 450px; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5 &#125; .text &#123; font-size: 60px; color: #666666; text-align: center; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<div>","path":"references/components/div.html","permalink":"https://weex.apache.org/references/components/div.html","text":"&lt;div&gt;#Summary#The most fundamental component which is a contianer to wrap any other components. It supports all the common styles, attributes and layout of flexbox. alias: &lt;container&gt; (deprecated) Child Components#This type of component supports all kinds of weex component as its child components including its own kind. Attributes#There is no specific attribute for this component. Styles#common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Examples#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<cell>","path":"references/components/cell.html","permalink":"https://weex.apache.org/references/components/cell.html","text":"&lt;cell&gt;#Summary#This component must be used as a subcomponent of a list component, which is for the performance optimizing during scrolling. Child Components#This type of component supports all kinds of weex component as its child components. Attributes#Notes: you can’t give &lt;cell&gt; a flex value. Width of &lt;cell&gt; is equal to the width of its parent component &lt;list&gt;, and you don’t need to specify its height. keep-scroll-position {boolean}: v0.11+ List Whether to keep the last sliding position after inserting the Cell Styles#common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Notes: cell itself is a container, its layout info is managed by list, so specifying cell’s margin info will not work. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#please refer to List","type":"references"},{"title":"<image>","path":"references/components/image.html","permalink":"https://weex.apache.org/references/components/image.html","text":"&lt;image&gt;#Summary#image tag is used to render a specified picture, and it shouldn’t contain any child component. &lt;img&gt; is not supported currently. Notes: the styles of width and height should be specified, otherwise it won’t work. Child Components#This component supports no child components. Attributes# src: &lt;string&gt; image source url resize: v0.5+ &lt;string&gt; the ‘ScaleType’ of the component. The default value is stretch, if this attribute is not specified. Possible values are cover, contain, each of which has the same meaning with w3c standard. placeholder: v0.9+ &lt;string&gt; image to display while the network image src is loading. Styles# width: &lt;length&gt; the width of the component. This style should be specified. height: &lt;length&gt; the height of the component. This style should be specifed. common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events loadv0.8+ event. The load event fires on an image has been loaded. Only Android and iOS are supported currently. example event object success : true if the image was loaded successfully, otherwise false size : the original size of image, contains two parameters: naturalWidth representing the original width of image in pixels, naturalHeight representing the original height of image in pixels. default value. The default value for both parameters is 0. component method support save v0.16.0+ image to local device or photo album. you should specify a callback function to receive the saving result. var image = this.$refs.imageRef; // image 是之前已经定义过的ref image.save(function(result) &#123; console.log(JSON.stringify(result))&#125;); and the result can be the following format &#123; &quot;success&quot; : true/false, // 保存成功或失败 &quot;errorDesc&quot;: &quot;errordesc&quot; // 在success 为false的情况会返回 &#125; noteyou must add NSPhotoLibraryAddUsageDescription and NSPhotoLibraryAddUsageDescription(iOS 11) privacy to access photo album for iOS, see more privacy try it for saving image Examples#&lt;template&gt; &lt;scroller class=\"wrapper\" &gt; &lt;div class=\"page-head\" &gt; &lt;image class=\"title-bg\" resize=\"cover\" src=\"https://img.alicdn.com/tps/TB1dX5NOFXXXXc6XFXXXXXXXXXX-750-202.png\"&gt;&lt;/image&gt; &lt;div class=\"title-box\"&gt; &lt;text class=\"title\"&gt;Alan Mathison Turing&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"article\"&gt; &lt;text class=\"paragraph\"&gt;Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;During the Second World War, Turing worked for the Government Code and Cypher School (GC&amp;CS) at Bletchley Park, Britain's codebreaking centre. For a time he led Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for speeding the breaking of German ciphers, including improvements to the pre-war Polish bombe method, an electromechanical machine that could find settings for the Enigma machine. Turing played a pivotal role in cracking intercepted coded messages that enabled the Allies to defeat the Nazis in many crucial engagements, including the Battle of the Atlantic; it has been estimated that this work shortened the war in Europe by more than two years and saved over fourteen million lives.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;After the war, he worked at the National Physical Laboratory, where he designed the ACE, among the first designs for a stored-program computer. In 1948 Turing joined Max Newman's Computing Machine Laboratory at the Victoria University of Manchester, where he helped develop the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov–Zhabotinsky reaction, first observed in the 1960s.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;Turing was prosecuted in 1952 for homosexual acts, when by the Labouchere Amendment, \"gross indecency\" was still criminal in the UK. He accepted chemical castration treatment, with DES, as an alternative to prison. Turing died in 1954, 16 days before his 42nd birthday, from cyanide poisoning. An inquest determined his death as suicide, but it has been noted that the known evidence is also consistent with accidental poisoning. In 2009, following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for \"the appalling way he was treated.\" Queen Elizabeth II granted him a posthumous pardon in 2013.&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .page-head &#123; width: 750px; height: 200px; &#125; .title-bg &#123; width: 750px; height: 200px; &#125; .title-box &#123; width: 750px; height: 200px; justify-content: center; align-items: center; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125; .title &#123; color: #ffffff; font-size: 32px; font-weight: bold; &#125; .article &#123; padding: 20px; &#125; .paragraph&#123; margin-bottom: 15px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<indicator>","path":"references/components/indicator.html","permalink":"https://weex.apache.org/references/components/indicator.html","text":"&lt;indicator&gt;#Summary#This component must be used as a subcomponent of a slider component. Child Components#This component supports no child components. Attributes#There is no specific attribute for this component. Styles# item-color: &lt;colors&gt; This style attribute sets the normal item color using either a named color or a color specified in the hexadecimal #RRGGBB format. item-selectedColor: &lt;colors&gt; This style attribute sets the selected item color using either a named color or a color specified in the hexadecimal #RRGGBB format. item-size: &lt;length&gt; The size of the indicator elements, which is an float attribute. common styles: check out the common styles support flexbox related styles support box model related styles support position related styles Note: There are some specific details about the style width and height on this component: the position of indicator will not only depend on the top, left, bottom and right, but also depend on the value of width and height. Imagine there is a virtual container outside the indicator, and it inherit the width and height of the indicator. The top, left, right and bottom will always take effect on this container, not the indicator points themselves, and the indicator points will be positioned in the center of it. And also you should know the default width and height is the parent slider’s width and height. Note: background-color is not recommended to apply on this component, and you should use item-color and item-selectedColor instead. Events#common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"4500\" @change=\"onchange\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;img.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .title &#123; position: absolute; top: 20px; left: 20px; padding-left: 20px; width: 200px; color: #FFFFFF; font-size: 36px; line-height: 60px; background-color: rgba(0, 0, 0, 0.3); &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125; .indicator &#123; width: 700px; height: 700px; item-color: green; item-selected-color: red; item-size: 50px; top: 200px; left: 200px; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; title: 'item A', src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; title: 'item B', src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; title: 'item C', src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;, methods: &#123; onchange (event) &#123; console.log('changed:', event.index) &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<list>","path":"references/components/list.html","permalink":"https://weex.apache.org/references/components/list.html","text":"List#v0.6.1+ The List component, which inherits from Scroller component, is a core component, and it provides the most popular features for using a list of items. It can provide excellent experience and performance while still maintaining smooth scroll and low memory usage. example &lt;template&gt; &lt;list class=\"list\"&gt; &lt;cell class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; lists: ['A', 'B', 'C', 'D', 'E'] &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 300px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .text &#123; font-size: 88px; text-align: center; color: #41B883; &#125;&lt;/style&gt; Child Components#Notes: The list now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell 0.6.1 defines the attributes and behavior of the cells that appear in list. header 0.6.1 sticks to the top when it reaches the top of the screen. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes# show-scrollbar: true/false whether show the scroll bar or not, default value is true loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. offset-accuracy： default value is 0, the vertical offset distance required to trigger the scroll event. Please checkout Scroller Component Attributes to have a look at the inherited attributes from direct parent. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#onloadmore 0.5 used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. scroll 0.12+ used with offset-accuracy attribute. This event is fired when the list scrolls. The current contentOffset value is given in this event callback. See details in scroll event demo. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events API#All cells or cell’s subcomponents in list support the scrollToElement API in dom module Difference between loading child component and onloadmore event#loading is a child component that can response to the onloading event, and this event can only be triggered when the scroller/list has been scrolled down to the bottom.onloadmore is an event that will be triggered when the rest of the scroller/list is less than loadmoreoffset long. Restrictions#Nested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. Example#&lt;template&gt; &lt;list class=\"list\" @loadmore=\"fetch\" loadmoreoffset=\"10\"&gt; &lt;cell class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; fetch (event) &#123; modal.toast(&#123; message: 'loadmore', duration: 1 &#125;) setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; &#125;, 800) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<input>","path":"references/components/input.html","permalink":"https://weex.apache.org/references/components/input.html","text":"input#The weex builtin component input is used to create input controls to receive the user’s input characters. How a input component works varies considerably depending on the value of its type attribute, such as text, password, url, email, tel etc. Notes: does not support the common-event click. Please listen to the input or change event instead. Child Components#This component supports no child components. Attributes# type: the type of controls to display. The default value is text, if this attribute is not specified. Possible values are text, password, tel, email, url , number etc. each of which has the same meaning with \u001dW3C standard. value: the value(text) of the control. placeholder: a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: a boolean attribute lets you specify that a form control should have input focus when the page loads. maxlength: v0.7+ a number value to specify maxlength of input. return-key-type {string}：v0.11the keybord returen key type support defalut;go;next;search;send,done. Styles# placeholder-color: the color of placeholder. Default value is ‘#999999’. Pseudo-classv0.9.5+: input component support the following pseudo-classes: active focus disabled enabled text styles: checkout text styles support ‘color’ style. support ‘font-size’ style. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. common styles#check out common styles for components support flexbox related styles. support box model related styles. support ‘position’ related styles. support ‘opacity’, ‘background-color’ etc. Events# input: the value of an input character changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a ‘blur’ event. focus: a component has received focus. blur: a component has lost focus. return:the return key click. the object property of event: returnKeyType: return key Type of component value: component text value common events#check out common events support ‘appear’ / ‘disappear’ event. Methoads# focus() v0.9+ The focus() method is used to give focus to an input component and tigger soft keybord(if it can be focused). blur()v0.9+ The blur() method is used to remove focus from an input component and close soft keybord(if it has focus). setSelectionRange(selectionStart,selectionEnd) v0.11+set text selection range of input or textarea selectionStart {number}:set starting location text selection range selectionEnd {number}:set end location text selection range getEditSelectionRange(callback[selectionStart,selectionEnd]) v0.11+get text selection range of input or textarea selectionStart {number}:get starting location text selection range selectionEnd {number}: get end location text selection range Notes#does not support the common-event ‘click’. Please listen to the ‘input’ or ‘change’ event instead. Parameters of events’ object# for ‘input’ and ‘change’ events:’value’: the value of the component who dispatched this event.’timestamp’: the time stamp of the event. for ‘focus’ and ‘blur’ events:’timestamp’: the time stamp of the event. Example#&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;selection: &#123;&#123;txtSelection&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = number&lt;/text&gt; &lt;/div&gt; &lt;input type=\"number\" placeholder=\"Input number\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"getSelectionRange\" type=\"primary\" @click=\"getSelectionRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, getSelectionRange: function() &#123; console.log(this.$refs[\"inputselection\"]); var self = this; this.$refs[\"inputselection\"].getSelectionRange(function(e) &#123; self.txtSelection = e.selectionStart +'-' + e.selectionEnd; &#125;); &#125; &#125; &#125;;&lt;/script&gt; try it","type":"references"},{"title":"<refresh> & <loading>","path":"references/components/refresh.html","permalink":"https://weex.apache.org/references/components/refresh.html","text":"refresh &amp; loading#v0.6.1+ Loading Components#To be rendered properly, the refresh/loading Components must appear inside the Scroller Component or the List Component. Child Components#Any other components, like the text and img components, can be put inside the refresh component. And there is a special component named loading-indicator used only inside the refresh or the loading components. loading-indicator is a child component implemented with default animation effect for the refresh component. Attributes# display has value of show or hide. Styles#common styles: check out common styles for components Events# onloading triggered when loading Restrictions# refresh/loading does not support remove action, Weex 0.9 will fix it. refresh/loading despite setting with display=’hide’, the refresh/loading view will still appear when scrolling due to known issues. it can be fixed with a another display=’hide’ when the refresh/loading should be hidden. refresh/loading can only be hidden or displayed with an attribute display with value of show or hide. And there should be a statement of display=’hide’ when display=’show’ shows up in an event function, or your scroller may not response to user inputs. Example#&lt;template&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;loading class=\"loading\" @loading=\"onloading\" :display=\"showLoading\"&gt; &lt;text class=\"indicator\"&gt;Loading ...&lt;/text&gt; &lt;/loading&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; showLoading: 'hide', lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; onloading (event) &#123; modal.toast(&#123; message: 'loading', duration: 1 &#125;) this.showLoading = 'show' setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; this.showLoading = 'hide' &#125;, 1500) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5; &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125; .loading &#123; justify-content: center; &#125; .indicator &#123; color: #888888; font-size: 42px; padding-top: 20px; padding-bottom: 20px; text-align: center; &#125;&lt;/style&gt; Refresh Components#To be rendered properly, the refresh/loading Components must appear inside the Scroller Component or the List Component. Child Components#Any other components, like the text and img components, can be put inside the refresh component. And there is a special component named loading-indicator used only inside the refresh or the loading components. loading-indicator is a child component implemented with default animation effect for the refresh component. Attributes# display has value of show or hide, default value is show. Other attributes please check out the common attributes. Styles#common styles: check out common styles for components Events# onrefresh: triggered when the scroller has been pulled down onpullingdown: triggered when the scroller has been pulled down. you can get dy, pullingDistance, viewHeight, type from onpullingdown event object. dy: the differencen between two scroll actionspullingDistance: the distance of pullingviewHeight: the height of refreshViewtype: &quot;pullingdown&quot; constant string type for this event Restrictions# refresh/loading does not support remove action, may support in Weex 0.9. refresh/loading despite setting with display=’hide’, the refresh/loading view will still appear when scrolling due to known issues. it can be fixed with a another display=’hide’ when the refresh/loading should be hidden. refresh/loading can only be hidden or displayed with an attribute display with value of show or hide. And there should be a statement of display=’hide’ when display=’show’ shows up in an event function, or your scroller may not response to user inputs. example#&lt;template&gt; &lt;scroller class=\"scroller\"&gt; &lt;refresh class=\"refresh\" @refresh=\"onrefresh\" @pullingdown=\"onpullingdown\" :display=\"refreshing ? 'show' : 'hide'\"&gt; &lt;text class=\"indicator\"&gt;Refreshing ...&lt;/text&gt; &lt;/refresh&gt; &lt;div class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; refreshing: false, lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; onrefresh (event) &#123; console.log('is refreshing') modal.toast(&#123; message: 'refresh', duration: 1 &#125;) this.refreshing = true setTimeout(() =&gt; &#123; this.refreshing = false &#125;, 2000) &#125;, onpullingdown (event) &#123; console.log('is onpulling down') modal.toast(&#123; message: 'pulling down', duration: 1 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .indicator &#123; color: #888888; font-size: 42px; text-align: center; &#125; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5; &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<text>","path":"references/components/text.html","permalink":"https://weex.apache.org/references/components/text.html","text":"&lt;text&gt;#The weex builtin component ‘text’ is used to render text with specified style rule. tag can contain text value only. You can use variable interpolation in the text content with the mark {{}}. Child Components#This component supports no child components. Attributes# value(string): text value of this component. This is equal to the content of ‘text’. example#var textComponent = this.$el(&quot;textid&quot;);this.text = textComponent.attr.value; Styles# lines: specify the text lines. Default value is 0 for unlimited. text styles: check out text styles support ‘color’ style. support ‘font-size’ style. iOS: default vlaue 32. Android: platform specify. HTML5: default value 32. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. support ‘text-decoration’ style. support ‘text-overflow’ style. support ‘line-height’(available from v0.6.1) style. not support ‘flex-direction, ‘justify-content’, ‘align-items’ which is active for child nodes, and text has no child nodes. common styles#check out common styles for components support flexbox related styles. support box model related styles. support ‘position’ related styles. support ‘opacity’, ‘background-color’ etc. Events#common events#check out common events support ‘click’ event. support ‘appear’ / ‘disappear’ event. iconfont#support:v0.12.0 support ttf and woff font format to custom your text, call addRule in dom module to build your own font-family, we suggest that you call addRule in beforeCreate &lt;template&gt; &lt;div style='flex-direction:row;margin-top:50px'&gt; &lt;text style='font-family:iconfont4;font-size:50;color:green'&gt;&amp;#xe614;&amp;#xe612;&amp;#xe613;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:50;'&gt;&amp;#xe614;&amp;#xe612;&amp;#xe613;&amp;#xe61d;&amp;#xe714;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:60;color:blue'&gt;&amp;#xe711;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:60;color:green'&gt;&amp;#xe71c;&amp;#xe60b;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; beforeCreate: function() &#123; var domModule = weex.requireModule('dom'); //support ttf、woff file，svg、eot can not be supported ,moreItem at http://www.iconfont.cn/ domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\" &#125;); &#125;&#125;&lt;/script&gt; try it Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\" lines=\"3\"&gt;Weex 是一套简单易用的跨平台开发方案，能以 Web 的开发体验构建高性能、可扩展的原生应用。Vue 是一个轻量并且功能强大的渐进式前端框架。&lt;/text&gt; &lt;/div&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\" lines=\"3\"&gt;Weex is an cross-platform development solution that builds high-performance, scalable native applications with a Web development experience. Vue is a lightweight and powerful progressive front-end framework. &lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .panel &#123; width: 600px; margin-left: 75px; border-width: 2px; border-style: solid; border-color: #BBB; padding-top: 15px; padding-bottom: 15px; padding-left: 15px; padding-right: 15px; margin-bottom: 30px; &#125; .text &#123; lines: 3; color: #666666; font-size: 32px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<slider>","path":"references/components/slider.html","permalink":"https://weex.apache.org/references/components/slider.html","text":"&lt;slider&gt;#Summary#A slide’s player to show slides (mostly as pictures) one page by another. The default interval between two slides is 3 seconds. Child Components#It supports all kinds of weex components as its slides, especially the indicator component which can be used only as a child component of slider. Attributes# auto-play: &lt;boolean&gt; true | false. This value determines whether the slides plays automatically after the page rendering finished. The default value is false. interval: &lt;number&gt; millisecond. This value determines time interval for each page displayed in slider. index: . This value determines the index of current shown slide. The default value is 0. offset-x-accuracy {float}：set the scroll event trigger precision, precision value represents the rolling distance of a page width ratio. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events# change: triggerd when the slide’s index is changed. The event object contains the attribute of index, which is the index number of the currently shown slide. scroll 0.11+：this event is fired when scrolling. The current offsetXRatio value is given in this event callback. common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example#&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<switch>","path":"references/components/switch.html","permalink":"https://weex.apache.org/references/components/switch.html","text":"&lt;switch&gt;#v0.6.1+ The weex builtin component switch is used to create and manage an IOS styled On/Off buttons, for example, the Airplane mode button in the Settings app is a switch button. Child Components#There are no child components for the switch component. Attributes# checked &lt;boolean&gt; true|false, default value is false, indicating whether the button is on or not. disabled &lt;boolean&gt; true|false, default value is false, indicating whether the button is enable or not. Styles#Notes: There are several style properties that you mustn’t use on this component. And here are all the invalid properties: width height min-width min-height margin and margin-xxs padding and padding-xxs border and border-xxs Notes: If the container of &lt;switch&gt; is not set to align-items:flex-start, the switch in android will be stretched. common styles: check out common styles for components Events# onappear / ondisappear event. check out common events onclick: check out common events onchange: check out common events Parameters of events’ object for onchange event:# value: the value of the component who dispatched this event, which is the boolean value true or false. timestamp: the time stamp of the event. Examples#&lt;template&gt; &lt;div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;normal&lt;/text&gt; &lt;switch&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;checked&lt;/text&gt; &lt;switch checked=\"true\"&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;disabled&lt;/text&gt; &lt;switch disabled=\"true\" checked=\"true\"&gt;&lt;/switch&gt; &lt;switch disabled=\"true\"&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;onchange&lt;/text&gt; &lt;switch @change=\"onchange\"&gt;&lt;/switch&gt; &lt;text class=\"info\"&gt;&#123;&#123;checked&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; checked: false &#125; &#125;, methods: &#123; onchange (event) &#123; console.log(`onchage, value: $&#123;event.value&#125;`) this.checked = event.value &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .example &#123; flex-direction: row; justify-content: flex-start; margin-top: 60px; &#125; .label &#123; font-size: 40px; line-height: 60px; width: 350px; color: #666; text-align: right; margin-right: 20px; &#125; .info &#123; font-size: 30px; line-height: 60px; color: #BBB; margin-left: 10px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<scroller>","path":"references/components/scroller.html","permalink":"https://weex.apache.org/references/components/scroller.html","text":"&lt;scroller&gt;#v0.6.1+ A scroller is a component in vertical direction which can have multiple child components in one column. If total height of its child components exceed the height of the scroller, the whole child components will be scrollable. Notes: A can be used as a root element or a embed element. The scroll direction of this component is column, and it can’t be changed. Child Components#Scroller supports all kinds of components, such as div, text, etc.And there are two special components that can only be used inside scroller component. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes# show-scrollbar: true/false whether show the scroll bar or not, default value is true scroll-direction: define scroll direction of component, horizontal or vertical scroll-direction defines the scrollable axis of scroller and flex-direction defines the layout axis of scroller. scroll-direction and flex-direction must be set to the same direction, otherwise, undefined behavior may happen. Default value for scroll-direction is vertical, and for flex-direction is row . Use scroll-direction:horizontal and flex-direction: row when a horizontal layout and scrollable scroller is expected. Use scroll-direction:vertical and flex-direction: column when a vertical layout and scrollable scroller is expected. But thoes two values are default, if you don’t set them, it also works fine. loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. offset-accuracy： default value is 0, the vertical offset distance required to trigger the scroll event. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#loadmore used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. scroll 0.12+ used with offset-accuracy attribute. This event is fired when the list scrolls. The current contentOffset value is given in this event callback. See details in scroll event demo. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events Restrictions#Nested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it","type":"references"},{"title":"<textarea>","path":"references/components/textarea.html","permalink":"https://weex.apache.org/references/components/textarea.html","text":"&lt;textarea&gt;#v0.8+ Summary#The weex builtin component textarea is used to create interactive controls to accept data from users. It can be a multi-line input. Notes: &lt;textarea&gt; support all event which &lt;input&gt; had. Child Components#This component supports no child components. attributes# value: &lt;string&gt; the value of the control. placeholder: &lt;string&gt; a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: &lt;boolean&gt; a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: &lt;boolean&gt; a boolean attribute lets you specify that a form control should have input focus when the page loads. rows:&lt;number&gt; a number which can specify the height of textarea, default is 2. Styles#Pseudo-classv0.9.5+: textarea component support the following pseudo-classes: active focus disabled enabled text styles: checkout text styles support color style. support font-size style. support font-style style. support font-weight style. support text-align style. common styles: check out common styles for components support flexbox related styles. support box model related styles. support position related styles. support opacity, background-color etc. Events# input: the value of an element changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a blur event. focus: a component has received focus. blur: a component has lost focus. common events: check out the common events support appear / disappear event. Check out common events. Notes: &lt;textarea&gt; does not support the common-event click. Please listen to the input or change event instead. Parameters of events’ object# for input and change events: value: the value of the component who dispatched this event. timestamp: the time stamp of the event. for focus and blur events: timestamp: the time stamp of the event. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;textarea class=\"textarea\" @input=\"oninput\" @change=\"onchange\" @focus=\"onfocus\" @blur=\"onblur\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; oninput (event) &#123; console.log('oninput:', event.value) modal.toast(&#123; message: `oninput: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onchange (event) &#123; console.log('onchange:', event.value) modal.toast(&#123; message: `onchange: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onfocus (event) &#123; console.log('onfocus:', event.value) modal.toast(&#123; message: `onfocus: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onblur (event) &#123; console.log('onblur:', event.value) modal.toast(&#123; message: `input blur: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .textarea &#123; font-size: 50px; width: 650px; margin-top: 50px; margin-left: 50px; padding-top: 20px; padding-bottom: 20px; padding-left: 20px; padding-right: 20px; color: #666666; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<web>","path":"references/components/web.html","permalink":"https://weex.apache.org/references/components/web.html","text":"&lt;web&gt;#v0.5+ Use web component to display any web content in the weex page. The srcattribute is used to specify a special source. You also can use webview module to control some web operation such as goBack,goForward and reload. see webview module.For example,You can use web component and webview module to assemble a browser. Child Components#This component supports no child components. Attributes#src(string): this attribute specifies the page source to load. Styles#width(float): the width of the component, default value is 0. This style must be specified. height(float): the height of the component, default value is 0. This style must be specifed. common styles#check out the common styles. support flexbox related stylessupport box model related stylessupport position related styles Events#pagestart: sent after the web component starts loading a page.pagefinish: sent after the web component finishes loading a page.error: sent if the web component failed to load a page. common events#support appear / disappear event. Check out common events Notes#not support click event. Example#We use a simple Browser Demo to show how to use web component and webview module. Check out webview module. &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;input class=\"input\" v-model=\"value\" ref=\"input\" type=\"url\" autofocus=\"false\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"button\" @click=\"reload\"&gt;reload&lt;/text&gt; &lt;/div&gt; &lt;web ref=\"webview\" :src=\"url\" class=\"webview\" @pagestart=\"start\" @pagefinish=\"finish\" @error=\"error\"&gt;&lt;/web&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const webview = weex.requireModule('webview') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; url : 'https://m.alibaba.com', value: 'https://m.alibaba.com' &#125; &#125;, methods: &#123; loadURL (event) &#123; this.url = this.value modal.toast(&#123; message: 'load url:' + this.url &#125;) setTimeout(() =&gt; &#123; console.log('will go back.') modal.toast(&#123; message: 'will go back' &#125;) webview.goBack(this.$refs.webview) &#125;, 10000) &#125;, reload (event) &#123; console.log('will reload webview') modal.toast(&#123; message: 'reload' &#125;) webview.reload(this.$refs.webview) &#125;, start (event) &#123; console.log('pagestart', event) modal.toast(&#123; message: 'pagestart' &#125;) &#125;, finish (event) &#123; console.log('pagefinish', event) modal.toast(&#123; message: 'pagefinish' &#125;) &#125;, error (event) &#123; console.log('error', event) modal.toast(&#123; message: 'error' &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .group &#123; flex-direction: row; justify-content: space-around; margin-top: 20px; &#125; .input &#123; width: 600px; font-size: 36px; padding-top: 15px; padding-bottom: 15px; border-width: 2px; border-style: solid; border-color: #BBBBBB; &#125; .button &#123; width: 225px; text-align: center; background-color: #D3D3D3; padding-top: 15px; padding-bottom: 15px; margin-bottom: 30px; font-size: 30px; &#125; .webview &#123; margin-left: 75px; width: 600px; height: 750px; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<video>","path":"references/components/video.html","permalink":"https://weex.apache.org/references/components/video.html","text":"&lt;video&gt;#v0.6.1+ The video component can be used to embed video content in a weex page. Child Components# text is the only valid type of child component. Attributes# src: &lt;string&gt; The URL of the video to embed. play-status: &lt;boolean&gt; play | pause. Use it to control video’s play/pause status. Default value is pause. auto-play: &lt;boolean&gt; true | false. Use it to control whether it is playing when the page initialization finished. Defalut value is false. Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events# onstart: triggered when playback state is Playing. onpause: triggered when playback state is Paused. onfinish: triggered when playback state is Finished. onfail: triggered when playback state is Failed. example#&lt;template&gt; &lt;div&gt; &lt;video class=\"video\" :src=\"src\" autoplay controls @start=\"onstart\" @pause=\"onpause\" @finish=\"onfinish\" @fail=\"onfail\"&gt;&lt;/video&gt; &lt;text class=\"info\"&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .video &#123; width: 630px; height: 350px; margin-top: 60px; margin-left: 60px; &#125; .info &#123; margin-top: 40px; font-size: 40px; text-align: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; state: '----', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125; &#125;, methods:&#123; onstart (event) &#123; this.state = 'onstart' &#125;, onpause (event) &#123; this.state = 'onpause' &#125;, onfinish (event) &#123; this.state = 'onfinish' &#125;, onfail (event) &#123; this.state = 'onfinish' &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<waterfall>","path":"references/components/waterfall.html","permalink":"https://weex.apache.org/references/components/waterfall.html","text":"waterfall#v0.11.0+ A component providing waterfall layout. Child Components#Notes: The waterfall now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell: presents the content for a single data item in waterfall header: components that need to stretch across multiple columns. It can be sticky by using css position. Attributes# column-width : This property describes the width of columns in waterfall elements. auto: means that the column width will be determined by other properties(e.g., column-count, if it has a non-auto value). &lt;length&gt;: describes the optimal column width. The actual column width may be wider (to fill the available space), or narrower (only if the available space is smaller than the specified column width). Specified values must be greater than 0. column-count:This property describes the number of columns of a multicol element. auto: means that the number of columns will be determined by other properties (e.g., column-width, if it has a non-auto value). &lt;integer&gt;: describes the optimal number of columns into which the content of the element will be flowed. Values must be greater than 0. If both column-width and column-count have non-auto values, the integer value describes the maximum number of columns. column-gap:sets the gap between columns. if normal is specified, the gap will be 32. To see other attributes, please checkout List Component Attributes Styles#common styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events#common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events API#All subcomponents in waterfall support the scrollToElement API in dom module Example#see playground waterfall example","type":"references"},{"title":"clipboard","path":"references/modules/clipboard.html","permalink":"https://weex.apache.org/references/modules/clipboard.html","text":"clipboard#v0.8+ (developing) clipboard allows you to getString() or setString() from the system clipboard. Not long ago, We’re still suffering from such a situation that we got a verification code sent by SMS, and we had no way to get the code from the SMS text but to typed it by our hands. How frustrated it is! But now you can enable your app to get the code from the system clipboard by calling clipboard.getString() . Caution# only support text. only works on Android and iOS. NOT works for html5, for web security reason. API#getString(callback)#reads from clipboard. Arguments#callback(function): the callback function after executing this action. data is the return value. setString(text)#sets the text to clipboard, having the same effect as copying manually. Arguments#text(string): the text copied to clipboard. Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"onItemClick\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"setContent\"&gt;Click to copy: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const clipboard = weex.requireModule('clipboard') export default &#123; data () &#123; return &#123; tobecopied: 'yay!', message: 'nothing.' &#125; &#125;, methods: &#123; setContent () &#123; clipboard.setString(this.tobecopied) &#125;, onItemClick () &#123; this.message = 'clicked! ' clipboard.getString(ret =&gt; &#123; this.message = 'text from clipboard:' + ret.data &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750px; height: 90px; padding-left: 30px; padding-right: 30px; border-bottom-width: 1px; border-style: solid; border-color: #DDDDDD; &#125; .text &#123; width: 750px; height: 90px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"animation","path":"references/modules/animation.html","permalink":"https://weex.apache.org/references/modules/animation.html","text":"animation#Smooth and meaningful animation is very effective for enhancing the user experience of mobile application, you can use the animation module to perform animation on components. A animation can perform a series of simple transformations (position, size, rotation, background color, and opacity) on the component. So, if you have a image component, you can move, rotate, grow, or shrink it. API#transition(node, options, callback)#Arguments#node#type: node position: An element that will be animated, for example , specify the ref attribute for the element you want to animated as element, so you can get this element by calling this.refs.element. options#type: object position: Transition options. duration (number): Specifies the number of milliseconds of animation execution, the default value is 0, means that no animation will occur. delay (number): Specifies the amount of milliseconds to wait between a change being requested to a property that is to be transitioned and the start of the transition effect. The default value is 0. needLayout(boolean)：Whether or not the layout animation occurs when animation is executed，default value is false timingFunction (string): Used to describe how the intermediate values of the styles being affected by a transition effect are calculated, default value is linear, the allowed attributes are listed in the following table: name description linear Specifies a transition effect with the same speed from start to end ease-in Specifies a transition effect with a slow start ease-out Specifies a transition effect with a slow end ease-in-out Specifies a transition effect with a slow start and end cubic-bezier(x1, y1, x2, y2) Define your own values in the cubic-bezier function. Possible values are parameter values from 0 to 1. More information about cubic-bezier please visit cubic-bezier and Bézier curve. styles (object): Specify the names and values of styles to which a transition effect should be applied. The allowed attributes are listed in the following table: name description value type default value width The width applied to the component after the animation finished. length none height The height applied to the component after the animation finished. length none backgroundColor The background color applied to the component after the animation finished. string none opacity The opacity applied to the component after the animation finished. number between 0 to 1 1 transformOrigin The povit of transition. The possible values for x-aris are left/center/right/length or percent, and possible values of y-axis are top/center/bottom/ length or percent x-axis y-axis center center transform Transform function to be applied to the element. The properties in the following table are supported object none properties of transform: name description value type default value translate/translateX/translateY Specifies the location of which the element will be translated to. pixel or percent none rotate/rotateX v0.14+ /rotateY v0.14+ Specifies the angle of which the element will be rotated, the unit is degree. number none perspective v0.16+ The distance between the z=0 plane and the user in order to give to the 3D-positioned element some perspective. Supported for Android 4.1 and above. number positive infinity scale/scaleX/scaleY Stretch or shrink the element. number none callback(function): Callback which is called after the completion of transition.NOTISE, after WeexSDK0.16.0, in iOS platform can get animation’s message about completion, there are two types of parameters with result, is Successand Fail, Android can not support until now. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div ref=\"test\" @click=\"move\" class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const animation = weex.requireModule('animation') const modal = weex.requireModule('modal') export default &#123; methods: &#123; move () &#123; var testEl = this.$refs.test; animation.transition(testEl, &#123; styles: &#123; color: '#FF0000', transform: 'translate(250px, 100px)', transformOrigin: 'center center' &#125;, duration: 800, //ms timingFunction: 'ease', needLayout:false, delay: 0 //ms &#125;, function () &#123; modal.toast(&#123; message: 'animation finished.' &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; width: 250px; height: 250px; background-color: #DDD; &#125;&lt;/style&gt; try it","type":"references"},{"title":"meta","path":"references/modules/meta.html","permalink":"https://weex.apache.org/references/modules/meta.html","text":"meta#The meta module can be used to declare meta information for a single page, such as the viewport of the container. API#setViewport(options)#0.10.0+ The default width (viewport) of Weex container is 750px. The setViewport method can change the viewport of the page and only takes effect on the current page. Notice: The viewport must be set before the page rendering starts. In other words, the setViewport method can only be used in the entry file, and before the new Vue (...) statement. If it’s used in the component, the code is executed only when the component is being rendered, meanwhile, the page is already in the rendering process, set the viewport will not take effect again. it is only in the rendering of the components will be implemented The corresponding code, Parameters#Referance: W3C Spec CSS Device Adaptation. options: viewport configuration width: Number or &quot;device-width&quot; or &quot;device-height&quot;. height: Number or &quot;device-width&quot; or &quot;device-height&quot;. The default unit of the width and height is px, other units are not supported. Example#The entry file: // entry.jsimport App from './app.vue'const meta = weex.requireModule('meta')// The width of the viewport is set to 640pxmeta.setViewport(&#123; width: 640&#125;)App.el = '#root'new Vue(App) After configuring the width of the viewport to 640 in the entry.js, all the components in the current page will take 640px as full screen width. Example component: &lt;!-- app.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div class=\"box750\"&gt; &lt;text class=\"text\"&gt;750&lt;/text&gt; &lt;div class=\"box640\"&gt; &lt;text class=\"text\"&gt;640&lt;/text&gt; &lt;div class=\"box480\"&gt; &lt;text class=\"text\"&gt;480&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box750 &#123; width: 750px; height: 750px; background-color: #EEEEEE; &#125; .box640 &#123; width: 640px; height: 640px; background-color: #CCCCCC; &#125; .box480 &#123; width: 480px; height: 480px; background-color: #AAAAAA; &#125; .text &#123; font-size: 50px; &#125;&lt;/style&gt; Try it. (The http://dotwe.org doesn’t support to configure the entry file currently.) Referance: Set up development environment.","type":"references"},{"title":"dom","path":"references/modules/dom.html","permalink":"https://weex.apache.org/references/modules/dom.html","text":"dom#Summary#A series of dom apis that sending virtual-dom’s messages to the native renderer to update the dom tree. The only API for developers to use in a .vue file is scrollToElement which you can use by calling the $scrollTo method. Other APIs mentioned on this page should only be used through the native renderer in the callNative process. API#scrollToElement(node, options)#Scroll the page to the specified node. This API should only be used on the element in the scroller or list component. This API can be used by calling the VM’s method $scrollTo (deprecated). You can use weex.requireModule(&#39;dom&#39;).scrollToElement to call this API in your .we file. Arguments# node(Node): an element that scrolled into the view. options(object): some options. offset(number): An offset to the visible position, default is 0. animated (bool) :set element animation, default true Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; /*justify-content: space-around;*/ justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it getComponentRect(ref,callback) v0.9.4+#You can get the view rectangle information of named element. An example callback result maybe: &#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; If you want to get the rectangle information of ‘weex view’ container, you can specify the ref=&#39;viewport&#39;. Example Useage: &lt;template&gt; &lt;div class=\"wrapper\" style='margin-top:200px'&gt; &lt;div ref=\"box\" class=\"box\"&gt; &lt;text class=\"info\"&gt;Width: &#123;&#123;size.width&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Height: &#123;&#123;size.height&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Top: &#123;&#123;size.top&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Bottom: &#123;&#123;size.bottom&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Left: &#123;&#123;size.left&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Right: &#123;&#123;size.right&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"info btn\" @click='click()'&gt;&#123;&#123;this.tip&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') function round(size) &#123; var roundSize = &#123; 'width': Math.round(size.width), 'height': Math.round(size.height), 'top': Math.round(size.top), 'bottom': Math.round(size.bottom), 'left': Math.round(size.left), 'right': Math.round(size.right) &#125; return roundSize &#125; export default &#123; data () &#123; return &#123; size: &#123; width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 &#125;, ref:\"viewport\", tip:\"get box rect\" &#125; &#125;, mounted () &#123; const result = dom.getComponentRect(this.ref, option =&gt; &#123; console.log('getComponentRect:', option) this.size = round.call(this,option.size); &#125;) &#125;, methods:&#123; click:function() &#123; if (this.ref === 'viewport') &#123; this.ref = this.$refs.box; this.tip = \"get viewport rect\" &#125; else &#123; this.ref = 'viewport' this.tip = \"get box rect\" &#125; const result = dom.getComponentRect(this.ref, option =&gt; &#123; console.log('getComponentRect:', option) this.size = round.call(this,option.size); &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .btn &#123; margin-top:20px; border-width:2px; border-style: solid; border-radius:10px; width:300px; margin-left:170px; padding-left:35px; border-color: rgb(162, 217, 192); &#125; .btn:active &#123; background-color: #8fbc8f; border-color: gray; &#125; .box &#123; align-items:center; margin-left: 150px; width: 350px; height: 400px; background-color: #DDD; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .info &#123; font-size: 40px; top:30px; margin-left:20px; font-family: Consolas, \"Liberation Mono\", Menlo, Courier, monospace; color: #41B883; &#125;&lt;/style&gt; try it addRule#support:v0.12.0 you can add your rule for dom by this, now we support fontFace only for building your custom font-family, use it on text directly. fontFace#var domModule = weex.requireModule('dom');domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\"&#125;); try it","type":"references"},{"title":"globalEvent","path":"references/modules/globalevent.html","permalink":"https://weex.apache.org/references/modules/globalevent.html","text":"globalEvent#v0.8+ Summary#globalEvent are used to listen for persistent events, such as changes in positioning information, gyroscopes, and so on. A global event is a secondary API that requires additional APIs to work with. You can register events via addEventListener, which can be removed by removeEventListener when you do not need to listen for globalEvent. AUCTION Only instance level is not application level . How to make your Module support global events#API development is complete, when the event needs to be sent, the need through the following methods: /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); How to dispatch a global event in a weex-html5 component or module ? Just dispatch the event on the document element: var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) Example#Android#Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\", params); iOS#[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; API#addEventListener(String eventName, String callback)#register global event. Arguments# eventName(string): The name of the event you want to listen to. callback(function): the callback function after executing this action. Example#var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)#remove global event Arguments# eventName(string): You no longer need to listen for event names. Example#var globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"modal","path":"references/modules/modal.html","permalink":"https://weex.apache.org/references/modules/modal.html","text":"modal#Weex provides a series of message boxes: toast, alert, confirm and prompt. API#toast(options)#A toast provides simple feedback about an operation in a small popup. For example, navigating away from an email before you send it triggers a “Draft saved” toast to let you know that you can continue editing later. Toasts automatically disappear after a timeout. Arguments# options (object): toast options. message (string): the text message that the toast shows. duration (number): the duration(seconds) that the toast shows. For Android: If the duration is longer than 3, it will use a system defined variable called LONG, otherwise it will use another variable called SHORT For iOS: It will show the toast during the specified time. alert(options, callback)#An alert box is often used if you want to make sure information comes through to the user.When an alert box pops up, the user will have to click “OK” to proceed. Arguments# options (object): alert box options. message (string): the text message that the alert shows. okTitle (string): the text of positive button, default is ‘OK’. callback (function): callback when complete.This method has a callback function whose arguments will be: result (string): the title text of the confirm button that clicked by user. confirm(options, callback)#A confirm box is often used if you want the user to verify or accept something. When a confirm box pops up, the user will have to click either confirm or cancel button to proceed. Arguments# options (object): confirm box options. message (string): the message that the confirm shows. okTitle (string): the title of confirm button, default is ‘OK’. cancelTitle (string): the title of cancel button, default is ‘Cancel’. callback (function): callback when complete. This method has a callback function whose arguments will be: result(string): the title text of the button that clicked by user. prompt(options, callback)#A prompt box is often used if you want the user to input a value before entering a page.When a prompt box pops up, the user will have to click either confirm or cancel button to proceed after entering an input value. Arguments# options (object): some options. message (string): the message that the prompt shows. okTitle (string): the title text of confirm button, default is ‘OK’. cancelTitle (string): the title text of cancel button, default is ‘Cancel’. callback (function): callback when complete.This method has a callback function whose arguments will be: ret (object): the argument will be a object, which has attributes result and data, like { result: &#39;OK&#39;, data: &#39;hello world&#39; } result (string): the title of the button that clicked by user. data (string): the value of the text that entered by user. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"showToast\"&gt;Toast&lt;/text&gt; &lt;text class=\"button\" @click=\"showAlert\"&gt;Alert&lt;/text&gt; &lt;text class=\"button\" @click=\"showConfirm\"&gt;Confirm&lt;/text&gt; &lt;text class=\"button\" @click=\"showPrompt\"&gt;Prompt&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var modal = weex.requireModule('modal') export default &#123; methods: &#123; showToast (event) &#123; console.log('will show toast') modal.toast(&#123; message: 'This is a toast', duration: 0.3 &#125;) &#125;, showAlert (event) &#123; console.log('will show alert') modal.alert(&#123; message: 'This is a alert', duration: 0.3 &#125;, function (value) &#123; console.log('alert callback', value) &#125;) &#125;, showConfirm (event) &#123; console.log('will show confirm') modal.confirm(&#123; message: 'Do you confirm ?', duration: 0.3 &#125;, function (value) &#123; console.log('confirm callback', value) &#125;) &#125;, showPrompt (event) &#123; console.log('will show prompt') modal.prompt(&#123; message: 'This is a prompt', duration: 0.3 &#125;, function (value) &#123; console.log('prompt callback', value) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"navigator","path":"references/modules/navigator.html","permalink":"https://weex.apache.org/references/modules/navigator.html","text":"Navigator#v0.6.1+ As it’s known to all that, we can navigate back and forth in the web browser using the navigation bar.And The navigator module mimics the same behaviors in the iOS/Android application. Without such an ability, We will have to stay in the same page forever, so it is very important. Besides the navigation, the module can let us to specify whether to apply animation or not during the transition. API#push(options, callback)#push a weex page onto the navigator stack, you can specify whether apply animation when pushing. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. url(stirng): The URL of the weex page to push. animated(string): true, if the weex page is push through animation, otherwise, false. Default value is true. callback(object): the callback function to be called after executing this action. pop(options, callback)#pop a weex page onto the navigator stack, you can specify whether apply animation when popping. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. animated(string): true if the weex page is pop through animation; otherwise, false. Default value is true. callback(object): the callback function after executing this action. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"jump\"&gt;Jump&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal') export default &#123; methods: &#123; jump (event) &#123; console.log('will jump') navigator.push(&#123; url: 'http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js', animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"picker","path":"references/modules/picker.html","permalink":"https://weex.apache.org/references/modules/picker.html","text":"picker#v0.9+ Summary#A series of stream api. It provides function: pick data,pick date,pick time API#pick(options, callback[options])#pick data(single column) Arguments# options {Object}:pick options index {number}:default selected row items {array}:picker’s data callback {function (ret)}:the callback function after executing this action.ret {Object} is callback ‘s parameter: result {string}:result is one of success,cancel,error data {number}:the selected index,it exists when result is success. pickDate(options, callback[options])#pick date Arguments# options {Object}:pick date options value {string}:Required，date picker selected value by default，date’s form is yyyy-MM-dd max {string}:optional，date’s max value min {string}:optional，date’s min value callback {function (ret)}：the callback function after executing this action.ret {Object} is callback ‘s parameter: result {string}:result is one of success,cancel,error data {string}:the selected value，the form of data is yyyy-MM-dd ,it exists when result is success. pickTime(options, callback[options])#pick time Arguments# options {Object}:pick time options value {string}:required，the form of value is HH:mm callback {function (ret)}:the callback function after executing this action.ret {Object} is callback ‘s parameter： result {string}:result is one of success,cancel,error data {string}:the selected value，the form of data is HH:mm,it exists when result is success. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"label\"&gt;Time: &lt;/text&gt; &lt;text class=\"title\"&gt;&#123;&#123;value&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"pickTime\"&gt;Pick Time&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const picker = weex.requireModule('picker') export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; align-items: center; &#125; .label &#123; font-size: 40px; color: #888888; &#125; .title &#123; font-size: 80px; color: #41B883; &#125; .button &#123; font-size: 36px; width: 280px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;","type":"references"},{"title":"storage","path":"references/modules/storage.html","permalink":"https://weex.apache.org/references/modules/storage.html","text":"storage#v0.7+ Summary#storage is a series of apis, allowing you to for example add, modify or delete stored data items. API#setItem(key, value, callback)#When passed a key name and value, will add that key to the storage,or update that key’s value if it already exists. Arguments# key(string): the name of the key you want to store. “” or null is not allowed. value(string): the name of the value you want to store.”” or null is not allowed. callback(object): the callback function after executing this action. getItem(key, callback)#When passed a key name, will return that key’s value. Arguments# key(string): the name of the key you want to retrieve the value of.”” or null is not allowed. callback(object): the callback function after executing this action. removeItem(key, callback)#When passed a key name, will remove that key from the storage. Arguments# key(string): the name of the key you want to remove.”” or null is not allowed. callback(object): the callback function after executing this action. Example#var storage = weex.requireModule('storage');storage.removeItem('foo', function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. // e.result will return 'success' or 'failed' according to the executing result. // e.data will always return 'undefined' in this function if success.&#125;); length(callback)#Returns an integer representing the number of data items stored in the Storage object. Arguments# callback(object): the callback function after executing this action. getAllKeys(callback)#Returns an array that contains all keys stored in Storage object. Arguments# callback(object): the callback function after executing this action. Example#&lt;template&gt; &lt;div class=\"list\"&gt; &lt;div class=\"group center\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\"&gt;&#123;&#123;state&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"setItem\"&gt;set&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getItem\"&gt;get&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"removeItem\"&gt;remove&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getAll\"&gt;all&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const storage = weex.requireModule('storage') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; keys: '[]', length: 0, state: '----' &#125; &#125;, methods: &#123; setItem () &#123; storage.setItem('name', 'Hanks', event =&gt; &#123; this.state = 'set success' console.log('set success') &#125;) &#125;, getItem () &#123; storage.getItem('name', event =&gt; &#123; console.log('get value:', event.data) this.state = 'value: ' + event.data &#125;) &#125;, removeItem () &#123; storage.removeItem('name', event =&gt; &#123; console.log('delete value:', event.data) this.state = 'deleted' &#125;) &#125;, getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === 'success') &#123; modal.toast(&#123; message: 'props: ' + event.data.join(', ') &#125;) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; height: 100px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .group &#123; flex-direction: row; justify-content: space-between; width: 650px; margin-left: 50px; margin-top: 50px; margin-bottom: 50px; &#125; .center &#123; justify-content: center; &#125; .text &#123; font-size: 50px; text-align: center; padding-left: 25px; padding-right: 25px; color: #41B883; &#125; .small &#123; font-size: 32px; padding-left: 35px; padding-right: 35px; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"stream","path":"references/modules/stream.html","permalink":"https://weex.apache.org/references/modules/stream.html","text":"stream#A series of stream api. It provides a network request. API#fetch(options, callback,progressCallback)#Start a network request, use two callbacks to receive server’s response data. Arguments options(object): the request options, key value style dictionary. method(string): the HTTP method GET or POST. url(string): the request url. headers(string): the HTTP request headers. type(string): response type, ‘json’,’text’ or ‘jsonp’(same as ‘json’ in native implementation) body(string): the HTTP body. callback(function): A callback function whose argument is the response object of the request. Callback function will receive a response object. status(number): response status code. ok(boolean): true if status code is bewteen 200～299. statusText(string): status text data(string): response data. It’s a object if request option is json/jsonp, or (string) in other type value. headers(object): response headers progressCallback(function): A progress callback. This callback will be invoked before request finished. readyState(number): Current request state.’1’:request connection opened;’2’:response headers received.;’3’:response data is loading; status(number): response status code. length(number): bytes of data have received. You can read full length of response from ‘headers’. statusText(string): status text. headers(object): response headers. Note# Default Content-Type is ‘application/x-www-form-urlencoded’. (The type specified in fetch is the response type!) You need to set the Content-Type header to ‘application/json’ manually if you want to post the json body. Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"title\"&gt;Weex Star :&lt;/text&gt; &lt;text class=\"count\"&gt;&#123;&#123;weexStar&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"title\"&gt;Vue Star :&lt;/text&gt; &lt;text class=\"count\"&gt;&#123;&#123;vueStar&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var stream = weex.requireModule('stream') export default &#123; data () &#123; return &#123; weexStar: 'unknown', vueStar: 'unknown' &#125; &#125;, methods: &#123; getStarCount (repo, callback) &#123; return stream.fetch(&#123; method: 'GET', type: 'json', url: 'https://api.github.com/repos/' + repo &#125;, callback) &#125; &#125;, created () &#123; this.getStarCount('alibaba/weex', res =&gt; &#123; this.weexStar = res.ok ? res.data.stargazers_count : '(network error)' &#125;) this.getStarCount('vuejs/vue', res =&gt; &#123; this.vueStar = res.ok ? res.data.stargazers_count : '(network error)' &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; &#125; .title &#123; font-size: 45px; color: #888888; &#125; .count &#123; font-size: 45px; font-weight: bold; margin-left: 12px; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"WebSocket","path":"references/modules/websocket.html","permalink":"https://weex.apache.org/references/modules/websocket.html","text":"WebSocket#v0.12+ Summary#WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user’s H5/iOS/android and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply Notes:# iOS and h5 provide webSocket default handle. if you use webSocket in android environment . you should provide custom adapter implementation,source: DefaultWebSocketAdapter.java; DefaultWebSocketAdapterFactory.java; refer: weex playground API#WebSocket(url, protocol)#create websocket Arguments# url {string}:The URL to which to connect; protocol {string}:the websocket protocol send(data)#Transmits data to the server over the WebSocket connection Arguments# data {string}:A text string to send to the server. close(code,reason)#Closes the WebSocket connection or connection attempt, if any. If the connection is already CLOSED, this method does nothing. Arguments# code {number}: the status code explaining why the connection is being closed. reason {string}:a string explaining why the connection is closing onopen(options)#An event listener to be called when the WebSocket connection’s readyState changes to OPEN; this indicates that the connection is ready to send and receive data. Arguments# options {object}:an empty object onmessage(options)#An event listener to be called when a message is received from the server Arguments# options {object}:the server message options data {string}: The listener received message onclose(options)#An event listener to be called when the WebSocket connection’s readyState changes to CLOSED Arguments# options {object}:the CloseEvent is sent to clients using WebSockets when the connection is closed code {number}: Returns an unsigned short containing the close code send by the server reason {string}: Returns a string indicating the reason the server closed the connection wasClean {boolen}: Returns a Boolean that Indicates whether or not the connection was cleanly closed. onerror(options)#An event listener to be called when an error occurs. Arguments# options {object}:the error event data {string}: The listener received error data Example#&lt;template&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: white\"&gt;websocket&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input message to send\" class=\"input\" autofocus=\"false\" value=\"\" @change=\"onchange\" @input=\"oninput\" ref=\"input\"/&gt; &lt;div style=\"flex-direction: row; justify-content: center;\"&gt; &lt;text class=\"button\" @click=\"connect\"&gt;connect&lt;/text&gt; &lt;text class=\"button\" @click=\"send\"&gt;send&lt;/text&gt; &lt;text class=\"button\" @click=\"close\"&gt;close&lt;/text&gt; &lt;/div&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = send&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;sendinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onopen&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onopeninfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onmessage&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 400px\"&gt;&#123;&#123;onmessage&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onclose&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;oncloseinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onerror&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onerrorinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = close&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;closeinfo&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 40px; height: 80px; width: 600px; &#125; .button &#123; font-size: 36px; width: 150px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; margin-right: 20px; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; var websocket = weex.requireModule('webSocket') export default &#123; data () &#123; return &#123; connectinfo: '', sendinfo: '', onopeninfo: '', onmessage: '', oncloseinfo: '', onerrorinfo: '', closeinfo: '', txtInput:'', navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '' &#125; &#125;, methods: &#123; connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e) &#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e) &#123; self.onmessage = e.data; &#125; websocket.onerror = function(e) &#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e) &#123; self.onopeninfo = ''; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;, close:function(e) &#123; websocket.close(); &#125;, &#125;, &#125;&lt;/script&gt; Have a try","type":"references"},{"title":"webview","path":"references/modules/webview.html","permalink":"https://weex.apache.org/references/modules/webview.html","text":"webview#A series of web operation api like goBack, goForward, and reload. ‘webview’ module used with the web component. API#goBack(webElement)#Loads the previous location in the history stack. Arguments webElement(web): the element of the web component. Example#var webview = weex.requireModule(&apos;webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.goBack(webElement); goForward(webElement)#Loads the next location in the history stack. Arguments webElement(web): the element of the web component. Example#var webview = weex.requireModule(&apos;webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.goForward(webElement); reload(webElement)#Reloads the current web page. Arguments webElement(web): the element of the web component. Example#var webview = weex.requireModule(&apos;webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.reload(webElement.ref); Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;input class=\"input\" v-model=\"value\" ref=\"input\" type=\"url\" autofocus=\"false\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"button\" @click=\"reload\"&gt;reload&lt;/text&gt; &lt;/div&gt; &lt;web ref=\"webview\" :src=\"url\" class=\"webview\" @pagestart=\"start\" @pagefinish=\"finish\" @error=\"error\"&gt;&lt;/web&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const webview = weex.requireModule('webview') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; url : 'https://m.alibaba.com', value: 'https://m.alibaba.com' &#125; &#125;, methods: &#123; loadURL (event) &#123; this.url = this.value modal.toast(&#123; message: 'load url:' + this.url &#125;) setTimeout(() =&gt; &#123; console.log('will go back.') modal.toast(&#123; message: 'will go back' &#125;) webview.goBack(this.$refs.webview) &#125;, 10000) &#125;, reload (event) &#123; console.log('will reload webview') modal.toast(&#123; message: 'reload' &#125;) webview.reload(this.$refs.webview) &#125;, start (event) &#123; console.log('pagestart', event) modal.toast(&#123; message: 'pagestart' &#125;) &#125;, finish (event) &#123; console.log('pagefinish', event) modal.toast(&#123; message: 'pagefinish' &#125;) &#125;, error (event) &#123; console.log('error', event) modal.toast(&#123; message: 'error' &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .group &#123; flex-direction: row; justify-content: space-around; margin-top: 20px; &#125; .input &#123; width: 600px; font-size: 36px; padding-top: 15px; padding-bottom: 15px; border-width: 2px; border-style: solid; border-color: #BBBBBB; &#125; .button &#123; width: 225px; text-align: center; background-color: #D3D3D3; padding-top: 15px; padding-bottom: 15px; margin-bottom: 30px; font-size: 30px; &#125; .webview &#123; margin-left: 75px; width: 600px; height: 750px; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"构建完整移动应用","path":"cn/guide/advanced/app-architecture.html","permalink":"https://weex.apache.org/cn/guide/advanced/app-architecture.html","text":"用 Weex 构建移动应用#今天的移动应用#这里谈一谈 Weex 对移动应用的理解。 移动应用需要支撑并行研发#如今移动应用的开发需要并行研发的能力，当一个移动应用发展到一定规模的时候，能否支撑大规模的并行研发就成为了一件非常关键而又重要的事情。否则很容易变成工程瓶颈。 移动应用需要动态性#如今移动应用不论从研发节奏、部署的灵活性和时效性、包大小、还是从研发到发布再到反馈的迭代周期上，都和移动互联网的发展速度极不相符。移动应用需要更简单轻量的研发模型，需要摆脱版本部署和分发的笨重过程。 移动应用需要开放互联#如今移动应用的内容和信息都是相互孤立的，应用之间的交流变得非常复杂和困难，也缺乏一定的标准和规范化的容器来承载。 整体结构设计#我们认为一个具有高并行研发能力、动态化和标准化规范化的移动应用应该由以下几个方面构成： |------|------|------|------| |-----|| page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||------|------|------|------| | api || page | page | page | page | | api ||---------------------------| | api || router | | api ||---------------------------| |-----| 页面：首先移动应用应该可以被拆解成若干个页面，每个页面相对解耦独立，同时每个页面都有一个 URL 进行唯一标识。 路由：这些页面将会通过路由机制有机的串联起来，页面之间的关系是通过路由来进行调度的。常见的移动应用路由包括导航栏、tab 切换等。 设备能力：以各种 API 或服务的方式提供出来，供页面自由使用。 这样的话，在构建一个完整的移动应用之前，先确定你的应用有多少页面，每个页面分别是什么 URL，页面之间的关联和跳转逻辑是怎样的，然后梳理整个移动应用需要的所有 API 和服务。 然后通过 Weex 创建不同的页面，并分别进行开发、调试和发布。 相关链接 页面结构 如果你已经有一个做好的移动应用，只想用 Weex 开发其中的一部分页面甚至仅仅其中的一两个页面，这对 Weex 来说完全不是问题。Weex 只是一个 SDK，对整体的移动应用架构不会产生任何侵入性。并且完全可以和纯 native 界面或 hybrid 页面共存。 如果需要 WeexSDK 额外的组件、模块或其它功能，可以通过 Weex 的扩展机制进行扩展。这部分工作需要 native 的研发知识，但是随着 Weex 组件和模块的丰富以及业务迭代的深入，这部分成本会承下降和收敛的趋势。 相关链接 如何扩展 iOS 如何扩展 Android","type":"guide"},{"title":"降级方案","path":"cn/guide/advanced/downgrade.html","permalink":"https://weex.apache.org/cn/guide/advanced/downgrade.html","text":"降级方案#Weex 2.0 降级方案改成模块的形式支持，具体请参考downgrade","type":"guide"},{"title":"Weex 页面结构","path":"cn/guide/advanced/page-architecture.html","permalink":"https://weex.apache.org/cn/guide/advanced/page-architecture.html","text":"Weex 页面结构#一个 Weex 页面就是一个相对独立解耦的移动应用界面，它不仅包括了界面展示、更包含了逻辑处理、设备能力使用、生命周期管理等部分。 界面#DOM 模型#Weex 页面通过类似 HTML DOM 的方式管理界面，首先页面会被分解为一个 DOM 树，，每个 DOM 结点都代表了一个相对独立的 native 视图的单元。然后不同的视图单元之间通过树形结构组合在了一起，构成一个完整的页面。 相关链接 Weex Native DOM APIs 组件#Weex 支持文字、图片、视频等内容型组件，也支持 div、list、scroller 等容器型组件，还包括 slider、input、textarea、switch 等多种特殊的组件。Weex 的界面就是由这些组件以 DOM 树的方式构建出来的。 相关链接 Weex 组件列表 布局系统#Weex 页面中的组件会按照一定的布局规范来进行排布，我们这里提供了 CSS 中的盒模型、flexbox 和 绝对/相对/固定/吸附布局这三大块布局模型。 盒模型：通过宽、高、边框、内外边距、边框等 CSS 属性描述一个组件本身的尺寸。 flexbox：通过 CSS 3 Flexbox 布局规范定义和描述组件之间的空间分布情况。 position：支持 CSS position 属性中的 absolute, relative, fixed, sticky 位置类型，其中 relative 是默认值。 功能#Weex 提供了非常丰富的系统功能 API，包括弹出存储、网络、导航、弹对话框和 toast 等，开发者可以在 Weex 页面通过获取一个 native module 的方式引入并调用这些客户端功能 API。 相关链接 Weex 模块列表 生命周期#每个 Weex 页面都有其自身的生命周期，页面从开始被创建到最后被销毁，会经历到整个过程。这是通过对 Weex 页面的创建和销毁，在路由中通过 SDK 自行定义并实现的。","type":"guide"},{"title":"资源路径","path":"cn/guide/advanced/path.html","permalink":"https://weex.apache.org/cn/guide/advanced/path.html","text":"Path#v0.9+ 本文将介绍 Weex 中 uri(url) 的用法。包括使用图像、字体等资源，处理相对路径以及如何访问本地及打包的资源文件。 Schemes# 本地资源 Weex SDK 提供 local scheme 来访问打包在应用程序中的资源，此 scheme 无法在 H5 环境下使用。目前，开发者可以在 image 组件和字体文件中使用本地资源。 在 iOS 中，Weex 会在 bundle resources 中查找。例如，image 组件的 src 属性为 local:///app_icon&#39;， Weex 会加载 bundle resouce 中名为 app_icon 的图像资源，而字体文件也以相同的方式工作。 在 Android 中，image 组件将从 drawable 资源文件夹加载，如 res/drawable-xxx。但加载字体文件是不同的，Android 框架无法从 res 加载字体文件，因此 SDK 将从 asserts 文件夹加载它。 HTTP/HTTPS 它的工作方式与 web 相同，Weex 一直支持这种方式。 File 使用 file scheme 访问本地磁盘文件。这个方案有其局限性：你不应该在源页面中硬编码文件 url。因为不管它是否在不同的平台（iOS，Android）上运行，内容将在另一个设备上完全不同，这取决于具体的设备。 所以一种可行的方案是在运行时动态获取文件 url，你可以使用它来显示本地磁盘的图像，或者稍后上传它。 相对路径#与我们在 HTML 中的用法类似，Weex 以相同的方式处理相对路径。以/、.、..、// 开头的相对 URI 将相对于 bunle url 解析。 这意味着， 一个以 / 开头的路径将是相对于 JS Bundle 文件的根文件夹。. 则是当前文件夹，.. 是父文件夹。 // 则被解析为与 JS Bundle 相同的 scheme。 URI Adapter#以上所有是默认实现，开发者可以通过提供一个 URI Adapter 来扩展或覆盖默认实现。与其他 Adapter 相同，应在 Weex SDK 初始化之前设置自定义 Adapter。","type":"guide"},{"title":"使用 Vuex 和 vue-router","path":"cn/guide/advanced/use-vuex-and-vue-router.html","permalink":"https://weex.apache.org/cn/guide/advanced/use-vuex-and-vue-router.html","text":"使用 Vuex 和 vue-router#Vue.js 也有较多周边技术产品，如 Vuex 和 vue-router 等，这些库也可以在 Weex 中很好的工作。 我们基于 Weex 和 Vue 开发了一个的完整项目 weex-hackernews ，在项目中使用了 Vuex 和 vue-router ，能够实现同一份代码，在 iOS、Android、Web 下都能完整地工作。 使用 Vuex# Vuex 是一个专为 Vue.js 应用程序开发的状态管理工具库，可以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 由于在 Vuex 本身就是平台无关的，有较强的移植能力，完全可以在 Weex 中正常地使用 Vuex ，阅读其官方文档可以了解详细的使用方法。 Vuex 也集成到了其官方调试工具 devtools extension中，提供了诸如 time-travel 调试、状态快照导入导出等高级调试功能。这些工具在 Web 平台中可以一如既往地工作。 使用 vue-router#vue-router 是专为 Vue.js 开发的便于实现单页应用的工具库，能够以声明式的方法编写页面的导航和跳转信息。 由于 Weex 的运行环境不只是浏览器，通常是以移动端原生环境为主，然而在 Android 和 iOS 中都没有浏览器的 History API，也不存在 DOM，因此如果想在 Weex 环境中使用 vue-router ，有些功能受到了限制，使用时应该注意。 路由模式#vue-router 提供了三种运行模式： hash: 使用 URL hash 值来作路由。默认模式。 history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。 配置方法是在定义路由时，传递 mode 属性： new Router(&#123; mode: 'abstract', // ...&#125;) 从三种模式的介绍中也可以看出来，Weex 环境中只支持使用 abstract 模式。不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以在使用时只要不写 mode 配置即可。默认 vue-router 会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 编程式导航#vue-router 中使用 &lt;router-link&gt; 创建导航链接，不过在其中使用了基于 DOM 事件的一些特性，在 Weex 原生环境中并不能很好的工作。在 Weex 中，你必须使用编程式导航来编写页面跳转逻辑。 编程式导航其实就是通过主动调用 router 实例上的 push 方法实现跳转。 使用 &lt;router-link&gt; 的代码示例： &lt;!-- 只能在 Web 中使用，Native 环境不支持！ --&gt;&lt;template&gt; &lt;div&gt; &lt;router-link to=\"profile\"&gt; &lt;text&gt;Profile&lt;/text&gt; &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 在 Weex 中，需要写成这个样子： &lt;template&gt; &lt;div&gt; &lt;text @click=\"jump\"&gt;Profile&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import router from './path/to/router' export default &#123; methods: &#123; jump () &#123; router.push('profile') &#125; &#125; &#125;&lt;/script&gt;","type":"guide"},{"title":"<a>","path":"cn/references/components/a.html","permalink":"https://weex.apache.org/cn/references/components/a.html","text":"&lt;a&gt;#&lt;a&gt; 组件定义了指向某个页面的一个超链接. 此组件的作用和用法与HTML5中的 &lt;a&gt; 非常类似，区别在于 Weex 的 &lt;a&gt; 组件不能直接在里面添加文本（字符串），如果要展示文本，应该添加 &lt;text&gt; 组件。 子组件#此组件支持除了自己外的所有 Weex 组件作为子组件。 特性# href {string}：定义了超链接的 URL。 样式#&lt;a&gt; 支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式。 事件#&lt;a&gt; 支持所有通用事件。 click注意：我们不能保证 click 事件和 href 跳转的执行顺序。建议不要使用 click 事件来处理 href 跳转前的逻辑处理。 longpress appear disappear 查看 通用事件。 约束# 不能直接在 &lt;a&gt; 中添加文本。 请不要为 &lt;a&gt; 添加 click 事件。我们不能确保 click 事件和 href 跳转的执行顺序。 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;a class=\"button\" href=\"http://dotwe.org/raw/dist/3e0e40f9ddad79f98cd236753965ffd8.js\"&gt; &lt;text class=\"text\"&gt;Jump&lt;/text&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; width: 450px; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5 &#125; .text &#123; font-size: 60px; color: #666666; text-align: center; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<div>","path":"cn/references/components/div.html","permalink":"https://weex.apache.org/cn/references/components/div.html","text":"&lt;div&gt;#&lt;div&gt; 组件是用于包装其它组件的最基本容器。支持所有的通用样式、特性、flexbox 布局。其类似于 HTML 的 &lt;div&gt; 容器，但不能直接在里面添加文本（字符串），如果要展示文本，应该使用 &lt;text&gt; 组件。历史版本中，&lt;div&gt; 别名是 &lt;container&gt;，目前已经弃用。 注意： &lt;div&gt; 嵌套层级不可过深，否则容易引起性能问题，建议控制在 10 层以内。 一个简单例子： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\"&gt;Hello World!&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70px; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 子组件#&lt;div&gt; 基本容器组件，因此支持包括 &lt;div&gt; 在内的任何组件作为自己的子组件。因此，在写一个组件时，推荐外层使用 &lt;div&gt; 作为根容器。 样式#&lt;div&gt; 支持所有通用样式： 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件#&lt;div&gt; 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束# 不能直接在 &lt;div&gt; 中添加文本。 错误示例，“Hello World!” 无法被正常渲染。 &lt;template&gt; &lt;div&gt;Hello World!&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 &lt;div&gt; 在 native 中不可滚动，即使显式设置高度也一样。 错误示例 示例#&lt;template&gt; &lt;div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box &#123; border-width: 2px; border-style: solid; border-color: #BBB; width: 250px; height: 250px; margin-top: 250px; margin-left: 250px; background-color: #EEE; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<cell>","path":"cn/references/components/cell.html","permalink":"https://weex.apache.org/cn/references/components/cell.html","text":"&lt;cell&gt;#用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能，该组件必须作为&lt;list&gt; 组件的子组件, 这是为了优化滚动时的性能。 子组件#支持所有 Weex 的组件作为它的子组件。 属性# keep-scroll-position {boolean}: v0.11+ List 插入数据后是否保持上次滚动的位置 样式#注意： 由于 &lt;cell&gt; 本身是一个容器，其布局由 &lt;list&gt; 进行管理，你不能给 &lt;cell&gt; 设定flex值。 &lt;cell&gt;的宽度等于父组件 &lt;list&gt; 的宽度，并且 &lt;cell&gt; 高度自适应，指定 margin 样式也不起作用。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例#&lt;template&gt; &lt;list class=\"list\" @loadmore=\"fetch\" loadmoreoffset=\"10\"&gt; &lt;cell class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; fetch (event) &#123; modal.toast(&#123; message: 'loadmore', duration: 1 &#125;) setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; &#125;, 800) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<indicator>","path":"cn/references/components/indicator.html","permalink":"https://weex.apache.org/cn/references/components/indicator.html","text":"&lt;indicator&gt;#&lt;indicator&gt; 组件用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 子组件#&lt;indicator&gt; 组件没有任何子组件。 样式#&lt;indicator&gt; 组件有一些私有样式，如下： item-color {color}：设置项的颜色，可以是颜色的名称，例如 red；也可以是 16 进制的颜色，例如 #RRGGBB。 item-selected-color {color}：被选中时的颜色，可以是颜色的名称，red；也可以是 16 进制的颜色，例如 #RRGGBB。 item-size {number}：元素的个数。 通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 注意 1： 这里需要注意一点，&lt;indicator&gt; 的 position 不仅依赖 top、left、bottom 和 right 样式，同时会参考 width和 height 样式。&lt;indicator&gt; 默认的宽高继承于 &lt;slider&gt;，如果 &lt;slider&gt; 未设置宽高，需要显式的给 &lt;indicator&gt; 设置宽高值。 注意 2： background-color 不推荐使用，建议使用 item-color 和 item-selected-color 代替。 事件#支持所有通用事件。 click longpress appear disappear 查看 通用事件 约束# 不支持子组件。 示例#&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"4500\" @change=\"onchange\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;img.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .title &#123; position: absolute; top: 20px; left: 20px; padding-left: 20px; width: 200px; color: #FFFFFF; font-size: 36px; line-height: 60px; background-color: rgba(0, 0, 0, 0.3); &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125; .indicator &#123; width: 700px; height: 700px; item-color: green; item-selected-color: red; item-size: 50px; position: absolute; top: 200px; left: 200px; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; title: 'item A', src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; title: 'item B', src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; title: 'item C', src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;, methods: &#123; onchange (event) &#123; console.log('changed:', event.index) &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<image>","path":"cn/references/components/image.html","permalink":"https://weex.apache.org/cn/references/components/image.html","text":"&lt;image&gt;#&lt;image&gt; 组件用于渲染图片，并且它不能包含任何子组件。新版 Vue 2.0 中不支持用 &lt;img&gt; 作简写。 需要注意的是，需要明确指定 width 和 height，否则图片无法显示。 简单例子： &lt;template&gt; &lt;div&gt; &lt;image style=\"width: 560px;height: 560px;\" src=\"https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; 体验一下 子组件#&lt;image&gt; 组件不支持任何子组件，因此不要尝试在 &lt;image&gt; 组件中添加任何组件。如果需要实现 background-image 的效果，可以使用 &lt;image&gt; 组件和 position 定位来现实，如下面代码。 &lt;template&gt; &lt;div&gt; &lt;image style=\"width:750px; height:750px;\" src=\"https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg\"&gt;&lt;/image&gt; &lt;div class=\"title\"&gt; &lt;text style=\"font-size:50px; color: #ff0000\"&gt;你好，image&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .title&#123; position:absolute; top:50; left:10; &#125;&lt;/style&gt; 体验一下 特性#&lt;image&gt; 组件，包含 src 和 resize 两个重要特性。 src {string}：定义图片链接，目前图片暂不支持本地图片。 resize {string}：可以控制图片的拉伸状态，值行为和 W3C 标准一致。 可选值为： stretch：默认值，指定图片按照容器拉伸，有可能使图片产生形变。 cover：指定图片可以被调整到容器，以使图片完全覆盖背景区域，图片有可能被剪裁。 contain：指定可以不用考虑容器的大小，把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 例子： placeholder: v0.9+ &lt;string&gt; 当源图片下载中时显示一张占位图。 体验一下 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# load: v0.8+：当图片加载完成时触发。目前在 Android、iOS 上支持，H5 暂不支持。示例 事件对象 success: 当图片成功加载时为true，否则为false size: 图片的原始尺寸，包含两个参数：naturalWidth 代表图片的原始宽度像素值，naturalHeight 代表图片的原始高度值。这两个参数的默认值都为0 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 组件方法# v0.16.0+ save：保存当前图片到本地 参数回调函数作为方法入参，接收保存结果. var image = this.$refs.imageRef; // image 是之前已经定义过的ref image.save(function(result) &#123; console.log(JSON.stringify(result))&#125;); 异步返回的数据描述 &#123; &quot;success&quot; : true/false, // 保存成功或失败 &quot;errorDesc&quot;: &quot;errordesc&quot; // 在success 为false的情况会返回 &#125; 说明对于 iOS 系统需要添加 NSPhotoLibraryAddUsageDescription相册访问权限, iOS 11 需要再添加一个NSPhotoLibraryAddUsageDescription权限, 查看更多iOS系统权限 试一试 约束# 需要指定宽高； 不支持子组件。 示例#&lt;template&gt; &lt;scroller class=\"wrapper\" &gt; &lt;div class=\"page-head\" &gt; &lt;image class=\"title-bg\" resize=\"cover\" src=\"https://img.alicdn.com/tps/TB1dX5NOFXXXXc6XFXXXXXXXXXX-750-202.png\"&gt;&lt;/image&gt; &lt;div class=\"title-box\"&gt; &lt;text class=\"title\"&gt;Alan Mathison Turing&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"article\"&gt; &lt;text class=\"paragraph\"&gt;Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;During the Second World War, Turing worked for the Government Code and Cypher School (GC&amp;CS) at Bletchley Park, Britain's codebreaking centre. For a time he led Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for speeding the breaking of German ciphers, including improvements to the pre-war Polish bombe method, an electromechanical machine that could find settings for the Enigma machine. Turing played a pivotal role in cracking intercepted coded messages that enabled the Allies to defeat the Nazis in many crucial engagements, including the Battle of the Atlantic; it has been estimated that this work shortened the war in Europe by more than two years and saved over fourteen million lives.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;After the war, he worked at the National Physical Laboratory, where he designed the ACE, among the first designs for a stored-program computer. In 1948 Turing joined Max Newman's Computing Machine Laboratory at the Victoria University of Manchester, where he helped develop the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov–Zhabotinsky reaction, first observed in the 1960s.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;Turing was prosecuted in 1952 for homosexual acts, when by the Labouchere Amendment, \"gross indecency\" was still criminal in the UK. He accepted chemical castration treatment, with DES, as an alternative to prison. Turing died in 1954, 16 days before his 42nd birthday, from cyanide poisoning. An inquest determined his death as suicide, but it has been noted that the known evidence is also consistent with accidental poisoning. In 2009, following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for \"the appalling way he was treated.\" Queen Elizabeth II granted him a posthumous pardon in 2013.&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .page-head &#123; width: 750px; height: 200px; &#125; .title-bg &#123; width: 750px; height: 200px; &#125; .title-box &#123; width: 750px; height: 200px; justify-content: center; align-items: center; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125; .title &#123; color: #ffffff; font-size: 32px; font-weight: bold; &#125; .article &#123; padding: 20px; &#125; .paragraph&#123; margin-bottom: 15px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<list>","path":"cn/references/components/list.html","permalink":"https://weex.apache.org/cn/references/components/list.html","text":"&lt;list&gt;#&lt;list&gt; 组件是提供垂直列表功能的核心组件，拥有平滑的滚动和高效的内存管理，非常适合用于长列表的展示。最简单的使用方法是在 &lt;list&gt; 标签内使用一组由简单数组 repeat 生成的 &lt;cell&gt; 标签填充。 子组件#&lt;list&gt; 组件支持更多高级功能，由以下子组件提供： &lt;cell&gt; 用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能。 使用文档请查看 &lt;cell&gt;。 header 0.6.1+ 当 &lt;header&gt; 到达屏幕顶部时，吸附在屏幕顶部。 &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 注意： &lt;list&gt; 的子组件只能包括以上四种组件或是 fix 定位的组件，其他形式的组件将不能被正确的渲染。 特性# loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与 &lt;list&gt; 底部之间的距离）。当 &lt;list&gt; 的滚动条滚动到足够接近 &lt;list&gt; 底部时将会触发 loadmore 这个事件。 offset-accuracy {number} 0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 offset-accuracy：默认值是0，触发 scroll 事件所需要的垂直偏移距离。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# loadmore 0.5+：如果列表滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。 事件中 event 对象属性： contentSize {Object}：列表的内容尺寸 width {number}: 列表内容宽度 height {number}: 列表内容高度 contentOffset {Object}: 列表的偏移尺寸 x {number}: x轴上的偏移量 y {number}: y轴上的偏移量 体验一下 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展#scrollToElement(node, options)#滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 resetLoadmore() 0.9+#在默认情况下，触发loadmore事件后，如果列表中内容没有发生变更，则下一次滚动到列表末尾时将不会再次触发loadmore事件，你可以通过调用resetLoadmore()方法来打破这一限制，调用该方法后，下一次滚动到列表末尾时将强制触发loadmore。 参数# node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是 0 约束# 不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 list 或者 &lt;scroller&gt; 中的。 &lt;list&gt; 为根节点时无需设置高度，但是内嵌 &lt;list&gt; 高度必须可计算，你可以使用 flex 或 postion 将 &lt;list&gt; 设为一个响应式高度（例如全屏显示）, 也可以显式设置 &lt;list&gt; 组件的 height 样式。 示例#&lt;template&gt; &lt;list class=\"list\" @loadmore=\"fetch\" loadmoreoffset=\"10\"&gt; &lt;cell class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; fetch (event) &#123; modal.toast(&#123; message: 'loadmore', duration: 1 &#125;) setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; &#125;, 800) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<refresh>","path":"cn/references/components/refresh.html","permalink":"https://weex.apache.org/cn/references/components/refresh.html","text":"&lt;refresh&gt;#v0.6.1+ &lt;refresh&gt; 为 &lt;scroller&gt; 和 &lt;list&gt; 提供下拉加载功能。用法与特性与 &lt;loading&gt; 类似，&lt;scroller&gt; 和 &lt;list&gt; 的子组件，且只能在被 &lt;scroller&gt; 和 &lt;list&gt; 包含时才能被正确的渲染。 子组件# &lt;text&gt; &lt;image&gt; &lt;loading-indicator&gt;: &lt;refresh&gt; 和 &lt;loading&gt; 组件的子组件，拥有默认的动画效果的实现。 特性# display {string}：可选值为 show 或者 hide，仅隐藏 &lt;indicator&gt;，&lt;refresh&gt; 其他子组件依然可见，&lt;refresh&gt; 事件仍会被触发。 样式#支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# refresh： 当 &lt;scroller&gt;/&lt;list&gt; 被下拉时触发。 pullingdownv0.6.1+: 当 &lt;scroller&gt;/&lt;list&gt; 被下拉时触发，可以从事件的参数对象中获取 dy,pullingDistance, viewHeight, type dy: 前后两次回调滑动距离的差值pullingDistance: 下拉的距离viewHeight: refreshView 高度type: &quot;pullingdown&quot; 常数字符串 约束# &lt;refresh&gt; 不支持 remove，v0.9 版本会修复。 display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;refresh&gt; 其他子组件依然可见，refresh 事件仍会被触发。 如果需要 &lt;refresh&gt; hide 时隐藏文案并不再触发事件，有两种解决方法： 修改提示文案，并在 refresh 事件中添加判断逻辑； v0.9+ 可通过 remove 解决。 只能通过 display 特性进行展示和隐藏，且必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 示例#&lt;template&gt; &lt;scroller class=\"scroller\"&gt; &lt;refresh class=\"refresh\" @refresh=\"onrefresh\" @pullingdown=\"onpullingdown\" :display=\"refreshing ? 'show' : 'hide'\"&gt; &lt;text class=\"indicator\"&gt;Refreshing ...&lt;/text&gt; &lt;/refresh&gt; &lt;div class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; refreshing: false, lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; onrefresh (event) &#123; console.log('is refreshing') modal.toast(&#123; message: 'refresh', duration: 1 &#125;) this.refreshing = true setTimeout(() =&gt; &#123; this.refreshing = false &#125;, 2000) &#125;, onpullingdown (event) &#123; console.log('is onpulling down') modal.toast(&#123; message: 'pulling down', duration: 1 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .indicator &#123; color: #888888; font-size: 42px; text-align: center; &#125; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5; &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125;&lt;/style&gt; try it 更多示例可查看 &lt;list&gt;","type":"references"},{"title":"<input>","path":"cn/references/components/input.html","permalink":"https://weex.apache.org/cn/references/components/input.html","text":"&lt;input&gt;#Weex 内置的 &lt;input&gt; 组件用来创建接收用户输入字符的输入组件。 &lt;input&gt; 组件的工作方式因 type 属性的值而异，比如 &lt;text&gt;， password，url，email，tel 等。 注意： 此组件不支持 click 事件。请监听 &lt;input&gt; 或 change 来代替 click 事件。 子组件#不支持子组件。 特性# type {string}：控件的类型，默认值是 &lt;text&gt;。type 值可以是 text，password，url，email，tel ，number 。每个 type 值都符合 W3C 标准。 value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：布尔类型的数据，表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：布尔类型的数据，表示是否在页面加载时控件自动获得输入焦点。 maxlength {nubmer}：v0.7一个数值类型的值，表示输入的最大长度。 return-key-type {string}：v0.11键盘返回键的类型,支持 defalut;go;next;search;send,done。 样式# placeholder-color {color}：placeholder 字符颜色。默认值是 #999999 伪类v0.9.5+: input 支持以下伪类： active focus disabled enabled text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳,仅支持Android。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳,仅支持Android。 return: 键盘点击返回键。 事件中 event 对象属性： returnKeyType: 事件发生时的返回键类型。 value: 触发事件的组件的文本； 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 Methods# focus() v0.9+ focus() 方法用于将 input 组件聚焦。 blur() v0.9+ blur() 方法用于从 input 组件中移除焦点并关闭软键盘（如果它具有焦点）。 setSelectionRange(selectionStart,selectionEnd) v0.11+设置文本选区 selectionStart {number}：设置文本选区的起始点 selectionEnd {number}：设置文本选区的起终点 getEditSelectionRange(callback[selectionStart,selectionEnd]) v0.11+设置文本选区 selectionStart {number}：获取文本选区的起始点 selectionEnd {number}：获取文本选区的起终点约束# 目前不支持 this.$el(id).value = &#39;&#39; 这种方式改写 input value。只支持在 &lt;input&gt; 组件的 input、change 事件中改写。 示例#&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text style=\"font-size: 40px\"&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;onreturntype: &#123;&#123;txtReturnType&#125;&#125;&lt;/text&gt; &lt;text style=\"font-size: 40px\"&gt;selection: &#123;&#123;txtSelection&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = text&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input Text\" class=\"input\" :autofocus=true value=\"\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = password&lt;/text&gt; &lt;/div&gt; &lt;input type=\"password\" placeholder=\"Input Password\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = url&lt;/text&gt; &lt;/div&gt; &lt;input type=\"url\" placeholder=\"Input URL\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = email&lt;/text&gt; &lt;/div&gt; &lt;input type=\"email\" placeholder=\"Input Email\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = tel&lt;/text&gt; &lt;/div&gt; &lt;input type=\"tel\" placeholder=\"Input Tel\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = time&lt;/text&gt; &lt;/div&gt; &lt;input type=\"time\" placeholder=\"Input Time\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = number&lt;/text&gt; &lt;/div&gt; &lt;input type=\"number\" placeholder=\"Input number\" class=\"input\" @change=\"onchange\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input type = date&lt;/text&gt; &lt;/div&gt; &lt;input type=\"date\" placeholder=\"Input Date\" class=\"input\" @change=\"onchange\" @input=\"oninput\" max=\"2017-12-12\" min=\"2015-01-01\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = default&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"default\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = go&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"go\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = next&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"next\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = search&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"search\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = send&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"send\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input return-key-type = done&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input\" return-key-type=\"done\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;function focus() &amp; blur()&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"Focus\" type=\"primary\" @click=\"focus\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"Blur\" type=\"primary\" @click=\"blur\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"Input1\" class=\"input\" value=\"\" ref=\"input1\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80 ;padding: 20;color: #FFFFFF\"&gt;input selection&lt;/text&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row;margin-bottom: 16px;justify-content: space-between\"&gt; &lt;text class=\"button\" value=\"setRange\" type=\"primary\" @click=\"setRange\"&gt;&lt;/text&gt; &lt;text class=\"button\" value=\"getSelectionRange\" type=\"primary\" @click=\"getSelectionRange\"&gt;&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" ref=\"inputselection\" placeholder=\"please input\" value=\"123456789\" class=\"input\" @change=\"onchange\" @return = \"onreturn\" @input=\"oninput\"/&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 60px; height: 80px; width: 750px; &#125; .button &#123; font-size: 36; width: 200; color: #41B883; text-align: center; padding-top: 10; padding-bottom: 10; border-width: 2; border-style: solid; margin-right: 20; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; txtInput: '', txtChange: '', txtReturnType: '', txtSelection:'', autofocus: false &#125;; &#125;, methods: &#123; ready: function () &#123; var self = this; setTimeout(function () &#123; self.autofocus = true; &#125;, 1000); &#125;, onchange: function (event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, onreturn: function (event) &#123; this.txtReturnType = event.returnKeyType; console.log('onreturn', event.type); &#125;, oninput: function (event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125;, focus: function () &#123; this.$refs['input1'].focus(); &#125;, blur: function () &#123; this.$refs['input1'].blur(); &#125;, setRange: function() &#123; console.log(this.$refs[\"inputselection\"]); this.$refs[\"inputselection\"].setSelectionRange(2, 6); &#125;, getSelectionRange: function() &#123; console.log(this.$refs[\"inputselection\"]); var self = this; this.$refs[\"inputselection\"].getSelectionRange(function(e) &#123; self.txtSelection = e.selectionStart +'-' + e.selectionEnd; &#125;); &#125; &#125; &#125;;&lt;/script&gt; 体验一下","type":"references"},{"title":"<loading>","path":"cn/references/components/loading.html","permalink":"https://weex.apache.org/cn/references/components/loading.html","text":"&lt;loading&gt;#v0.6.1+ &lt;loading&gt; 为 &lt;scroller&gt; 和 &lt;list&gt; 提供上拉加载功能。用法与特性与 &lt;refresh&gt; 类似， 是 &lt;scroller&gt; 和 &lt;list&gt; 的子组件，且只能在被 &lt;scroller&gt; 和 &lt;list&gt; 包含时才能被正确的渲染。 子组件# &lt;text&gt; &lt;image&gt; &lt;loading-indicator&gt;: &lt;refresh&gt; 和 &lt;loading&gt; 组件的子组件，拥有默认的动画效果的实现。 特性# display {string}：可选值为 show 或者 hide，仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发。 样式#支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# loading：加载时被触发。 约束# &lt;loading&gt; 不支持 remove，v0.9 版本会修复。 display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发。 如果需要 &lt;loading&gt; hide 时隐藏文案并不再触发事件，有两种解决方法： 修改提示文案，并在 loading 事件中添加判断逻辑； v0.9+ 可通过 remove 解决。 只能通过 display 特性进行展示和隐藏，且必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 示例#&lt;template&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"cell\" v-for=\"num in lists\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;loading class=\"loading\" @loading=\"onloading\" :display=\"showLoading\"&gt; &lt;text class=\"indicator\"&gt;Loading ...&lt;/text&gt; &lt;/loading&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') const LOADMORE_COUNT = 4 export default &#123; data () &#123; return &#123; showLoading: 'hide', lists: [1, 2, 3, 4, 5] &#125; &#125;, methods: &#123; onloading (event) &#123; modal.toast(&#123; message: 'loading', duration: 1 &#125;) this.showLoading = 'show' setTimeout(() =&gt; &#123; const length = this.lists.length for (let i = length; i &lt; length + LOADMORE_COUNT; ++i) &#123; this.lists.push(i + 1) &#125; this.showLoading = 'hide' &#125;, 1500) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; width: 600px; height: 250px; margin-left: 75px; margin-top: 35px; margin-bottom: 35px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: #DDDDDD; background-color: #F5F5F5; &#125; .text &#123; font-size: 50px; text-align: center; color: #41B883; &#125; .loading &#123; justify-content: center; &#125; .indicator &#123; color: #888888; font-size: 42px; padding-top: 20px; padding-bottom: 20px; text-align: center; &#125;&lt;/style&gt; Try it","type":"references"},{"title":"<slider>","path":"cn/references/components/slider.html","permalink":"https://weex.apache.org/cn/references/components/slider.html","text":"&lt;slider&gt;#&lt;slider&gt; 组件用于在一个页面中展示多个图片，在前端，这种效果被称为 轮播图。 子组件#支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下组件作为子组件展示特殊效果： &lt;indicator&gt;：用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 特性# auto-play {boolean}：可选值为 true/false，默认的是 false。 该值决定是否自动播放轮播。重置 loadmore 相关的 UI，值不一样就会重置。 interval {number}：值为毫秒数，此值设定 slider 切换时间间隔。当 auto-play 值为 true 时生效。 infinite {boolean}：循环播放，可选值为 true/false，默认的是 true。 offset-x-accuracy {number}0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间Slider Page至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# change: 当轮播索引改变时，触发该事件。 事件中 event 对象属性： index：展示的图片索引 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。体验一下事件中 event 对象属性： offsetXRatio {number}：表示当前页面的偏移比例，取值范围为[-1, 1]，负值表示向左侧滚动，正值向右。例如，-0.2表示当前item有20%的区域被滚动到slider左侧边界以外，0.3表示当前item有30%的区域被滚动到slider右侧边界以外。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例#&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"frame\" v-for=\"img in imageList\"&gt; &lt;image class=\"image\" resize=\"cover\" :src=\"img.src\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .image &#123; width: 700px; height: 700px; &#125; .slider &#123; margin-top: 25px; margin-left: 25px; width: 700px; height: 700px; border-width: 2px; border-style: solid; border-color: #41B883; &#125; .frame &#123; width: 700px; height: 700px; position: relative; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; imageList: [ &#123; src: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123; src: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<scroller>","path":"cn/references/components/scroller.html","permalink":"https://weex.apache.org/cn/references/components/scroller.html","text":"&lt;scroller&gt;#v0.6.1+ &lt;scroller&gt; 是一个竖直的，可以容纳多个排成一列的子组件的滚动器。如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 注意： &lt;scroller&gt; 可以当作根元素或者嵌套元素使用。此组件的滚动方向是垂直方向的形式。 子组件#支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下两个特殊组件作为子组件： &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 特性# show-scrollbar {boolean}：可选值为 true/ false，默认值为 true。控制是否出现滚动条。 scroll-direction {string}：可选为 horizontal 或者 vertical，默认值为 vertical 。定义滚动的方向。 scroll-direction定义了 scroller 的滚动方向，flex-direction 定义了 scroller 的布局方向，两个方向必须一致。 scroll-direction 的默认值是 vertical, flex-direction 的默认值是 row。 当需要一个水平方向的 scroller 时，使用 scroll-direction:horizontal 和 flex-direction: row。 当需要一个竖直方向的 scroller 时，使用 scroll-direction:vertical 和 flex-direction: column。由于这两个值均是默认值，当需要一个竖直方向的 scroller 时，这两个值可以不设置。 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与页面底部之间的距离）。当页面的滚动条滚动到足够接近页面底部时将会触发 loadmore 这个事件。 loadmoreretry {number}：默认值为 0，当 loadmore 失败时是否重置 loadmore 相关的 UI，值不一样就会重置。 该属性已废弃，请使用resetLoadmore()函数实现重置loadmore的操作。 offset-accuracy {number} 0.11+：控制onscroll事件触发的频率，默认值为10，表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能。 offset-accuracy：默认值是0，触发 scroll 事件所需要的垂直偏移距离。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# loadmore v0.5+：如果滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 scroll 0.11+: 列表发生滚动时将会触发该事件，事件的默认抽样率为10px，即列表每滚动10px触发一次，可通过属性offset-accuracy设置抽样率。 参见 scroll event demo。 事件中 event 对象属性： contentSize {Object}：列表的内容尺寸 width {number}: 列表内容宽度 height {number}: 列表内容高度 contentOffset {Object}: 列表的偏移尺寸 x {number}: x轴上的偏移量 y {number}: y轴上的偏移量 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展#scrollToElement(node, options)#滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 resetLoadmore() 0.9+#在默认情况下，触发loadmore事件后，如果列表中内容没有发生变更，则下一次滚动到列表末尾时将不会再次触发loadmore事件，你可以通过调用resetLoadmore()方法来打破这一限制，调用该方法后，下一次滚动到列表末尾时将强制触发loadmore。 参数# node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是0 约束#不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 &lt;list&gt; 或者 &lt;scroller&gt; 中的。 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it","type":"references"},{"title":"<switch>","path":"cn/references/components/switch.html","permalink":"https://weex.apache.org/cn/references/components/switch.html","text":"&lt;switch&gt;#v0.6.1+ &lt;switch&gt; 是 Weex 的内置组件，用来创建与 iOS 一致样式的按钮。例如，在 iPhone 中的设置应用中的飞行模式按钮就是一个 switch 按钮。 子组件#&lt;switch&gt; 组件不支持任何子组件。 特性# checked {boolean}：默认值为 false，表明按钮是否开启 is on or not. disabled {boolean}：默认值为 false，表明是否激活按钮 样式#值得注意的是，在这个组件上，有些样式组件属性不能使用，它们是： width height min-width min-height margin padding border 注意： 如果 &lt;switch&gt; 的容器没有设置为 align-items：flex-start，则 Android 中的开关将被拉伸。 通用样式 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# change：改变开关状态时触发该事件。 事件中 event 对象属性： value: 组件布尔值真或假。 timestamp: 事件的时间戳。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例#&lt;template&gt; &lt;div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;normal&lt;/text&gt; &lt;switch&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;checked&lt;/text&gt; &lt;switch checked=\"true\"&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;disabled&lt;/text&gt; &lt;switch disabled=\"true\" checked=\"true\"&gt;&lt;/switch&gt; &lt;switch disabled=\"true\"&gt;&lt;/switch&gt; &lt;/div&gt; &lt;div class=\"example\"&gt; &lt;text class=\"label\"&gt;onchange&lt;/text&gt; &lt;switch @change=\"onchange\"&gt;&lt;/switch&gt; &lt;text class=\"info\"&gt;&#123;&#123;checked&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; checked: false &#125; &#125;, methods: &#123; onchange (event) &#123; console.log(`onchage, value: $&#123;event.value&#125;`) this.checked = event.value &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .example &#123; flex-direction: row; justify-content: flex-start; margin-top: 60px; &#125; .label &#123; font-size: 40px; line-height: 60px; width: 350px; color: #666; text-align: right; margin-right: 20px; &#125; .info &#123; font-size: 30px; line-height: 60px; color: #BBB; margin-left: 10px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<text>","path":"cn/references/components/text.html","permalink":"https://weex.apache.org/cn/references/components/text.html","text":"&lt;text&gt;#&lt;text&gt; 是 Weex 内置的组件，用来将文本按照指定的样式渲染出来。&lt;text&gt; 只能包含文本值，你可以使用 {{}} 标记插入变量值作为文本内容。 子组件#此组件不支持子组件。 特性# value {string}: 组件的值，与 &lt;text&gt; 标签中的文本内容相同。 样式# lines {number}: 指定文本行数。默认值是 0 代表不限制行数。 text styles: 查看 文本样式 支持 color 样式. 支持 font-size 样式. iOS默认值：32，Android：不同设备不同，H5 默认值：32. 支持 font-style 样式. 支持 font-weight 样式. 支持 text-align 样式. 支持 text-decoration 样式. 支持 text-overflow 样式. 支持 line-height样式0.6.1+ 不支持 flex-direction, justify-content, align-items 这些为子节点设置的属性，并且&lt;text&gt;没有子节点。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# 通用事件支持所有通用事件： click longpress appear disappear 查看 通用事件 约束# &lt;text&gt; 里直接写文本头尾空白会被过滤，如果需要保留头尾空白，暂时只能通过数据绑定写头尾空格。 iconfont#支持版本:v0.12.0 支持ttf和woff字体格式的自定义字体, 可以通过调用 dom module 里面的 addRule方法, 构建自定义的font-family使用, addRule 建议在 beforeCreate 或者更早时调用 &lt;template&gt; &lt;div style='flex-direction:row;margin-top:50px'&gt; &lt;text style='font-family:iconfont4;font-size:50;color:green'&gt;&amp;#xe614;&amp;#xe612;&amp;#xe613;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:50;'&gt;&amp;#xe614;&amp;#xe612;&amp;#xe613;&amp;#xe61d;&amp;#xe714;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:60;color:blue'&gt;&amp;#xe711;&lt;/text&gt; &lt;text style='font-family:iconfont4;font-size:60;color:green'&gt;&amp;#xe71c;&amp;#xe60b;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; beforeCreate: function() &#123; var domModule = weex.requireModule('dom'); //目前支持ttf、woff文件，不支持svg、eot类型,moreItem at http://www.iconfont.cn/ domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\" &#125;); &#125;&#125;&lt;/script&gt; try it 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\" lines=\"3\"&gt;Weex 是一套简单易用的跨平台开发方案，能以 Web 的开发体验构建高性能、可扩展的原生应用。Vue 是一个轻量并且功能强大的渐进式前端框架。&lt;/text&gt; &lt;/div&gt; &lt;div class=\"panel\"&gt; &lt;text class=\"text\" lines=\"3\"&gt;Weex is an cross-platform development solution that builds high-performance, scalable native applications with a Web development experience. Vue is a lightweight and powerful progressive front-end framework. &lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .panel &#123; width: 600px; margin-left: 75px; border-width: 2px; border-style: solid; border-color: #BBB; padding-top: 15px; padding-bottom: 15px; padding-left: 15px; padding-right: 15px; margin-bottom: 30px; &#125; .text &#123; lines: 3; color: #666666; font-size: 32px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<video>","path":"cn/references/components/video.html","permalink":"https://weex.apache.org/cn/references/components/video.html","text":"&lt;video&gt;#v0.6.1+ &lt;video&gt; 组件可以让我们在 Weex 页面中嵌入视频内容。 子组件# &lt;text&gt; 是唯一合法的子组件。 特性# src {string}：内嵌的视频指向的URL play-status {string}：可选值为 play | pause，用来控制视频的播放状态，play 或者 pause，默认值是 pause。 auto-play {boolean}：可选值为 true | false，当页面加载初始化完成后，用来控制视频是否立即播放，默认值是 false。 样式# 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# start：当 playback 的状态是 Playing 时触发 pause：当 playback 的状态是 Paused 时触发 finish：当 playback 的状态是 Finished 时触发 fail：当 playback 状态是 Failed 时触发 示例#&lt;template&gt; &lt;div&gt; &lt;video class=\"video\" :src=\"src\" autoplay controls @start=\"onstart\" @pause=\"onpause\" @finish=\"onfinish\" @fail=\"onfail\"&gt;&lt;/video&gt; &lt;text class=\"info\"&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .video &#123; width: 630px; height: 350px; margin-top: 60px; margin-left: 60px; &#125; .info &#123; margin-top: 40px; font-size: 40px; text-align: center; &#125;&lt;/style&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; state: '----', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125; &#125;, methods:&#123; onstart (event) &#123; this.state = 'onstart' &#125;, onpause (event) &#123; this.state = 'onpause' &#125;, onfinish (event) &#123; this.state = 'onfinish' &#125;, onfail (event) &#123; this.state = 'onfinish' &#125; &#125; &#125;&lt;/script&gt; try it","type":"references"},{"title":"<textarea>","path":"cn/references/components/textarea.html","permalink":"https://weex.apache.org/cn/references/components/textarea.html","text":"&lt;textarea&gt;#v0.8+ textarea 是 Weex 内置的一个组件，用于用户交互，接受用户输入数据。 可以认为是允许多行的 &lt;input&gt; Notes: &lt;textarea&gt;支持 &lt;input&gt; 支持的所有的事件。 子组件#textarea 组件不支持子组件。 特性# value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：表示是否在页面加载时控件自动获得输入焦点。 rows {number}：接收 number 类型的数据，指定组件的高度，默认值是 2 样式# 伪类v0.9.5+: textarea 支持以下伪类： active focus disabled enabled text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;textarea class=\"textarea\" @input=\"oninput\" @change=\"onchange\" @focus=\"onfocus\" @blur=\"onblur\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const modal = weex.requireModule('modal') export default &#123; methods: &#123; oninput (event) &#123; console.log('oninput:', event.value) modal.toast(&#123; message: `oninput: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onchange (event) &#123; console.log('onchange:', event.value) modal.toast(&#123; message: `onchange: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onfocus (event) &#123; console.log('onfocus:', event.value) modal.toast(&#123; message: `onfocus: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125;, onblur (event) &#123; console.log('onblur:', event.value) modal.toast(&#123; message: `input blur: $&#123;event.value&#125;`, duration: 0.8 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .textarea &#123; font-size: 50px; width: 650px; margin-top: 50px; margin-left: 50px; padding-top: 20px; padding-bottom: 20px; padding-left: 20px; padding-right: 20px; color: #666666; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"<waterfall>","path":"cn/references/components/waterfall.html","permalink":"https://weex.apache.org/cn/references/components/waterfall.html","text":"waterfall#v0.11.0+ 提供瀑布流布局的组件 子组件#注意: 和list一样, waterfall 只支持特定类型的组件: cell, header, refresh, loading 和 fixed-position 组件. cell: 瀑布流中的每个元素 header: 主要用于表示横跨多列的元素，可以通过css的position属性设置为sticky 特性# column-width : 描述瀑布流每一列的列宽 auto: 意味着列宽是被其他属性所决定的(比如 column-count) &lt;length&gt;: 最佳列宽，实际的列宽可能会更宽(需要填充剩余的空间)， 或者更窄(如果剩余空间比列宽还要小)。 该值必须大于0 column-count: 描述瀑布流的列数 auto: 意味着列数是被其他属性所决定的(比如 column-width) &lt;integer&gt;: 最佳列数，column-width 和 column-count 都指定非0值， 则 column-count 代表最大列数。 column-gap: 列与列的间隙. 如果指定了 normal ，则对应 32. 其他支持的属性参见 List Component Attributes 样式#通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 API#滚动到列表某个指定项是常见需求，&lt;waterfall&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt; 或者 &lt;header&gt;。通过 dom module 访问，更多信息可参考 dom module 。 示例#参见 playground waterfall example","type":"references"},{"title":"<web>","path":"cn/references/components/web.html","permalink":"https://weex.apache.org/cn/references/components/web.html","text":"&lt;web&gt;#v0.5+ 使用 &lt;web&gt; 组件在 Weex 页面中嵌入一张网页内容。src 属性用来指定资源地址。你也可以使用 webview module 来控制 web 的行为，比如前进、后退和重载。可以在这里查看 webview module。 子组件#不支持子组件。 特性# src {string}：此特性指定嵌入的 web 页面 url。 样式# 通用样式：不支持部分盒模型样式，支持列表如下： width 组件的宽度，默认值是0。这个样式定义必须指定数值。 height 组件的高度，默认值是0。这个样式定义必须指定数值。 flexbox 布局 position opacity background-color 查看 组件通用样式 事件# pagestart: &lt;web&gt; 组件开始加载时发送此事件消息。 pagefinish: &lt;web&gt; 组件完成加载时发送此事件消息。 error: \b如果 &lt;web&gt; 组件加载出现错误，会发送此事件消息。 通用事件 支持以下通用事件： appear disappear 查看 通用事件 注意： 不支持 click 事件。 示例#我们用一个简易浏览器示例，来展示如何使用 &lt;web&gt; 组件和 webview module。 查看 webview module。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;input class=\"input\" v-model=\"value\" ref=\"input\" type=\"url\" autofocus=\"false\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"button\" @click=\"reload\"&gt;reload&lt;/text&gt; &lt;/div&gt; &lt;web ref=\"webview\" :src=\"url\" class=\"webview\" @pagestart=\"start\" @pagefinish=\"finish\" @error=\"error\"&gt;&lt;/web&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const webview = weex.requireModule('webview') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; url : 'https://m.alibaba.com', value: 'https://m.alibaba.com' &#125; &#125;, methods: &#123; loadURL (event) &#123; this.url = this.value modal.toast(&#123; message: 'load url:' + this.url &#125;) setTimeout(() =&gt; &#123; console.log('will go back.') modal.toast(&#123; message: 'will go back' &#125;) webview.goBack(this.$refs.webview) &#125;, 10000) &#125;, reload (event) &#123; console.log('will reload webview') modal.toast(&#123; message: 'reload' &#125;) webview.reload(this.$refs.webview) &#125;, start (event) &#123; console.log('pagestart', event) modal.toast(&#123; message: 'pagestart' &#125;) &#125;, finish (event) &#123; console.log('pagefinish', event) modal.toast(&#123; message: 'pagefinish' &#125;) &#125;, error (event) &#123; console.log('error', event) modal.toast(&#123; message: 'error' &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .group &#123; flex-direction: row; justify-content: space-around; margin-top: 20px; &#125; .input &#123; width: 600px; font-size: 36px; padding-top: 15px; padding-bottom: 15px; border-width: 2px; border-style: solid; border-color: #BBBBBB; &#125; .button &#123; width: 225px; text-align: center; background-color: #D3D3D3; padding-top: 15px; padding-bottom: 15px; margin-bottom: 30px; font-size: 30px; &#125; .webview &#123; margin-left: 75px; width: 600px; height: 750px; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"clipboard","path":"cn/references/modules/clipboard.html","permalink":"https://weex.apache.org/cn/references/modules/clipboard.html","text":"clipboard 剪切板#v0.8+ 我们可以通过 clipboard 模块的 getString()、setString() 接口从系统的粘贴板获取内容或者设置内容。 以前当我们收到一条短信验证码信息时，除了人肉拷贝，我们无法获取拷贝短信的内容。这是非常苦恼的。但是现在我们可以通过简单的调用 clipboard.getString() 接口来获取短信内容了。 注意 仅支持文本拷贝 出于安全考虑和平台限制，只支持 Android 和 iOS，不支持 html5。 API#getString(callback)#从系统粘贴板读取内容。 参数# callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： ret.data：获取到的文本内容； ret.result：返回状态，可能为 success 或 fail。 setString(text)#将一段文本复制到剪切板，相当于手动复制文本。 参数# text {string}：要复制到剪切板的字符串。 Example#&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"onItemClick\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" @click=\"setContent\"&gt;Click to copy: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const clipboard = weex.requireModule('clipboard') export default &#123; data () &#123; return &#123; tobecopied: 'yay!', message: 'nothing.' &#125; &#125;, methods: &#123; setContent () &#123; clipboard.setString(this.tobecopied) &#125;, onItemClick () &#123; this.message = 'clicked! ' clipboard.getString(ret =&gt; &#123; this.message = 'text from clipboard:' + ret.data &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750px; height: 90px; padding-left: 30px; padding-right: 30px; border-bottom-width: 1px; border-style: solid; border-color: #DDDDDD; &#125; .text &#123; width: 750px; height: 90px; &#125;&lt;/style&gt; try it","type":"references"},{"title":"animation","path":"cn/references/modules/animation.html","permalink":"https://weex.apache.org/cn/references/modules/animation.html","text":"animation 动画#流畅且有意义的动画是一个十分有效的提升移动应用用户体验的手段，animation 模块被用于在组件上执行动画。动画可以对组件执行一系列简单的变换 (位置、大小、旋转角度、背景颜色和不透明度)。举个例子，如果有一个 &lt;image&gt; 组件，通过动画你可以对其进行移动、旋转、拉伸或收缩等动作。 API#transition(el, options, callback)#参数# el {Element}：将要执行动画的元素，例如指定动画的元素 ref 属性为 test , 可以通过调用 this.refs.test 来获取元素的引用。 options {Object}：描述动画过程的对象。 options.duration {number}：指定动画的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 options.delay {number}：指定请求动画操作到执行动画之间的时间间隔 (单位是毫秒)，默认值是 0，表示没有延迟，在请求后立即执行动画。 options.needLayout {boolean}：节点动画执行时是否产生布局动画即LayoutAnimation，默认值是false。 options.timingFunction {string}：描述动画执行的速度曲线，用于使动画变化更为平滑。默认值是 linear，表示动画从开始到结束都拥有同样的速度。下表列出了所有合法的属性： 属性名 描述 linear 动画从头到尾的速度是相同的 ease-in 动画速度由慢到快 ease-out 动画速度由快到慢 ease-in-out 动画先加速到达中间点后减速到达终点 cubic-bezier(x1, y1, x2, y2) 在三次贝塞尔函数中定义变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. options.styles {Object}：设置不同样式过渡效果的键值对，下表列出了所有合法的参数： 参数名 描述 值类型 默认值 width 动画执行后应用到组件上的宽度值 length 无 height 动画执行后应用到组件上的高度值 length 无 backgroundColor 动画执行后应用到组件上的背景颜色 string none opacity 动画执行后应用到组件上的不透明度值 介于 0 到 1 间的数值 1 transformOrigin 定义变化过程的中心点. 参数 x-aris 可能的值为 left、center、right、长度值或百分比值, 参数 y-axis 可能的值为 top、center、bottom、长度值或百分比值 x-axis y-axis center center transform 定义应用在元素上的变换类型，支持下表列出的属性 object 无 transform属性的合法值: 名称 描述 值类型 默认值 translate/translateX/translateY 指定元素要移动到的位置 像素值或百分比 无 rotate 指定元素将被旋转的角度，单位是度 number 无 scale/scaleX/scaleY 按比例放大或缩小元素 number 无 rotate/rotateX v0.14+ /rotateY v0.14+ 指定元素将被旋转的角度，单位是度 number 无 perspective v0.16+ 观察者距离z=0平面的距离，在Android 4.1及以上有效 number 正无穷 callback {Function}：动画执行完毕之后的回调函数。注意，在0.16.0+版本后，iOS上可以获取animation是否执行成功的信息，callback中的result参数会有两种，分别是是Success与Fail，Android暂不支持。 Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div ref=\"test\" @click=\"move\" class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const animation = weex.requireModule('animation') const modal = weex.requireModule('modal') export default &#123; methods: &#123; move () &#123; var testEl = this.$refs.test; animation.transition(testEl, &#123; styles: &#123; color: '#FF0000', transform: 'translate(250px, 100px)', transformOrigin: 'center center' &#125;, duration: 800, //ms timingFunction: 'ease', needLayout:false, delay: 0 //ms &#125;, function () &#123; modal.toast(&#123; message: 'animation finished.' &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .box &#123; width: 250px; height: 250px; background-color: #DDD; &#125;&lt;/style&gt; try it","type":"references"},{"title":"dom","path":"cn/references/modules/dom.html","permalink":"https://weex.apache.org/cn/references/modules/dom.html","text":"dom#包含如下可以更新 dom 树的 dom API。 这部分API是通过把 virtual-dom 的消息发送到 native 渲染器来做到的。 开发者在日常开发中，唯一可在 .vue 文件中使用的是 scrollToElement。你也可以调用 $scrollTo 方法来使用它 这个页面提及的其他的 API，只在 callNative 进程中的 native 渲染器用。（关于 callNative 进程的进一步介绍，可以在 How it works中的 JS Framework 部分看到 ） API#scrollToElement(node, options)#让页面滚动到那个对应的节点，这个API只能在 &lt;scroller&gt; 和 &lt;list&gt; 组件中用。 这个API也能通过调用VM的方法 $scrollTo 来使用（已弃用） 要在你的 .vue 文件中使用这个 API，可以使用 weex.requireModule(&#39;dom&#39;).scrollToElement。 参数# node {Node}：你要滚动到的那个节点 options {Object}：如下选项 offset {number}：一个到其可见位置的偏移距离，默认是 0 animated {boolean} 0.10+：是否需要附带滚动动画，默认是true 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;scroller class=\"scroller\"&gt; &lt;div class=\"row\" v-for=\"(name, index) in rows\" :ref=\"'item'+index\"&gt; &lt;text class=\"text\" :ref=\"'text'+index\"&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"group\"&gt; &lt;text @click=\"goto10\" class=\"button\"&gt;Go to 10&lt;/text&gt; &lt;text @click=\"goto20\" class=\"button\"&gt;Go to 20&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') export default &#123; data () &#123; return &#123; rows: [] &#125; &#125;, created () &#123; for (let i = 0; i &lt; 30; i++) &#123; this.rows.push('row ' + i) &#125; &#125;, methods: &#123; goto10 (count) &#123; const el = this.$refs.item10[0] dom.scrollToElement(el, &#123;&#125;) &#125;, goto20 (count) &#123; const el = this.$refs.item20[0] dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .scroller &#123; width: 700px; height: 700px; border-width: 3px; border-style: solid; border-color: rgb(162, 217, 192); margin-left: 25px; &#125; .row &#123; height: 100px; flex-direction: column; justify-content: center; padding-left: 30px; border-bottom-width: 2px; border-bottom-style: solid; border-bottom-color: #DDDDDD; &#125; .text &#123; font-size: 45px; color: #666666; &#125; .group &#123; flex-direction: row; /*justify-content: space-around;*/ justify-content: center; margin-top: 60px; &#125; .button &#123; width: 200px; padding-top: 20px; padding-bottom: 20px; font-size: 40px; margin-left: 30px; margin-right: 30px; text-align: center; color: #41B883; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt; try it getComponentRect(ref, callback) v0.9.4+#通过标签的 ref 获得其布局信息，返回的信息在 callBack 中，格式参考如下： &#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; 如果想要获取到 Weex 容器的布局信息，可以指定 ref=&#39;viewport&#39;，调用例子如下： &lt;template&gt; &lt;div class=\"wrapper\" style='margin-top:200px'&gt; &lt;div ref=\"box\" class=\"box\"&gt; &lt;text class=\"info\"&gt;Width: &#123;&#123;size.width&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Height: &#123;&#123;size.height&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Top: &#123;&#123;size.top&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Bottom: &#123;&#123;size.bottom&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Left: &#123;&#123;size.left&#125;&#125;&lt;/text&gt; &lt;text class=\"info\"&gt;Right: &#123;&#123;size.right&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text class=\"info btn\" @click='click()'&gt;&#123;&#123;this.tip&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const dom = weex.requireModule('dom') function round(size) &#123; var roundSize = &#123; 'width': Math.round(size.width), 'height': Math.round(size.height), 'top': Math.round(size.top), 'bottom': Math.round(size.bottom), 'left': Math.round(size.left), 'right': Math.round(size.right) &#125; return roundSize &#125; export default &#123; data () &#123; return &#123; size: &#123; width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 &#125;, ref:\"viewport\", tip:\"get box rect\" &#125; &#125;, mounted () &#123; const result = dom.getComponentRect(this.ref, option =&gt; &#123; console.log('getComponentRect:', option) this.size = round.call(this,option.size); &#125;) &#125;, methods:&#123; click:function() &#123; if (this.ref === 'viewport') &#123; this.ref = this.$refs.box; this.tip = \"get viewport rect\" &#125; else &#123; this.ref = 'viewport' this.tip = \"get box rect\" &#125; const result = dom.getComponentRect(this.ref, option =&gt; &#123; console.log('getComponentRect:', option) this.size = round.call(this,option.size); &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .btn &#123; margin-top:20px; border-width:2px; border-style: solid; border-radius:10px; width:300px; margin-left:170px; padding-left:35px; border-color: rgb(162, 217, 192); &#125; .btn:active &#123; background-color: #8fbc8f; border-color: gray; &#125; .box &#123; align-items:center; margin-left: 150px; width: 350px; height: 400px; background-color: #DDD; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .info &#123; font-size: 40px; top:30px; margin-left:20px; font-family: Consolas, \"Liberation Mono\", Menlo, Courier, monospace; color: #41B883; &#125;&lt;/style&gt; try it addRule#支持版本:v0.12.0 addRule是可以为dom 添加一条规则，目前支持自定义字体fontFace规则，构建自定义的font-family，可以在text使用 fontFace#var domModule = weex.requireModule('dom');domModule.addRule('fontFace', &#123; 'fontFamily': \"iconfont2\", 'src': \"url('http://at.alicdn.com/t/font_1469606063_76593.ttf')\"&#125;); try it 其他#dom 还有一些底层接口用于创建 Weex 实例时调用，比如 createBody、updateAttrs 等，但并未开放供外部使用。","type":"references"},{"title":"globalEvent","path":"cn/references/modules/globalevent.html","permalink":"https://weex.apache.org/cn/references/modules/globalevent.html","text":"全局事件#0.8 globalEvent 用于监听持久性事件，例如定位信息，陀螺仪等的变化。全局事件是需要额外 APIs 处理的次要 API。你能通过 addEventListener 注册事件监听，当你不再需要的时候，也可以通过 removeEventListener 取消事件监听。 提醒 这是一个实例级别的事件，而非应用级别。 如何让你的模块支持全局事件#API 开发完成后，当需要发送事件时，需要通过以下方法： /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); 如何在 weex-html5 组件或模块中分发全局事件？只需在文档元素上分派事件： var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) 示例 Android#Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\",params); iOS#[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; API#addEventListener(String eventName, String callback)#注册全局事件。 参数# eventName {string}：需要监听的事件名称。 callback {Function}：触发事件后的回调函数。 示例#var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)#取消事件监听。 参数# eventName {string}：需要取消的事件名称。 示例#var globalEvent = weex.requireModule('globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"meta","path":"cn/references/modules/meta.html","permalink":"https://weex.apache.org/cn/references/modules/meta.html","text":"meta#meta 模块可用于声明单个页面的元信息，通常是一些页面的配置，如容器的显示宽度 (viewport) 等。 API#setViewport(options)#0.10.0+ Weex 容器默认的宽度 (viewport) 是 750px，通过 setViewport 方法可以改变页面的显示宽度，仅对当前页面生效。 需要注意的是：只有在页面渲染开始之前设置 viewport 才会生效。 也就是说，setViewport 方法只能在入口文件中使用，而且要在 new Vue(...) 之前调用；如果是在组件中使用，就只有在渲染到该组件的时候才会执行相应的代码，此时页面已经处于渲染过程中，设置 viewport 将不会再生效。 参数#参数配置借鉴了 W3C 标准中的 CSS Device Adaptation，目前支持如下属性： options: viewport 的配置项 width: 数值，或者 &quot;device-width&quot; 和 &quot;device-height&quot; 之一。 height: 数值，或者 &quot;device-width&quot; 和 &quot;device-height&quot; 之一。 宽度和高度的单位默认是 px，暂不支持其他单位。 例子#入口文件： // entry.jsimport App from './app.vue'const meta = weex.requireModule('meta')// 配置 viewport 的宽度为 640pxmeta.setViewport(&#123; width: 640&#125;)App.el = '#root'new Vue(App) 在入口文件中配置了 viewport 的宽度为 640 之后，当前页面中的所有组件都会以 640px 作为满屏宽度。 组件文件： &lt;!-- app.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;div class=\"box750\"&gt; &lt;text class=\"text\"&gt;750&lt;/text&gt; &lt;div class=\"box640\"&gt; &lt;text class=\"text\"&gt;640&lt;/text&gt; &lt;div class=\"box480\"&gt; &lt;text class=\"text\"&gt;480&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .box750 &#123; width: 750px; height: 750px; background-color: #EEEEEE; &#125; .box640 &#123; width: 640px; height: 640px; background-color: #CCCCCC; &#125; .box480 &#123; width: 480px; height: 480px; background-color: #AAAAAA; &#125; .text &#123; font-size: 50px; &#125;&lt;/style&gt; 试试看。（由于 http://dotwe.org 目前还不支持配置入口文件，例子中的效果暂时无法在线查看。） 本地开发环境的搭建可以参考：《搭建开发环境》。","type":"references"},{"title":"navigator","path":"cn/references/modules/navigator.html","permalink":"https://weex.apache.org/cn/references/modules/navigator.html","text":"navigator 导航控制#v0.6.1+ 众所周知，在浏览器里，我们可以通过前进或者回退按钮来切换页面，iOS/Android 的 navigator 模块就是用来实现类似的效果的。除了前进、回退功能，该模块还允许我们指定在切换页面的时候是否应用动画效果。 API#push(options, callback)#把一个weex页面URL压入导航堆栈中，可指定在页面跳转时是否需要动画，以及操作完成后需要执行的回调函数 参数# options {Object}：选项参数 url {stirng}：要压入的 Weex 页面的 URL animated {string}：&quot;true&quot; 示意为页面压入时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {Function}：执行完该操作后的回调函数 pop(options, callback)#把一个 Weex 页面 URL 弹出导航堆栈中，可指定在页面弹出时是否需要动画，以及操作完成后需要执行的回调函数。 参数# options {object}：选项参数对象 animated {string}：&quot;true&quot; 示意为弹出页面时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {function}：执行完该操作后的回调函数 注意事项：animated 二级参数目前仅支持字符串的 &quot;true&quot; 和 &quot;false&quot;，传入布尔值类型会导致程序崩溃，未来版本会修复这个问题 Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"jump\"&gt;Jump&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = weex.requireModule('navigator') var modal = weex.requireModule('modal') export default &#123; methods: &#123; jump (event) &#123; console.log('will jump') navigator.push(&#123; url: 'http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js', animated: \"true\" &#125;, event =&gt; &#123; modal.toast(&#123; message: 'callback: ' + event &#125;) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"modal","path":"cn/references/modules/modal.html","permalink":"https://weex.apache.org/cn/references/modules/modal.html","text":"modal 模态#modal 模块提供了以下展示消息框的 API：toast、alert、confirm 和 prompt。 API#toast(options)#toast() 会在一个小浮层里展示关于某个操作的简单反馈。例如，在邮件发送前离开邮编编辑界面，可以触发一个“草稿已保存”的 toast，告知用户以后可以继续编辑。toast 会在显示一段时间之后自动消失。 参数# options {Object}：相关选项 message {string}：展示的内容 duration {number}：展示的持续时间（以秒为单位） Android: 如果时间长度大于3s，将使用一个被称为LONG的系统变量, 否则使用SHORT这个系统变量 iOS: 持续的时间同Duration相同。 alert(options, callback)#警告框经常用于确保用户可以得到某些信息。当警告框出现后，用户需要点击确定按钮才能继续进行操作。 参数# options {Object}：alert选项 message {string}：警告框内显示的文字信息 okTitle {string}：确定按钮上显示的文字信息，默认是“OK” callback {Function}：用户操作完成后的回调 confirm(options, callback)#确认框用于使用户可以验证或者接受某些信息。当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。 参数# options {object}：confirm 选项 message {string}：确认框内显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (result)}：用户操作完成后的回调，回调函数的参数 result 是确定按钮上的文字信息字符串 prompt(options, callback)#提示框经常用于提示用户在进入页面前输入某个值。当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操作。 参数# options {object}：prompt 选项 message {string}：提示框内要显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (ret)}：用户操作完成后的回调，回调函数的参数 ret 格式形如 { result: &#39;OK&#39;, data: &#39;hello world&#39; }，如下 result {string}：用户按下的按钮上的文字信息 data {string}：用户输入的文字信息 Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"button\" @click=\"showToast\"&gt;Toast&lt;/text&gt; &lt;text class=\"button\" @click=\"showAlert\"&gt;Alert&lt;/text&gt; &lt;text class=\"button\" @click=\"showConfirm\"&gt;Confirm&lt;/text&gt; &lt;text class=\"button\" @click=\"showPrompt\"&gt;Prompt&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var modal = weex.requireModule('modal') export default &#123; methods: &#123; showToast (event) &#123; console.log('will show toast') modal.toast(&#123; message: 'This is a toast', duration: 0.3 &#125;) &#125;, showAlert (event) &#123; console.log('will show alert') modal.alert(&#123; message: 'This is a alert', duration: 0.3 &#125;, function (value) &#123; console.log('alert callback', value) &#125;) &#125;, showConfirm (event) &#123; console.log('will show confirm') modal.confirm(&#123; message: 'Do you confirm ?', duration: 0.3 &#125;, function (value) &#123; console.log('confirm callback', value) &#125;) &#125;, showPrompt (event) &#123; console.log('will show prompt') modal.prompt(&#123; message: 'This is a prompt', duration: 0.3 &#125;, function (value) &#123; console.log('prompt callback', value) &#125;) &#125; &#125; &#125;;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .button &#123; font-size: 60px; width: 450px; text-align: center; margin-top: 30px; margin-left: 150px; padding-top: 20px; padding-bottom: 20px; border-width: 2px; border-style: solid; color: #666666; border-color: #DDDDDD; background-color: #F5F5F5 &#125;&lt;/style&gt; try it","type":"references"},{"title":"picker","path":"cn/references/modules/picker.html","permalink":"https://weex.apache.org/cn/references/modules/picker.html","text":"picker#v0.9+ 概述#以下为 picker 相关的 API，用于数据选择，日期选择，时间选择。（ H5模块如需使用，请手动引入weex-picker组件） API#pick(options, callback[options])#调用单选 picker 参数# options {Object}：调用单选 picker 选项 index {number}：默认选中的选项 items {array}：picker 数据源 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {number}：选择的选项,仅成功确认时候存在。 pickDate(options, callback[options])#调用 date picker 参数# options {Object}：调用 date picker 选项 value {string}：必选，date picker 选中的值，date 的字符串格式为yyyy-MM-dd max {string}：可选，date 的最大值 min {string}：可选，date 的最小值 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {string}：选择的值 date 的字符，格式为 yyyy-MM-dd, 仅成功确认的时候存在。 pickTime(options, callback[options])#调用 time picker 参数# options {Object}：调用 time picker 选项 value {string}：必选，time 格式为 HH:mm callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： result {string}：结果三种类型 success, cancel, error data {string}：time 格式为 HH:mm, 仅成功确认的时候存在。 示例#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"label\"&gt;Time: &lt;/text&gt; &lt;text class=\"title\"&gt;&#123;&#123;value&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"pickTime\"&gt;Pick Time&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const picker = weex.requireModule('picker') export default &#123; data () &#123; return &#123; value: '' &#125; &#125;, methods: &#123; pickTime () &#123; picker.pickTime(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === 'success') &#123; this.value = event.data &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; align-items: center; &#125; .label &#123; font-size: 40px; color: #888888; &#125; .title &#123; font-size: 80px; color: #41B883; &#125; .button &#123; font-size: 36px; width: 280px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;","type":"references"},{"title":"storage","path":"cn/references/modules/storage.html","permalink":"https://weex.apache.org/cn/references/modules/storage.html","text":"storage 本地存储#v0.7+ 备注：0.7及以上版本可用 storage 是一个在前端比较常用的模块，可以对本地数据进行存储、修改、删除，并且该数据是永久保存的，除非手动清除或者代码清除。但是，storage 模块有一个限制就是浏览器端（H5）只能存储小于5M的数据，因为在 H5/Web 端的实现是采用 HTML5 LocalStorage API。而 Android 和 iOS 这块是没什么限制的。 storage 常用在一些被用户经常查询，但是又不频繁更新的数据，比如搜索历史、用户的订单列表等。搜索历史一般情况都是作为本地数据存储的，因此使用 storage 比较合适。而用户订单列表是需要本地存储和服务端器检索配合的场景。当一个用户下单后，会经常查阅个人的订单列表。但是，订单的列表数据不是频繁更新的，往往只有在收到货品时，才更新“已签收”，其余平时的状态是“已发货”。因此，可以使用 storage 存储订单列表，可以减少服务器的压力，例如减少 SQL 查询或者缓存的压力。当用户查看订单详情的时候，再更新数据状态。 API#storage 提供了一系列的 API 供我们调用。我们只需要引入该模块，然后调用对应的 API 即可。 setItem(key, value, callback)#该方法可以通过键值对的形式将数据存储到本地。同时可以通过该方法，更新已有的数据。 参数# key {string}：要存储的键，不允许是 &quot;&quot; 或 null value {string}：要存储的值，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示设置成功，invalid_param 表示 key/value 为 &quot;&quot; 或者 null 这里，对返回值做一个简单的介绍： e 包含两个属性：e.result 和 e.data。如果 e.result 返回值是 “success”，则说明成功。e.data 返回 undefined 表示设置成功，返回 invalid_param 表示key/value 为 “” 或者 null。因此，你可以判断两个返回判断是否插入成功。 getItem(key, callback)#传入键名返回对应的键值 参数# key {string}：要获取的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：获取对应的键值字符串，如果没有找到则返回 undefined removeItem(key, callback)#传入一个键名将会删除本地存储中对应的键值 参数# key {string}：要删除的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调. e.result：表示删除是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示删除成功 length(callback)#返回本地存储的数据中所有存储项数量的整数 参数# callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：当前已存储项的数量 getAllKeys(callback)#返回一个包含全部已存储项键名的数组 参数# callback {function (e)}：执行操作成功后的回调。 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：所有键名组成的数组 示例#&lt;template&gt; &lt;div class=\"list\"&gt; &lt;div class=\"group center\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\"&gt;&#123;&#123;state&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"setItem\"&gt;set&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getItem\"&gt;get&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"removeItem\"&gt;remove&lt;/text&gt;&lt;/div&gt; &lt;div class=\"panel\"&gt;&lt;text class=\"text\" @click=\"getAll\"&gt;all&lt;/text&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const storage = weex.requireModule('storage') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; keys: '[]', length: 0, state: '----' &#125; &#125;, methods: &#123; setItem () &#123; storage.setItem('name', 'Hanks', event =&gt; &#123; this.state = 'set success' console.log('set success') &#125;) &#125;, getItem () &#123; storage.getItem('name', event =&gt; &#123; console.log('get value:', event.data) this.state = 'value: ' + event.data &#125;) &#125;, removeItem () &#123; storage.removeItem('name', event =&gt; &#123; console.log('delete value:', event.data) this.state = 'deleted' &#125;) &#125;, getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === 'success') &#123; modal.toast(&#123; message: 'props: ' + event.data.join(', ') &#125;) &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .panel &#123; height: 100px; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125; .group &#123; flex-direction: row; justify-content: space-between; width: 650px; margin-left: 50px; margin-top: 50px; margin-bottom: 50px; &#125; .center &#123; justify-content: center; &#125; .text &#123; font-size: 50px; text-align: center; padding-left: 25px; padding-right: 25px; color: #41B883; &#125; .small &#123; font-size: 32px; padding-left: 35px; padding-right: 35px; color: #41B883; &#125;&lt;/style&gt; try it 其它参考# W3school: html5 localStorage storage 模块完整的 Demo","type":"references"},{"title":"stream","path":"cn/references/modules/stream.html","permalink":"https://weex.apache.org/cn/references/modules/stream.html","text":"stream#概述#以下为 stream 相关的 API，用于实现网络请求。 API#fetch(options, callback[,progressCallback])#发起网络请求 参数# options {Object}：请求的一些选项 method {string}：HTTP 方法 GET 或是 POST url {string}：请求的 URL headers {Object}：HTTP 请求头 type {string}：响应类型, json,text 或是 jsonp {在原生实现中其实与 json 相同) body {string}：HTTP 请求体。 注意： body 参数仅支持 string 类型的参数，请勿直接传递 JSON，必须先将其转为字符串。 GET 请求不支持 body 方式传递参数，请使用 url 传参。 callback {Function}：响应结果回调，回调函数将收到如下的 response 对象： status {number}：返回的状态码 ok {boolean}：如果状态码在 200~299 之间就为真。 statusText {string}：状态描述文本 data {Object | string}: 返回的数据，如果请求类型是 json 和 jsonp，则它就是一个 object ，如果不是，则它就是一个 string。 headers {Object}：响应头 progressCallback {Function}：关于请求状态的回调。 这个回调函数将在请求完成后就被调用: readyState {number}：当前状态state:’1’: 请求连接中opened:’2’: 返回响应头中received:’3’: 正在加载返回数据 status {number}：响应状态码. length {number}：已经接受到的数据长度. 你可以从响应头中获取总长度 statusText {string}：状态文本 headers {Object}：响应头 注意# 默认 Content-Type 是 ‘application/x-www-form-urlencoded’。 如果你需要通过 POST json ， 你需要将 Content-Type 设为 ‘application/json’。 Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;text class=\"title\"&gt;Weex Star :&lt;/text&gt; &lt;text class=\"count\"&gt;&#123;&#123;weexStar&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"title\"&gt;Vue Star :&lt;/text&gt; &lt;text class=\"count\"&gt;&#123;&#123;vueStar&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var stream = weex.requireModule('stream') export default &#123; data () &#123; return &#123; weexStar: 'unknown', vueStar: 'unknown' &#125; &#125;, methods: &#123; getStarCount (repo, callback) &#123; return stream.fetch(&#123; method: 'GET', type: 'json', url: 'https://api.github.com/repos/' + repo &#125;, callback) &#125; &#125;, created () &#123; this.getStarCount('alibaba/weex', res =&gt; &#123; this.weexStar = res.ok ? res.data.stargazers_count : '(network error)' &#125;) this.getStarCount('vuejs/vue', res =&gt; &#123; this.vueStar = res.ok ? res.data.stargazers_count : '(network error)' &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .wrapper &#123; flex-direction: column; justify-content: center; &#125; .group &#123; flex-direction: row; justify-content: center; margin-bottom: 40px; &#125; .title &#123; font-size: 45px; color: #888888; &#125; .count &#123; font-size: 45px; font-weight: bold; margin-left: 12px; color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"WebSocket","path":"cn/references/modules/websocket.html","permalink":"https://weex.apache.org/cn/references/modules/websocket.html","text":"WebSocket#v0.12+ Summary#WebSockets 是一种先进的技术, 这使得在用户的 H5/iOS/Android 和一个服务器之间打开一个的交互式通信会话成为可能, 有了这个 API，你可以向服务器发送消息, 并接收事件驱动的响应, 无需轮询服务器的响应 注意：# iOS和h5提供 WebSockets 的 protocol 默认实现，安卓使用需要提供自定义 adapter 实现，source: DefaultWebSocketAdapter.java; DefaultWebSocketAdapterFactory.java; 集成例子参考weex playground API#WebSocket(url, protocol)#创建 WebSockets，并连接服务器 Arguments# url {string}: 表示要连接的 URL; protocol {string}: WebSockets 协议 send(data)#通过WebSocket连接向服务器发送数据 Arguments# data{string}:要发送到服务器的数据 close(code,reason)#关闭 WebSockets 的链接 Arguments# code {number}: 关闭连接的状态号. reason {string}: 关闭的原因 onopen(options)#链接打开的监听 Arguments# options {object}: 一个空的对象 onmessage(options)#消息事件的监听器 Arguments# options {object}: 服务器返回的消息对象 data {string}: 监听器接收的到的消息 onclose(options)#关闭事件的监听器 Arguments# options {object}: 监听器接收到的对象 code {number}: 服务器返回关闭的状态码 reason {string}: 服务器返回的关闭原因 wasClean {boolen}: 是否完全关闭. onerror(options)#错误事件的监听器 Arguments# options {object}: 错误信息的事件 data {string}: 监听器接收到的信息 Example#&lt;template&gt; &lt;scroller&gt; &lt;div&gt; &lt;div style=\"background-color: #286090\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: white\"&gt;websocket&lt;/text&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input message to send\" class=\"input\" autofocus=\"false\" value=\"\" @change=\"onchange\" @input=\"oninput\" ref=\"input\"/&gt; &lt;div style=\"flex-direction: row; justify-content: center;\"&gt; &lt;text class=\"button\" @click=\"connect\"&gt;connect&lt;/text&gt; &lt;text class=\"button\" @click=\"send\"&gt;send&lt;/text&gt; &lt;text class=\"button\" @click=\"close\"&gt;close&lt;/text&gt; &lt;/div&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = send&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;sendinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onopen&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onopeninfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onmessage&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 400px\"&gt;&#123;&#123;onmessage&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onclose&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;oncloseinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = onerror&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;onerrorinfo&#125;&#125;&lt;/text&gt; &lt;div style=\"background-color: lightgray\"&gt; &lt;text class=\"title\" style=\"height: 80px ;padding: 20px;color: black\"&gt;method = close&lt;/text&gt; &lt;/div&gt; &lt;text style=\"color: black;height: 80px\"&gt;&#123;&#123;closeinfo&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style scoped&gt; .input &#123; font-size: 40px; height: 80px; width: 600px; &#125; .button &#123; font-size: 36px; width: 150px; color: #41B883; text-align: center; padding-top: 25px; padding-bottom: 25px; border-width: 2px; border-style: solid; margin-right: 20px; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); &#125;&lt;/style&gt;&lt;script&gt; var websocket = weex.requireModule('webSocket') export default &#123; data () &#123; return &#123; connectinfo: '', sendinfo: '', onopeninfo: '', onmessage: '', oncloseinfo: '', onerrorinfo: '', closeinfo: '', txtInput:'', navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '' &#125; &#125;, methods: &#123; connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e) &#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e) &#123; self.onmessage = e.data; &#125; websocket.onerror = function(e) &#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e) &#123; self.onopeninfo = ''; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;, close:function(e) &#123; websocket.close(); &#125;, &#125;, &#125;&lt;/script&gt; Have a try","type":"references"},{"title":"webview","path":"cn/references/modules/webview.html","permalink":"https://weex.apache.org/cn/references/modules/webview.html","text":"webview#一系列的 &lt;web&gt; 组件操作接口。 比如 goBack、goForward、和 reload。webview module 与 &lt;web&gt; 组件共用。 示例#查看 简单浏览器 ，一个结合 &lt;web&gt; 组件和 webview module 的示例。 API#goBack(webElement)#加载历史记录里的前一个资源地址。 参数# webElement {Element}：&lt;web&gt; 组件对象。 goForward(webElement)#加载历史记录里的下一个资源地址。 参数# webElement {Element}：&lt;web&gt; 组件对象。 reload(webElement)#刷新当前页面。 参数# webElement {Element}：&lt;web&gt; 组件对象。 注意事项：未来 &lt;web&gt; 组件的 Element 对象将会支持直接这些方法，届时 webview module 将不再需要 Example#&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"group\"&gt; &lt;input class=\"input\" v-model=\"value\" ref=\"input\" type=\"url\" autofocus=\"false\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div class=\"group\"&gt; &lt;text class=\"button\" @click=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"button\" @click=\"reload\"&gt;reload&lt;/text&gt; &lt;/div&gt; &lt;web ref=\"webview\" :src=\"url\" class=\"webview\" @pagestart=\"start\" @pagefinish=\"finish\" @error=\"error\"&gt;&lt;/web&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const webview = weex.requireModule('webview') const modal = weex.requireModule('modal') export default &#123; data () &#123; return &#123; url : 'https://m.alibaba.com', value: 'https://m.alibaba.com' &#125; &#125;, methods: &#123; loadURL (event) &#123; this.url = this.value modal.toast(&#123; message: 'load url:' + this.url &#125;) setTimeout(() =&gt; &#123; console.log('will go back.') modal.toast(&#123; message: 'will go back' &#125;) webview.goBack(this.$refs.webview) &#125;, 10000) &#125;, reload (event) &#123; console.log('will reload webview') modal.toast(&#123; message: 'reload' &#125;) webview.reload(this.$refs.webview) &#125;, start (event) &#123; console.log('pagestart', event) modal.toast(&#123; message: 'pagestart' &#125;) &#125;, finish (event) &#123; console.log('pagefinish', event) modal.toast(&#123; message: 'pagefinish' &#125;) &#125;, error (event) &#123; console.log('error', event) modal.toast(&#123; message: 'error' &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .group &#123; flex-direction: row; justify-content: space-around; margin-top: 20px; &#125; .input &#123; width: 600px; font-size: 36px; padding-top: 15px; padding-bottom: 15px; border-width: 2px; border-style: solid; border-color: #BBBBBB; &#125; .button &#123; width: 225px; text-align: center; background-color: #D3D3D3; padding-top: 15px; padding-bottom: 15px; margin-bottom: 30px; font-size: 30px; &#125; .webview &#123; margin-left: 75px; width: 600px; height: 750px; border-width: 2px; border-style: solid; border-color: #41B883; &#125;&lt;/style&gt; try it","type":"references"},{"title":"Extend JS framework","path":"guide/advanced/extend-js-framework.html","permalink":"https://weex.apache.org/guide/advanced/extend-js-framework.html","text":"Extend JS framework#This part of the extension of JS framework is still in the discussion, may be adjusted at any time, please pay attention. Weex wants to be able to respect as many developer development habits as possible.So, in addition to Weex official support Vue 2.0, the developer can also customize and horizontally extension their own or their favorite JS Framework.The steps to customize the JS Framework are as follows: First you have a complete set of JS Framework. Learn about Weex’s JS engine feature support. Adapting Weex’s native DOM APIs. Adapting Weex’s initialization portal and multi-instance management mechanism. Add your own JS Framework to the framework configuration of the Weex JS runtime. Then pack it. Build JS bundles based on the JS Framework. You need to add a specific prefix comment so that the Weex JS runtime can recognize it. Weex JS engine features support# Under iOS, Weex uses the JavaScriptCore that comes with the system, so the ES support depends on the version of the operating system.The current conservative judgments, ES5 features on the market mainstream iOS devices are perfectly supported, but some of the features of ES6 + is not supported. Under Android, Weex uses the v8 kernel provided by UC. For performance and stability considerations, we are not using the latest version of the v8 kernel.The same conservative judgment, the ES5 feature can all support, including strict mode Object.freeze and so on. The Weex JS engine does not support HTML DOM APIs and HTML5 JS APIs, including document, setTimeout`, and so on. We added Promise‘s polyfill, as well as the console‘s polyfill. In addition, in order to ensure that the JS engine can manage memory as much as possible, we have a generic global object for the Object.freeze () freeze operation, which includes: Object Object.prototype Array Array.prototype String.prototype Number.prototype Boolean.prototype Error.prototype Date.prototype RegExp.prototype Adapt to Weex’s initial entry and multi-instance management mechanism#The JS Framework provided by the developer needs to be packaged as a CommonJS package, and the package needs to be extension to the following methods: Framework initialization# init(config) config Document Element Comment TaskSender CallbackManager This method places the Native DOM class and two auxiliary classes provided by Weex in the config parameter and allows the framework itself to be initialized. Tip: At the same time, the author can pass in a different config in the framework of the initialization time. This allows for framework testing or environmental simulation. Introduction to parameter format# TaskSender: wip… CallbackManager: wip… Register available native components and modules# registerComponents(components) registerModules(modules) These two methods are called immediately after the frame is initialized. This framework will be able to know which components and modules the current client supports. Introduction to parameter format# components: Array: Describe the array of components, each of which includes: type: string: Component name, for example div。 methods: string[]: Optional, a list of method names supported by this component. These methods can follow the native DOM APIs call. modules: Object: Describe the hash table of a series of modules. Key is the module name, the value is an array. The elements of the array describe a method in the module. The information of the method includes: name: string: Method name args: string[]: Parameter number and type description E.g: registerComponents([ &#123; type: 'web', methods: ['goBack', 'goForward', 'refresh']&#125;])registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ]&#125;) Multi - instance lifecycle management# createInstance(instanceId, code, config, data, env) refreshInstance(instanceId, data) destroyInstance(instanceId) Each Weex page has two stages: created and destroyed. At the same time in the Weex page running process, native can send messages to the Weex page. Different frameworks can follow their own ideas to achieve the message. Introduction to parameter format# instanceId: string: The unique id of the Weex page is generated by native. code: string:The Wex page’s JS bundle’s code is passed through native. config: Object?: The configuration information for the Wex page, such as the bundleUrl representing the bundle address, is generated by the native configuration. It has nothing to do with the contents of the JS bundle itself. data: Object?: Native can import an external data when creating a Weex page. The JS framework can also generate different page content for the same JS bundle with different data. env: Object?:The current environment information about the Weex page, the meaning of each field: info: Object: Framework information, see the “JS Bundle format requirements” later. config: Object:Equivalent to the third parameter of the method config callbacks: CallbackManager: only CallbackManagerinstance of Weex page. created: number:The number of seconds that the Wex page was created. framework: string:The name of the framework used by the Wex page. Equivalent to info.framework. Native communication# receiveTasks(instanceId, tasks) Native can use the refreshInstance method to send a message to the JS framework layer. But in many cases will use receiveTasks to send user events or methods callback to the JS framework. For example, if the user clicks on a button, native will send a fireEvent type of task to the JS framework, and then the JS framework will handle the corresponding event logic. This part of the working mechanism is related to the design of the addEvent in the native DOM interface. Another example is the user using fetch to send network requests. When the request is done at the native end, it will be sent to the JS framework with a callback type of task. Since native can not pass the function in JavaScript, it actually only sends a callbackId to the JS framework. This part of the working mechanism is related to the design of CallbackManager. Auxiliary method# getRoot(instanceId): JSON This method returns the full JSON description of the document body node. Developers can view the full native DOM tree as a result. The format of the specific return value is the same as the return method of the toJSON () method in the native DOM interface. This feature is used extensively as a developer tool extension. Configure the JS Framework in WeexSDK#Prepare your JS Framework code#// your-own-js-framework.jsexport function init (config) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function createInstance (id, code, config, data, env) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; Register a JS Framework#import * as Vue from '...'import * as React from '...'import * as Angular from '...'export default &#123; Vue, React, Angular &#125;; And then packaged JS runtime, integrated into WeexSDK. JS Bundle format requirements#Framework infoThe note(alias framework info) at the beginning of the JS Bundle file is very important. The format is as follows: // &#123; \"framework\": \"Vue\" &#125; So that the Weex JS engine will know that the JS bundle needs to use the Vue framework to resolve.Similarly, Weex supports multiple frameworks.It will be based on js bundle notes to select the corresponding framework resolution.","type":"guide"}],"posts":[{"title":"Weex ❤️ iOS 11 系列之二：ARKit初探","path":"en/arkit/","link":"","permalink":"https://weex.apache.org/en/arkit/","text":"ARKit#苹果在wwdc 2017公布了第一款具有AR功能的操作系统iOS11，并提供了AR的SDK，ARKit，同时宣称苹果是世界上最大的AR平台，Weex也积极拥抱AR，让Weex用户也可以方便开发AR功能 AR体验就是创建和追踪用户所在的现实世界和可建立模型的空间的对应关系的能力，让用户感觉产生虚拟内容在现实世界的错觉，这就是所谓的增强现实。ARKit通过识别图像场景中的显著特征，追踪这些特征的差异位置，最后与传感器数据比较，得到设备位置和运动状态的高精度模型 原理#ARkit 在ARSCNView，ARSession,ARFrame的基础上实现 ARSCNView和ARSession#ARKit提供了两种增强现实的视图，他们分别是ARSCNView(3D)和ARSKView(2D),这两种视图都采用ARCamera作为视图背景的，而ARSCNView等视图和相机没有直接关系，他们是通过ARSession这个桥梁和camera交互的，运行一个session，需要指定会话追踪配置的对象：ARSessionConfiguration，ARSessionConfiguration负责追踪相机在3D世界中的位置和平面探测 ARWorldTrackingSessionConfiguration与ARFrame#ARWorldTrackingSessionConfiguration通过一系列的复杂计算和调用传感器来跟踪设备的方向和位置，当ARWorldTrackingSessionConfiguration计算出位置，会交给ARSession管理,ARSession就会维护一个相机的位置ARFame，用户可以通过这个frame将4x4矩阵世界坐标转换为3D系统相机坐标 weex-ar#ARKit在wwdc上带来的震撼效果，我通过weex插件的方式将ARKit能力透传到Weex，让用户在weex上也第一时间体验到Native的AR效果所有的demo以及源码我已经开源，同步到github，用户在自己工程依赖即可使用 在现实世界渲染一个3D的虚拟物体#this.$refs[&apos;scene&apos;].addNode(&#123; name:&apos;color&apos;, width:0.1, height:0.1, length:0.1, chamferRadius:0, vector:&#123; x:0.1, y:0.1, z:-0.5 &#125;, contents:&#123; type:&apos;color&apos;, name:&apos;red&apos; &#125; &#125;); Weex在compnonent中增加addNode方法，用户可以设置好节点的参数，然后就会构建一个虚拟物体 效果 交互支持#当native触发了点击事件，会向jsfm发送点击位置信息 -(void)tapped:(UITapGestureRecognizer *)recognizer&#123; SCNView *sceneView = (SCNView *)recognizer.view ; CGPoint touchLocation = [recognizer locationInView:sceneView]; [self fireEvent:@&quot;tap&quot; params:@&#123;@&quot;touchLocation&quot;:@&#123;@&quot;x&quot;:@(touchLocation.x),@&quot;y&quot;:@(touchLocation.y)&#125;&#125;];&#125; 当VUE接收到相关信息，会处理位置信息，然后更新节点tap:function (event) &#123; this.index = this.index+1; if(this.index&gt;3)&#123; this.index = 0; &#125; var color = &apos;red&apos;; if(this.index == 1)&#123; color = &apos;blue&apos;; &#125; if(this.index == 2)&#123; color = &apos;green&apos;; &#125; if(this.index == 3)&#123; color = &apos;yellow&apos;; &#125; this.$refs[&apos;scene&apos;].updateNode(&#123; name:&apos;color&apos;, x:event.touchLocation.x, y:event.touchLocation.y, color:color &#125;) &#125; 效果 碰撞游戏#设置节点的mask，通过arkit的代理就可以检测碰撞了node.physicsBody.categoryBitMask= [self getMask:[WXConvert NSInteger:[options objectForKey:@&quot;categoryBitMask&quot;]]]; node.physicsBody.contactTestBitMask= [self getMask:[WXConvert NSInteger:[options objectForKey:@&quot;contactTestBitMask&quot;]]]; 当碰撞发生时候，会通过physicsWorld:(SCNPhysicsWorld )world didBeginContact:(SCNPhysicsContact )contact代理获取到节点的信息，weex将相关信息发送到jsfmvue获取先关节点可以删除节点，增减节点，从而完成碰撞的处理contact:function (event) &#123; if(event.nodes.nodeA.mask == 0 || event.nodes.nodeB.mask == 0 )&#123; this.isAdd = false; this.$refs[&apos;scene&apos;].removeNode(event.nodes.nodeA.name); this.$refs[&apos;scene&apos;].removeNode(event.nodes.nodeB.name); &#125; &#125; 效果","type":"blog"},{"title":"Weex ❤️ iOS 11 系列之一：Core ML 初探","path":"en/coreml/","link":"","permalink":"https://weex.apache.org/en/coreml/","text":"背景#WWDC 2017 有一个非常明确的信号：端上机器学习将会是未来苹果的一个重要发力点，同时开发者的使用门槛在不断降低。 Core ML 是今年 WWDC 上苹果发布的机器学习框架。它允许开发者在自己开发的 app 上使用机器学习，同时不需要收集用户数据。 有了 Core ML，你可以将自己训练得到的模型，借助苹果提供的转换工具，转化成 Core ML 类型的模型文件，你可以非常轻松地直接实现模型和 app 数据的互通。 WWDC 上展示了一张简单的架构图： 最底层的 Accelerate 和 MPS，其实是苹果去年推出的接口，前者可以直接调用 CPU，后者则直接调用 GPU。 Core ML 会自行决定到底使用 CPU 还是 GPU 来进行运算，可以最大程度地利用硬件资源来处理模型数据。 而 Core ML 往上一层则是应用层。Vision 主要负责图像相关的人工智能处理，如人脸识别、面部追踪、文字识别等等；NLP 则提供语义分析相关 API。这部分内容在以前版本的 SDK 中也存在，这次被集成到了新框架当中。好处在于，开发者拥有了更大的自由度。在以前，开发者的 app 调用这些高级接口，对底层的实现细节的掌控力度非常小。现在，你可以通过自定义底层所使用的机器学习模型，从而实现更个性化的需求。 Weex-ML#Weex 交互视觉能力小结中提到，Weex 最大的特别之处在于其 native 的能力， 我们要最大化利用 native 的特性， 而不是去模仿它。 作为本次 iOS 11 的一个重要 native 能力，我也第一时间尝试将 Core ML 透传到了 Weex 上。所有代码和 Demo 都已开源到 Github，后续也会将机器学习相关的Weex 模块统一放到 Weex Market 上。 得益于 Core ML API 的简洁，在 Weex 上使用 Core ML 相关能力变得非常简单: let imageRecognition = weex.requireModule('imageRecognition')imageRecognition.predictWithImage(this.$refs.image.ref, (results)=&gt;&#123; this.results = results.slice(0,5);&#125;) 通过调用透传的 module imageRecognition , 并传入 image 组件的 ref 作为参数，就可以实现图片识别的功能，最后提取出识别结果中 confidence 最高的 5 个结果。 Demo#imageRecognition# 使用 Inceptionv3 作为模型，能够高效识别， 该模型已经在 keras 中被训练好并通过苹果提供的工具转换成 mlmodel 文件， 只需拖拽的方式就可以集成到 iOS 开发环境中， 上述 demo 输出了对一张图片分类最大可能的5个预测结果， 对于 Weex 来说，几行代码就能搞定。 digitDetect# 上述 demo 首先使用 weex-gcanvas 插件做了一个简单的绘制板，然后使用 MNIST model 完成了对手写数字的识别。 faceDetect# 这个 demo 没有加载任何 model，使用了 iOS 11 内置的 Vision Framework，顾名思义，Vision 可以让开发者运行计算机视觉相关的任务，它相当于 Core ML 的 High-Level Solution， 它可以做很多事情: 脸部识别，会返回一个矩形数组来表示每一个脸部 脸部更精细识别，比如眼睛和鼻子的具体位置、头部的形状等，上述 demo 就是拿到这些信息以后使用 gcanvas 绘制出了面部精细轮廓 图片中的矩形探测 图片中的文字探测 二维码/条形码探测 视频中跟踪移动的物体 总结#这次 Core ML 的推出，同时得益于苹果对软硬件的全面掌控，使得从系统级到第三方开发者，都具备了在端上就可以进行机器学习模型处理的能力。所有代码和 Demo 都已上传到 Github，欢迎贡献和交流。 当然在实际研究过程中，也发现了 Core ML \u0005的一些限制： 无法在端上进行模型的训练，所有模型必须提前训练好再转换成 Core ML 的格式 无法动态下载和更新模型，对于需要经常重新训练的模型不太友好 目前看只支持监督学习的模型，不支持非监督学习。 Weex 未来在提供更多功能透传的同时，也会继续探索更深层次的结合。 最后，本文是 Weex 和 iOS 11 结合系列的第一篇文章，后续将会有更多有意思的iOS 11 feature (如 ARKit、 drag &amp; drop 等) 和大家一起探讨。","type":"blog"}]}